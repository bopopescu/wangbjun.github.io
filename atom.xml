<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JWang的博客</title>
  
  <subtitle>一点记录和想法，分享并成长</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wangbjun.github.io/"/>
  <updated>2020-02-07T08:30:45.351Z</updated>
  <id>https://wangbjun.github.io/</id>
  
  <author>
    <name>Ben Jun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>谈谈城市化和农村现状</title>
    <link href="https://wangbjun.github.io/2020/02/07/city-and-county/"/>
    <id>https://wangbjun.github.io/2020/02/07/city-and-county/</id>
    <published>2020-02-07T04:57:19.000Z</published>
    <updated>2020-02-07T08:30:45.351Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此次疫情爆发，有人说现在农村最安全，因为农村一般都是自建房，分布零散，而城市里面都在小区里面，住在火柴盒一样的格子楼里面，进出同一个楼道，同一个电梯，被感染的几率大很多。</p></blockquote><p>我从小在农村长大，自始至今，依然是个农村人（户口还在农村），大学之后，基本上都在城里面上班工作，但是过年还是在老家。有时候早上还在车水马龙、遍布高楼大厦的城里面，晚上就来到了农村蛙声一片的田野边，一个是现代化的城市，另一个是传统的农村，感触十分之深。</p><p>今天我就聊聊我一些关于农村和城市的事和想法，可能比较零散，纯属回忆！</p><a id="more"></a><h2 id="一样的经历"><a href="#一样的经历" class="headerlink" title="一样的经历"></a>一样的经历</h2><p>我在农村长大这些年的时光几乎和很多农村人一样，曾经也住过土房子，经常下河抓鱼摸虾，插过秧也种过地。。。很多和我年龄一样大但是在城里长大的孩子肯定没有经历过，但是或许他们父母（也可能是爷爷奶奶）经历过。</p><p>有趣的是，相对于和我同龄的人，我们虽然年龄相同但是经历不同，但我和他们父母虽然不在一个年龄段却可能拥有相同的经历。我相信，即使在2020年的今天，中国依然有很多孩子留守在农村，过着和我20年前差不多一样的农村生活。</p><h2 id="房地产市场化"><a href="#房地产市场化" class="headerlink" title="房地产市场化"></a>房地产市场化</h2><p>从农村到城市，这样的过程依然在很多地方进行着，只不过不同人可能处于不同的阶段，有些人可能在30年前就完成了这个过程。</p><p>有人说现在很多的城里人以前也是农村人，确实是这样，中国的城市化的快步发展很大程度上得益于国家政策的变化，也就是房地产市场化，开放城市落户，差不多是最近20年才完成的事情。我们盖了大概可以容纳30亿人的房子，全民都在买房、炒房，房子成为每个人最值钱的财产。</p><h2 id="落寞的小洋楼"><a href="#落寞的小洋楼" class="headerlink" title="落寞的小洋楼"></a>落寞的小洋楼</h2><p>我记得我上小学初中的时候那会，大约在03年左右，农村都在盖自建房以代替之前的土瓦房，那会很流行盖“小洋楼”，一般多为2-3层的楼房，现在你去农村看看还有很多，大部分都荒废了，因为农村根本没人了，即使现在农村几乎家家都有水泥路，有些地方甚至都通了自来水，光纤网络，虽然基础设施建设并不差，但是没人愿意住农村。</p><p>我在想，那会为什么没有人去城里买房呢？那会估计房子几百块一平方米就可以吧？</p><img src="/images/2020-02-07.jpeg" width=70% /> <p>其实并不是他们不想买，是因为根本买不到，我不知道中国房地产正式市场化具体时间点是什么时候，但是我肯定那会你在城里面买不到房子，也落不了户口，孩子更上不了学。</p><h2 id="割裂的家族"><a href="#割裂的家族" class="headerlink" title="割裂的家族"></a>割裂的家族</h2><p>农村有很多小村庄，一个村里面的基本上都是亲戚，毕竟那会兄弟姐妹很多，我有一个大伯，早年当兵，部队退伍之后给安排在省会，之后他们那一岔全部都在城里面发展了，他的子女就是原生的城里人了。早些年，村里老一辈在世的时候有时候还会回农村过年，清明节也会回家祭祖，小时候他们经常回来带着胶卷相机给我们拍照。</p><p>在农村，传统的血缘关系家族早已分崩离析，有钱的亲戚基本上都进了城，更有钱的甚至出了国，没钱的还在农村，久而久之就不联系了。即便现在网络通信发达，动动手指就能聊天视频，也懒的去问候寒暄。</p><p>传统的大家族时代一去不复返，现在很多人只生1个子女，慢慢在一个城市生根发芽，会逐渐演变成小家族（家庭）时代，我觉得这个重组的过程大约需要2代人吧。</p><blockquote><p>城里人亲戚基本上都在一个城市，而很多农村人的亲戚基本上遍布全国，这大概就是相濡以沫，不如相忘于江湖。</p></blockquote><h2 id="无处安放的土地"><a href="#无处安放的土地" class="headerlink" title="无处安放的土地"></a>无处安放的土地</h2><p>有些人可能不知道种地一年能挣多少钱，更不知道农业税有多重。我家以前大概分了10亩地，我记得忙活一年收的稻谷大概能卖5000块钱，其中农业税大概需要2000块钱。事实上，农业税只是统称，那会农村的税目不比现在企业的少，其中包括修路修桥、水利等很多类目。</p><p>在我上小学的时候，那些年农业税征收是政府的大事，每年秋收之后，田野间经常能看到浩浩荡荡的村干部一行十几人，挨家挨户催收。有些村民远远看见村干部来了，会关门出去躲开，但也有硬碰硬的，经常发生打架事件，村干部被打伤打死的事情时有发生。</p><p>那时候官民关系非常紧张，我亲眼所见，我叔的稻谷被村干部找来收粮人“强行”卖掉拿来交税（一般稻谷春季价格高一点，所以很多人会留着不卖），你不卖村干部帮你忙，卖了还帮你数钱，多的还你，比劫匪好一点。</p><blockquote><p>那时候中国工业刚刚起步，政府用农业补贴工业，对农民的压榨太狠了，后来工业差不多发展起来了，最终取消了农业税。</p></blockquote><p>为什么没人愿意种地？原因其实很简单，水稻小麦的价格是由政府定的（传说中的指导价），这个定价基本上是不让你饿死就行了，现在你随便去城里打工，一年收入也有好几万，你会为了几千块在家种地吗？</p><h2 id="农场主制度"><a href="#农场主制度" class="headerlink" title="农场主制度"></a>农场主制度</h2><p>现在农村的土地大部分都是承包给个人种植了，也就是说传说中的农场主制，不过这和美国的农场主差远了。土地大规模承包确实有利于机械化种植，发挥规模效益，但是其实很有限。很多地方连农场主都不想干了，土地就荒废了，原因很简单，也挣不了多少钱，一方面粮食价格国家控制，另一方面农药化肥价格是市场控制，作为种地的人，你什么都控制不了，连收成还得看天。</p><h2 id="消失的村镇"><a href="#消失的村镇" class="headerlink" title="消失的村镇"></a>消失的村镇</h2><p>这几年在农村过年晚上放烟花的人越来越少，农村基本上已经没人了，城里还不给放，印象中农村过年烟花放的最多的时候大约在05年左右，那会晚上农村还很热闹。</p><p>在农村有很多村和镇，有些地方逐渐发展壮大，有些地方逐渐消失，发展一个县城可能要吸引下面几十个乡镇的人口迁移，如果不这样做，那么多房子卖给谁呢？</p><p>但是光把房子盖起来，没有配套的工作，买了房又有什么用？这是很多三四线城市面临的问题</p><h2 id="房子还是公寓？"><a href="#房子还是公寓？" class="headerlink" title="房子还是公寓？"></a>房子还是公寓？</h2><p>在美国，一般说房子（house），是指那种带院子的独栋建筑，而中国所说的房子其实在美国一般被称为公寓（department），也就是格子房。在中国也有房子，不过一般都是别墅，很多大城市郊区都遍布了大规模的别墅群，但是和美国比还是差远了，而中国农村的自建房其实也可以算是别墅的一种。</p><p>如果你用过Google的卫星地图，你可以看看美国的城市，你会发现美国的城市规模非常之大，全部都是独栋建筑，很少有类似中国的高层小区。所以很多人戏称美国是大农村，没毛病，和中国农村差不多。</p><img src="/images/2020-02-07-2.jpeg" width=70% /> <p>中国这种密集的高层小区便于管理，可以很好利用公共基础设施，同时方便了快递、外卖、共享单车等行业发展，但是其弊端已经在慢慢展现。</p><p>如果能解决交通问题，我相信很多人还是愿意住在郊区、住在农村，每天开车去城里上班，而不用住在城中心拥挤的出租房或者监狱一样的格子楼。</p><h2 id="人口红利在消失"><a href="#人口红利在消失" class="headerlink" title="人口红利在消失"></a>人口红利在消失</h2><p>这基本上已经是公认的事实，很多年轻人受过教育，再加上中国不是一个尊重蓝领的社会，所以很多都不太想从事体力劳动，宁愿去拍段子玩抖音也不会去送快递。</p><p>在北上广这样的一些城市，只要你肯吃苦，无论是送快递还是送外卖，这些体力活一个月上万收入不是问题。即使在很多工厂的流水线上面，现在一个月拿5-6000块钱也不是什么难事。</p><p>我们父母这一代现在很多已经50多岁，基本快干不动，90后已经快30岁了，这群人马上就要成为社会主力。在未来，只要是涉及人力的活以后的成本会越来越高，这一点我们可以参考美国等发达社会，蓝领的工资很多时候比在办公室的白领还高，这种趋势势不可挡。</p><h2 id="李子柒式农村生活"><a href="#李子柒式农村生活" class="headerlink" title="李子柒式农村生活"></a>李子柒式农村生活</h2><p>中国的农村在很多人的印象里面只有一个字：穷，农村人几乎已经成了穷人的代言词，现在除了个别风景优美的地区被开发成了风景区，大部分农村和美也沾不上边。</p><p>李子柒给大家营造了一个梦想中的田园生活，而现实中的农村生活往往充满了破败荒芜，每个人都在努力工作努力赚钱，憧憬着买房买车，亦或是为子女忙碌。大部分农村人背井离乡，只为在城里面买房定居，过上更好的生活。</p><img src="/images/2020-02-07-1.jpeg" width=50% /> <p>或许当我们无欲无求的时候，才可以像李子柒视频那样潇洒，日出而作，日落而息，双手去耕作，用汗水收获果实。</p><p>农村的田园生活已经离我们太遥远了，在工业化时代，规模经济是趋势，社会分工日益明确，你不用亲手去种植蔬菜，你只需要选择一个可以挣钱的工作就行，你可以是流水线工人，也可以是办公室白领。</p><h2 id="如果"><a href="#如果" class="headerlink" title="如果"></a>如果</h2><p>如果我可以选择，我选择与自然为舞，不被高房价绑架，也不必终日为工作劳累，花更多的时间陪陪家人！你会怎么选？</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;此次疫情爆发，有人说现在农村最安全，因为农村一般都是自建房，分布零散，而城市里面都在小区里面，住在火柴盒一样的格子楼里面，进出同一个楼道，同一个电梯，被感染的几率大很多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我从小在农村长大，自始至今，依然是个农村人（户口还在农村），大学之后，基本上都在城里面上班工作，但是过年还是在老家。有时候早上还在车水马龙、遍布高楼大厦的城里面，晚上就来到了农村蛙声一片的田野边，一个是现代化的城市，另一个是传统的农村，感触十分之深。&lt;/p&gt;
&lt;p&gt;今天我就聊聊我一些关于农村和城市的事和想法，可能比较零散，纯属回忆！&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="https://wangbjun.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="Life" scheme="https://wangbjun.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>一个普通人眼里的“武汉肺炎”</title>
    <link href="https://wangbjun.github.io/2020/02/06/wuhan-fy/"/>
    <id>https://wangbjun.github.io/2020/02/06/wuhan-fy/</id>
    <published>2020-02-06T01:51:06.000Z</published>
    <updated>2020-02-06T03:12:49.456Z</updated>
    
    <content type="html"><![CDATA[<p>截止我写这篇文章的时候，这次肺炎病毒已经感染了数万人，而且还在持续增长！</p><img src="/images/2020-02-06.jpg" width=60% /> <p>每天醒来第一件事情就是打开手机，刷新一下数据，从最开始的几百人、到几千人、再到现在的几万人。。。在这里我想说说自己看到或者了解到的一些社会现象，谈谈自己的感受。</p><p>在我的记忆力，2003年还非常遥远，那时候我应该还在上初中，记得那时候学校被封闭，外人不得进出，教室每天早上都会有一股浓厚的消毒水味。</p><a id="more"></a><p>由于我平时也会逛逛油管，在油管上面有很多“时政”自媒体，这也就是一些墙外消息的来源，人所以很早之前也听过一些“谣言”，说说武汉出现SARS病毒了。这种非官方新闻我一般都是半信半疑，在没有确凿证据的情况下也不敢全信，更不敢传播，不然被定个罪就麻烦了。</p><p>2020年1月19日，新闻说北京大兴有2例确诊，当天上班的时候也有很多讨论这件事，这时候很多人开始慌张了，公司前台给大家发口罩，不过我并没有要。</p><p>我当时觉得这事并没有多大，毕竟连政府都没什么行动，北京才2例，觉得很多人有点大惊小怪，有些朋友开始跑医院买口罩，很多医院的口罩卖空，一下子口罩成了稀缺品。晚上坐地铁的时候发现大约有50%的人都戴了口罩。那会我还没有把这事放在心上，因为买不到口罩所以上班也没戴口罩，甚至感觉某些人反应过度，开始拼命的要买口罩。</p><p>我是2020年1月22日的火车，从北京南站出发，那时候我发现候车厅大约80%的人都戴了口罩，感觉事态有点严峻，由于我自己没口罩，所以刻意和其他人保持了距离。</p><img src="/images/2020-01-22.jpeg" width=60% /> <p>2020年1月22日晚，坊间传言武汉要封城，我一个朋友这时候正在回家的火车上，她刚好要从武汉转车，听她说车上人都慌了，有人怕封城出不去直接在中途郑州站下车了。后来正式新闻出来了，1月23日10点，武汉正式封城。</p><p>实际上，这会官方数据确诊只有几百人，但是这种封城动作让人胆战心惊，网上各种“谣言”四起，其实很多“谣言”都是来自墙外新闻，我一直也在油管上关注，有人说凡是官方辟谣的都是真的，不管你们信不信，我反正是信了。</p><p>过年这段时间，非常糟糕，在家里哪里都不能去，走亲访友的计划全部取消。。。然后接连不断的新闻爆出: 出门不戴口罩违法、封城、封村、挖坑断路、假期延长、武汉人被举报排挤，只见疫情事态逐步升级！</p><img src="/images/2020-01-27.jpeg" width=60% /><p>由于我所在公司宣布2月3日起在家办公，但是我回家的时候并没有电脑，所以我决定2月2日返京。我们那高铁依然正常运行，入站的时候需要测体温，听说我走后第二天村就被封路了。</p><img src="/images/2020-02-02.jpeg" width=60% /><p>火车站人确实很少，不过我那车刚好是晚上，本身人就不多，火车上卧铺上我那间6个床位只有我一个人，我走了一圈看了下，大部分床位都没人，看来返京的人确实不多。</p><p>到了北京，我进地铁的时候看见几个安检员在那嬉笑，居然没有给我测体温。网上新闻报道北京很多小区不允许租房的人进小区，我并没有遇到这种情况，只是在门口登记了一下，虽然配备了测温枪，但是那保安并没有给我测量体温。</p><p>有一件意料之外的事情，大家都知道这次疫情对工业、餐饮、娱乐、旅游、交通等很多行业是个致命的打击，可以说整个国家经济都受到影响，损失非常惨重。但是很多小的口罩厂却发财了，这些口罩厂原来多是生产一些工业口罩、一次性普通口罩或者布口罩，原来卖几毛钱一个，利润率非常低，甚至可以说濒临倒闭，现在可以卖几块钱一个，虽然从单价上看并不贵，但是价格缺翻了很多倍。大家知道现在口罩太难买了，我至今出门只戴了一个布口罩，心理安慰是其一，主要是不戴口罩出不了门。短期内很多工厂都开不了工，口罩的缺口依然很大，毕竟中国有14亿人口，平时戴口罩的人很少，市场需求不大，现在人人都要戴口罩，即使所有口罩厂全力生产也无法满足需求，现在连一次性的普通口罩都买不到，更别说什么N95口罩。</p><p>这次病毒什么时候是个头？很多公司原定10号正式返岗上班的计划又遍了，有人说15号或许是个拐点，也有人得到2月底，很多地方的管控越来越严。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;截止我写这篇文章的时候，这次肺炎病毒已经感染了数万人，而且还在持续增长！&lt;/p&gt;
&lt;img src=&quot;/images/2020-02-06.jpg&quot; width=60% /&gt; 

&lt;p&gt;每天醒来第一件事情就是打开手机，刷新一下数据，从最开始的几百人、到几千人、再到现在的几万人。。。在这里我想说说自己看到或者了解到的一些社会现象，谈谈自己的感受。&lt;/p&gt;
&lt;p&gt;在我的记忆力，2003年还非常遥远，那时候我应该还在上初中，记得那时候学校被封闭，外人不得进出，教室每天早上都会有一股浓厚的消毒水味。&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="https://wangbjun.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="Life" scheme="https://wangbjun.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>一个野生程序员的北漂之路（三）</title>
    <link href="https://wangbjun.github.io/2020/01/22/2019-3/"/>
    <id>https://wangbjun.github.io/2020/01/22/2019-3/</id>
    <published>2020-01-22T06:43:14.000Z</published>
    <updated>2020-02-06T01:52:18.699Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章说到我二家公司由于经营不善，濒临倒闭，拖欠工资，最终我选择自离找工作。</p><p>2018年03月，这次找工作非常顺序，我请假面了大概5个公司拿到2个offer，最后选择了一家我觉得还可以的公司，xx网，工资15k。</p><blockquote><p>xx网实际上是某大型教育公司下面一个部门的网站，专门面向程序员，并不是公司名字，很多学习编程的同学应该看过他们网站的课程。</p></blockquote><p>之前也看过他们网站的课程，觉得很不错，这个部门有100多人，其中技术40多人，在这家公司的上班体验总体还不错，除了每天早上无聊的站会以及每周周会，公司属于业务驱动型，大多做的一些业务开发。</p><p>直到2018年底春节放假那天，技术老大拉我进屋，悄悄告诉我，经过公司决定，你今年没有年终奖，我当时一脸懵逼，问他为什么？</p><a id="more"></a><p>他吞吞吐吐说因为什么线上bug，但是也说不清楚，说只是通知我一声，怕我不了解情况以为是漏发了。</p><p>后来得知不止我一个人，总共有好几个人都没有年终奖，据老员工透露一般没有年终奖的过完年会给n+1，意思就是过完年裁员会给n+1赔偿，公司也不是第一次这样干。</p><img src="/images/20200202152512.jpg" width=60% /> <p>其实裁员我可以理解，为什么都是我们年初刚入职的员工呢？了解才得知原来整个公司去年早就换血了，只剩下几个小组leader是老员工，其它都是新来的。</p><p>我更不理解，虽然这一年我表现不算突出，但也算是兢兢业业，努力工作，为什么选择我呢？我想过很多原因，直到离职后来听一个同事说，公司给他们涨薪了，但是名额有限，老大给他自己河南老乡全部涨了…</p><p>我平时大多数都是埋头写代码，不擅长在领导面前表现，一年下来基本上没有和老大聊过什么，他也只在周会的时候会询问项目进度，更别说其它的事情了，如果说bug的话，写代码谁没有bug。</p><p>这时候我突然想起来公司年初的骚操作，年初公司入职的人非常多，正常是3个月试用期，然而就在试用期快结束的时候，有几个同事被告知试用期不合格，被辞退，我在办的入职他们在办离职。如果不合适就不要招人进来，招人之后干了3个月最后一天辞退，这种行为实在恶心。</p><p>过完年回来之后，我在忙完手头的工作，拿了2个月补偿就走了，对这种公司我没有什么留恋，也不想多待一天。</p><img src="/images/20200202152503.jpg" width=60% /> <p>公司有一个同事和我比较熟，后来聊天的时候他说他工资比较低，只有12k，老大过年前和他说年后给他涨工资，但是一直到次年6月份都没有兑现，最后他也走了。</p><blockquote><p>后来才得知，这家公司，负责这个项目的老大是销售出身，集团公司给我们部门定了销售KPI，由于远远没有达到预期目标，所以就拿技术开刀，不是第一次这样了，每年都会裁人招人，公司的文化就是这样，谁遇到谁倒霉。</p></blockquote><p>本以为这是一个拥有2000多人的公司，应该会稳定点，没想到我又栽了，又得重新找工作了。</p><hr><p>2019年03月，我重新整理了简历，开始了面试，这时候招聘市场早一年不如一年了，非常艰难，我的直属领导其实还挺好，找关系给我内推了，也给了offer，虽然最后我没去那家公司。</p><p>面了半月，拿到几个offer，有些薪资太低就没去了，有些是因为公司太小，不想去创业公司了。最终去了一家互联网金融集团下面的子公司，这家公司技术团队有200多人，我们部门有15个人，从技术团队建设上说，这家公司其实非常不错，比我去过的所有公司都要好。</p><blockquote><p>刚入职那会我对p2p还没什么概念，虽然也看了新闻，知道国家一直在管理规范p2p，清退一些不合格企业，但是这个公司借贷规模上百亿，也是上市公司，论体量也属于头部公司了，应该没问题。</p></blockquote><img src="/images/20200202154032.jpg" width=60% /> <p>2019年07月，董事长突然来公司给大家开了一个临时会议，给大家透露了一些情况，主要就是说政策又变了，公司非常难，他在努力解决困难，公司平台遭到挤兑，暂停提现了，如果大家有人要走，他也不拦着。这时候我才知道事情的严峻性，国家可能不会给p2p活路了。</p><p>一直在公司被抓之前，公司陆续有人离职，也在陆续招人，我们部门走了2个，我心里知道其实早就会有这一天，只是时间问题，但是我没有选择走，一方面是我们部门领导对我还行，中间还给我提了一次涨薪，虽然不多，还有就考虑到我刚来公司不久离职工作也不好找工作，决定再坚持一段时间，心想至少等过完年再看吧。</p><p>那会公司依然正常运行，工资不仅没有拖欠，经常还提前发，公司还给所有人都买了商业医疗补充保险，一切正常，谁也不知道哪一天什么时候到来。</p><p>2019年12月，早上，我还在地铁上，有人在公司群里说公司下面有好几辆警车，还有大巴，让我们先不要进公司，出事了。有些早上到公司的同事电话也打不通，谁也不知道是什么情况，直到下午5点某地公安局在网上发了一个蓝色通告，坐实被抓了。</p><blockquote><p>后来得知，那些同事都被警察安排坐在工位上，没收手机电脑，上厕所有人跟着，中午吃的盒饭，最终下午6点多的时候才放出来，公司所有电脑无论个人还是公司的，全部被查封带走调查了。</p></blockquote><p>领导让我们在家等消息，其实大家心里都清楚，基本上是完了，接连不断的新闻告诉我们，即使公司没有问题，p2p也是完了。。。</p><p>其实公司有没有问题我真不知道，有人担心作为公司员工会被追缴工资，这一点暂时还不确定，目前案件还在审理中，我也是受害者，我还在里面投资了1万多，也一样没有拿出来。</p><p>就这样，我又失业了…</p><hr><p>这几年，不知道是不是该说运气不好，之前的创业公司倒闭很正常，最近2年的公司规模也算比较大，但结局却一样悲惨，正如很多人说的垃圾公司毁一生，选择很重要，你不知道你进的公司是什么公司，特别是很多不出名的中小型公司，你也不知道你会遇到什么样的领导。</p><p>我知道以我现在的简历，很多公司都过不了，很多HR一看就认为跳槽频繁，工作不稳定，再加上非科班出身，出路很少！</p><p>我对自己的评价是工作态度认真负责、学习理解能力强，但是我并不是大牛，也不是那种可以手撸各种算法、精通各种源码和底层原理的技术大佬。</p><p>虽然这些年很多叫我大佬，但我知道那也只是客气话，技术这行了解的越多会发现你不会的更多，而且对于互联网技术现在基本上大家已经形成共识：淘汰快。</p><p>以前觉得技术很厉害，可以改变世界，现在觉得改变世界的其实是商业、是资本，技术只不过是商业工具，有时候也充当打手。</p><p>这几年一直很焦虑，实际上大部分技术人都是这样，总感觉有太多东西要去学，这个算法那个数据结构、xx架构、xx源码解读，卖课的公众号数不胜数，每天都在贩卖焦虑，看不完的技术视频和文章。。。</p><p>我现在甚至不太想去写代码了，这是一份相当枯燥和无聊的工作，你需要去解读产品的X逼需求，应付领导的傻X检查，去做很多和技术无关的工作！而且大部分公司并不重视你的代码质量，他们只关心项目进度，能不能按时上线，能不能为他带来利益。</p><p>最后，就这样吧，谢谢阅读！希望新的一年有新的变化！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章说到我二家公司由于经营不善，濒临倒闭，拖欠工资，最终我选择自离找工作。&lt;/p&gt;
&lt;p&gt;2018年03月，这次找工作非常顺序，我请假面了大概5个公司拿到2个offer，最后选择了一家我觉得还可以的公司，xx网，工资15k。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;xx网实际上是某大型教育公司下面一个部门的网站，专门面向程序员，并不是公司名字，很多学习编程的同学应该看过他们网站的课程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前也看过他们网站的课程，觉得很不错，这个部门有100多人，其中技术40多人，在这家公司的上班体验总体还不错，除了每天早上无聊的站会以及每周周会，公司属于业务驱动型，大多做的一些业务开发。&lt;/p&gt;
&lt;p&gt;直到2018年底春节放假那天，技术老大拉我进屋，悄悄告诉我，经过公司决定，你今年没有年终奖，我当时一脸懵逼，问他为什么？&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="https://wangbjun.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="Life" scheme="https://wangbjun.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>一个野生程序员的北漂之路（二）</title>
    <link href="https://wangbjun.github.io/2020/01/22/2019-2/"/>
    <id>https://wangbjun.github.io/2020/01/22/2019-2/</id>
    <published>2020-01-22T01:17:16.000Z</published>
    <updated>2020-02-06T01:52:18.695Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章说到我第一家公司因为融资断裂，发不起工资，解散了。这时候我们开发里面一位大佬，这里我称他为Q哥，他也刚进公司不久，如果按职级分，他应该属于高级开发工程师，平时带我们做项目，也会参与开发，毕竟当时公司开发人员不多。</p><p>当时他说他有个朋友给他介绍了一个公司，这公司非常缺人，可以直接带我们过去，不用技术面试，他和老板聊好了，我们过去见一下老板就行了。</p><a id="more"></a><p>第二天，我们几个人和老板在一个大酒店的套房里面见了面，老板看上去比较老，大概50多岁，叼着雪茄和我们聊了一些他的往事人生以及一些商业战略，最后还请我们吃了一顿简餐。</p><p>搞定了老板基本上就没问题了，老板想让我们直接入职，但公司的HR不答应，最后还给我们安排了一个HR面试，聊了聊人生以及薪资待遇，我没有要求涨薪，其中有一个小伙伴因为薪资没谈拢最后没去，最终Q哥带着我们上家公司总共不到10人空降了该公司。</p><blockquote><p>后来得知，其实这个公司也不完全是缺人，他们之前有一个不到10人的开发团队，但是项目开发进度缓慢，处于失败的边缘。听说老板花了上百万开了一个盛大的发布会，但是APP还没上线，延期很久，老板非常生气，想把技术团队都开除。</p></blockquote><p>我们空降之后，就立马开始了1个多月的封闭开发，加班加点，Q哥也一直盯着开发进度，最终顺利完成了预期目标。作为奖励，年底整个技术团队获得了一次海南三亚游，次年6月，公司搬入望京SOHO，换了一个非常大的办公室。</p><img src="/images/20161222.jpg" width=60% /> <blockquote><p>后来了解，这老板花钱请了很多大公司的顾问，有几个BAT的技术顾问，也许是出于融资对外宣传需求，给人感觉很强大，而且技术团队之前一直是有这个百度的大佬兼职带队，就是不知道为什么进度缓慢，也没做出什么东西，据说他们之前已经做了一年多了。</p></blockquote><p>APP顺利上线后，看上去公司蒸蒸日上，但运营了几个月后发现并没有什么效果，此时Q哥主要心思不在技术上，甚至说他几乎不管技术，突然搞起运营了，亲自带队搞运营，这也最终导致了他的出走。</p><p>公司失败的原因有很多种，可能是这个老头子最终发现很多人都在围着他转，看上的是他的钱并没有用心做事，再加上他本身喜欢对产品指指点点，喜欢按着自己的想法做，比如说根据自己的想法给APP加一个功能，也从不考虑用户，整个公司说是面向老板开发也不过分。</p><p>2017年10月，由于业务基本上无增长，而且据说一年花了2000万，老板不想再投钱了，公司开始裁员，裁了几个人，办公室也从望京SOHO搬到望京西很偏的一个小商住两用办公楼，各种福利缩减，刚开始工资还能正常发放，后来每月都要拖欠工资，很多人开始离职。</p><img src="/images/20170727.jpg" width=60% /> <blockquote><p>老板其实挺有钱，早年发家，经常去美国，那边也有业务，家人都在国外，拔过他的背景，也有些黑料，但人并不傻。这次创业应该在我来之前大约2年前就开始了，只不过不是这个公司，这个公司是后来重新注册，应该属于第二波尝试，这样几番折腾，几年下来基本上算是创业失败了。</p></blockquote><p>当时有的人劳动合同到期，公司也表示不再续期，让自己走人，没有什么工作可干，但是公司后面也不再裁员了，但是工资经常拖欠，不能按时发放，等到2018年春节之后，公司很多人都在找工作，我也趁机走了。</p><blockquote><p>不过还有同事没走继续在那边干，听他说后来没走的人每个月工资只发了一半，到最后人基本上都跑光了，可以说结果很悲催。</p></blockquote><p>我上一家公司虽然也是创业公司，但是最后起码好聚好散，但这家公司了老板最终选择故意拖欠工资逼你自己离职，当时很多人说要一起去告公司，不最终还是不了了之。</p><p>说到Q哥，我对他非常感激，他人很不错，但是说实话缺少领导力，感激是因为他带我进入这家公司，虽然最后发现是个火坑，但是这也不能怪他，谁也无法预料后来的事情。还有一点不信任是因为他后来的行为，他在这家公司大部分时间并没有管理技术，没有当好CTO，却去插上并扛下运营和产品，最终由于他的运营方案失败，自己出走，留下我们几个人不知所措。</p><p>他出走之后却又带着一位同事进入另一家类似公司，而这家公司一直是用比较传统的方法运营，但是其互联网这块是从零开始，老板据说是从华为出来，印象挺深的是我们第一次Q哥带我们和他见面的时候，刚下班还没吃晚饭，他说请我们吃饭，最后带着我们几个人在路边找了家面馆一人吃了一碗面，场面甚是尴尬！</p><p>Q哥说他技术入股，先带一个人过去，又拉了一个他以前的同事，等这边搞起来后期我们一起再过去。</p><p>可是好景不长，这家公司只持续了几个月，他们第一版东西做完之后，这个华为出来的老板居然打了退堂鼓，不想干了，不仅没有和他们签合同，连工资都一直拖着不发，最后沟通很久说可以搬电脑抵工资。。。结局就是就这么狗血！</p><p>这时候Q哥说又有朋友介绍一家新公司，说这家公司就是为了上市，资金实力雄厚，他以顾问的身份进去，可以推荐我们进去。。。说实话，经过这么多，我有点怕了，怕了创业公司。。。另外对Q哥的信任度也大大降低!</p><img src="/images/20171225.jpg" width=60% /> <blockquote><p>Q哥是第一代北漂，比我们大不了多少岁，也是农村出来，但是来的早，赶上了IT行业发展的黄金时代，而且那会北京房价也不高，现在在北京有房有车，老婆孩子都很好，在我看来，算上成功人士了。但他自己好像并不是这么觉得，他觉得自己还没财务自由，总想做点事情出来，30多岁也算年轻，不想写代码，创业是个不错的选择。</p></blockquote><p>但是我其实并不想把所有宝都压在创业上面，我其实想找一个相对稳定的公司，所以后来他让我去他那边公司的时候我犹豫了，我最后决定自己投简历…</p><blockquote><p>虽然很久没有和Q哥聊了，但是知道他一直在创业，现在在做一个教育相关的小程序，希望他早日创业成功！</p></blockquote><p>这1年多，看尽了创业公司的各种结局，很多小创业公司九死一生，但是结局却各不相同。很多创业公司倒闭并不是因为技术，大部分都是因为商业模式，或者说是运营不起来，没有市场等各种原因，总之，创业难，想创业成功更难。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章说到我第一家公司因为融资断裂，发不起工资，解散了。这时候我们开发里面一位大佬，这里我称他为Q哥，他也刚进公司不久，如果按职级分，他应该属于高级开发工程师，平时带我们做项目，也会参与开发，毕竟当时公司开发人员不多。&lt;/p&gt;
&lt;p&gt;当时他说他有个朋友给他介绍了一个公司，这公司非常缺人，可以直接带我们过去，不用技术面试，他和老板聊好了，我们过去见一下老板就行了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="https://wangbjun.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="Life" scheme="https://wangbjun.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>一个野生程序员的北漂之路（一）</title>
    <link href="https://wangbjun.github.io/2020/01/21/2019-1/"/>
    <id>https://wangbjun.github.io/2020/01/21/2019-1/</id>
    <published>2020-01-21T15:32:27.000Z</published>
    <updated>2020-02-06T01:52:18.687Z</updated>
    
    <content type="html"><![CDATA[<p>虽然2020年已经到来，但是真正象征着新的一年的农历新年才刚刚开始，北漂4年多，IT这条路越走越窄，突然萌生出回家的念头，毕竟年龄也不小，算是90后最早一批奔三的人，还未成家，也谈不上立业。</p><p>在此回顾一下这些年在北京这几年的职业生涯，作为一种记录，也算是总结吧！</p><p>这些年在北京，工作换了很多个，几乎每年面试一次，微信里面同事倒是加了不少，除了聊的好的几个，大部分再也不联系。住的地方也是一年换一次，住过上下铺、地下室、天通苑、自如、一居室。。。</p><ul><li>2016年06月 第一家公司 –&gt; 融资失败、解散</li><li>2016年11月 第二家公司 –&gt; 濒临倒闭、欠薪</li><li>2018年03月 第三家公司 –&gt; 经营不善、裁员</li><li>2019年03月 第四家公司 –&gt; 涉及p2p、查封</li></ul><a id="more"></a><p>2015年10月，也许是在外漂泊够了（在此之前我一直在从事一份非常自由的工作），腰里揣着几万块钱，我决定来北京，去报名某智的培训班，学习Java。</p><p>为什么我要这么做？主要是因为从大学时代开始，我对编程就非常感兴趣，写过一点C，经常喜欢看一些关于计算机和网络的书籍，但是当时没有想过深入的学习，更没有想过毕业后会从事该行业，那时候纯粹是一些兴趣爱好。后在2013年的时候，在网上看到一些自学成才的例子，开始有这个想法，在家里自学过半年Java，买了几本书，也看了不少视频，但是最终因为各种原因并没有实际去找相关工作，曾经考虑过进培训班，但是当时也没钱就打消了这个念头，后来误打误撞去干别的事情了。</p><blockquote><p>现在回想起来，当时犯了一些错：单打独斗、学习效率不高、缺乏自信。主要是缺乏有经验的人指导，如果坚持下去或许是另一种结果，毕竟2013年那会IT的工作很好找，不像现在年年寒冬，各种裁员。</p></blockquote><p>时间回到2015年10月，这时候我已经有一定的经济能力，但是工作依然不稳定和明朗，也不知道该干啥去，但是觉得不能一直这么干下去，最终选择来北京培训，这个培训班的学费也从当年的几千块涨到1万多，不过尚可以接受。</p><p>不过最终报名的时候我选择了PHP，并没有学习Java，我当时主要是因为有人说PHP适合个人等中小型开发，而Java主要适合大型企业公司，其实现在这个说法也没错，但是当时我并不了解其实国内大厂都是Java的天下，PHP最终走向穷途末路。</p><img src="/images/20160219-1.jpg" width=60% />  <p>由于我几年前学过C和Java，相当于有基础，所以在培训班非常轻松，很多知识似曾相识，甚至觉得老师讲的太无聊，基本上就是照本宣书，填鸭式教学。同时也发现培训班就像高中一样，有很多学习能力超级差的同学，也有学习能力强的人，我旁边有一些让我感觉属于那种怎么教都教不会的人，非常可惜他们听了培训机构的忽悠，花了很多钱，最终可能无法找到工作。</p><blockquote><p>那会我开始研究Linux，天天折腾Ubuntu，还有Kali，最有意思的是我用Kali的木马工具生成一些木马，然后利用PHP一句话木马攻破讲师的电脑，远程控制其电脑，还在其电脑上找到了我们班所有人的信息。<br>还有，比如说控制某些女生的电脑，打开其摄像头。。。不过纯属搞笑娱乐，并没有做一些过分的事情。</p></blockquote><p>在培训的这几个月里面，我真正学到东西不是很多，培训班大部分讲的东西都很基础，而且枯燥，老师每一个知识点写一个demo，缺乏编程思想层次的指导。对我来说最大的意义在于这段培训经历帮我建立了自信，因为我发现在所有的同学中我即使不是能力最强的，也是属于前排，心里对自己的能力有了一个定位。</p><p>时间过的很快，半年后，2016年5月，我们开始找工作了，出于无耐，我编了一个1年经验的简历，也有一些同学编了2-3年，还有更过分的则是造假学历、假毕业证，虽然这些都是培训机构默认的常规操作。</p><p>我这个人本身就不属于那种会说的人，以前撒谎都会脸红那种，虽然进入社会好几年但是依然无法做到游刃有余，在找了差不多半个月，面试了10几家公司之后终于拿到一个offer，虽然公司不大也是创业公司有10来个开发，但是毕竟是一个开始，工资是12k，社保最低缴纳，对我来说已经很好了，据说在所有的同学中算高的了，可能是因为我有一个本科学历吧，那时候大部分培训的同学都是专科。</p><blockquote><p>那会2016年正是创业潮，初创企业层出不穷，所以市场对开发人员有很大需求，所以像我这种半路出家的非科班选手依然有市场。</p></blockquote><p>第一次正式参加公司的编程开发工作，心里还有点紧张，很努力，不过也基本上都hold住了，然而这段工作并没有维持多久。。。</p><img src="/images/20160722-1.jpg" width=60% /> <p>2016年11月，公司突然撑不住了。我之前一直没有关注这方面的消息，直到某一天老板说公司融资断了，发不起工资了，如果大家继续留下来也没有工资发，晚上一起吃个散伙饭吧！</p><p>那天是当月的20号，公司最后给每个人发了3000块钱，剩下的说先欠着，等哪天融到钱会第一时间给大家发工资，也可以继续回来工作，公司40多号人没有一个人提赔偿的事情，大家吃完饭喝完酒默默走人了，毕竟老板平时为人不错，不摆架子，好聚好散。</p><blockquote><p>这几年一直和其中一个同事有联系，听他说公司并没有倒闭，留了几个老员工做一些维护和少量开发工作，他就是其一。老板也在一直拉投资，客户也一直在增长，那年与其说倒闭，不如说是壮士断臂。在2018年底的时候，他和我说公司拉到了一笔投资，也不多，大概有几百万，公司正在招人扩大规模。我一直相信老板的话，觉得公司融到钱后把欠我们的半个月工资还给我们，事实上，至今老板从未和我们谈过这件事，我也未去询问过。不过我还是非常佩服这位老板的耐心和毅力，祝他早日能创业成功。</p></blockquote><p>在工作了还不到半年的时候，突然间我又失业了，又得重新找工作，但是事情却另有转机。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然2020年已经到来，但是真正象征着新的一年的农历新年才刚刚开始，北漂4年多，IT这条路越走越窄，突然萌生出回家的念头，毕竟年龄也不小，算是90后最早一批奔三的人，还未成家，也谈不上立业。&lt;/p&gt;
&lt;p&gt;在此回顾一下这些年在北京这几年的职业生涯，作为一种记录，也算是总结吧！&lt;/p&gt;
&lt;p&gt;这些年在北京，工作换了很多个，几乎每年面试一次，微信里面同事倒是加了不少，除了聊的好的几个，大部分再也不联系。住的地方也是一年换一次，住过上下铺、地下室、天通苑、自如、一居室。。。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2016年06月 第一家公司 –&amp;gt; 融资失败、解散&lt;/li&gt;
&lt;li&gt;2016年11月 第二家公司 –&amp;gt; 濒临倒闭、欠薪&lt;/li&gt;
&lt;li&gt;2018年03月 第三家公司 –&amp;gt; 经营不善、裁员&lt;/li&gt;
&lt;li&gt;2019年03月 第四家公司 –&amp;gt; 涉及p2p、查封&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="生活" scheme="https://wangbjun.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="Life" scheme="https://wangbjun.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github搭建免费技术博客</title>
    <link href="https://wangbjun.github.io/2020/01/08/hexo-github-blog/"/>
    <id>https://wangbjun.github.io/2020/01/08/hexo-github-blog/</id>
    <published>2020-01-08T04:05:45.000Z</published>
    <updated>2020-01-09T07:51:48.660Z</updated>
    
    <content type="html"><![CDATA[<p>最近想搭建了一个自己的博客网站，经过调研，最终决定使用Hexo+Github的形式搭建，大概花了3个小时的时间，这里简单记录一下过程，备用。</p><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>Github提供了一个免费的GIthub Pages功能，简单说就是可以让你存放静态的资源文件，比如css、js、html、image，同时会给你分配一个免费域名，格式：<a href="http://xxx.github.io" target="_blank" rel="noopener">http://xxx.github.io</a></p><p>所以你只需要注册一个Github账号，然后新建一个repository就行了，一毛线都不用花。</p><p>由于Github Pages只能托管静态资源，所以像WordPress这类博客肯定是无法运行的，这时候你有2种选择：</p><ol><li>手写静态页面，如果是前端大牛可以尝试这样</li><li>第三方博客工具生成，如Hexo、jekyll</li></ol><a id="more"></a><p>简单说，Hexo就是一个工具，它可以根据markdown文档自动生成博客的静态HTML页面，同时呢，你还可以一键换主题，网上有很多开源的主题。</p><p>Hexo 和 Github这2个完全可以单独使用，但是把2个结合起来就完美了，一个用来生成博客的静态文件，一个用户托管静态资源，服务器和域名都省了。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol><li><p>我不会告诉你如何注册Github账号、以及安装使用Git，作为一名编程开发人员应该都会</p></li><li><p>我其实也不想告诉你如何安装npm和node，但是我还是放个下载地址：<a href="https://nodejs.org/zh-cn" target="_blank" rel="noopener">https://nodejs.org/zh-cn</a></p></li></ol><h2 id="Hexo应用"><a href="#Hexo应用" class="headerlink" title="Hexo应用"></a>Hexo应用</h2><h3 id="安装运行环境"><a href="#安装运行环境" class="headerlink" title="安装运行环境"></a>安装运行环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装完成后，在命令行下执行hexo，应该可以看到以下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">jwang@jun:~$ hexo</span><br><span class="line">Usage: hexo &lt;command&gt;</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  help     Get help on a command.</span><br><span class="line">  init     Create a new Hexo folder.</span><br><span class="line">  version  Display version information.</span><br><span class="line"></span><br><span class="line">Global Options:</span><br><span class="line">  --config  Specify config file instead of using _config.yml</span><br><span class="line">  --cwd     Specify the CWD</span><br><span class="line">  --debug   Display all verbose messages in the terminal</span><br><span class="line">  --draft   Display draft posts</span><br><span class="line">  --safe    Disable all plugins and scripts</span><br><span class="line">  --silent  Hide output on console</span><br><span class="line"></span><br><span class="line">For more help, you can use &#39;hexo help [command]&#39; for the detailed information</span><br><span class="line">or you can check the docs: http:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;</span><br></pre></td></tr></table></figure><p>这里只是列出一部分命令，比较重要的就是init，它是用来创建一个新项目</p><h3 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p>文件夹名字自己起一个，它自动生成一个目录，里面文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── _config.yml</span><br><span class="line">├── db.json</span><br><span class="line">├── package.json</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><blockquote><p>简单说明一下，比较重要是有_config.yml文件,这是博客的配置，另外themes下是存放主题的目录，还有source下面的 _posts 目录，是博客文章markdown的源文件。</p></blockquote><p>然后我们进入该目录，生成静态文件并启动服务预览一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd blog</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>默认启动在本地4000端口，可以通过 -p 指定端口</p><h3 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &lt;article-name&gt;</span><br></pre></td></tr></table></figure><p>其实有2种方式写文章，一种是使用上述命令 new 一个，它会自动在source目录的_posts里面创建一个markdown文件。另一种就是你自己手动创建。</p><p>但是注意，文章头部会有一些注解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: Hexo+Github搭建免费技术博客</span><br><span class="line">date: 2020-01-08 12:05:45</span><br><span class="line">tags: Hexo</span><br><span class="line">category: 其它</span><br></pre></td></tr></table></figure><p>Hexo在生成静态页面的时候会解析这些注解，然后做一些处理，比如tags是标签、category是文章分类，都会用到。</p><p>不要忘记，每次更新文章之后，都需要执行<code>hexo g</code>重新生成静态页面。</p><h2 id="部署到GitPages"><a href="#部署到GitPages" class="headerlink" title="部署到GitPages"></a>部署到GitPages</h2><p>上面介绍如何使用Hexo生成博客，但是这时候只能在本地玩，如果你有自己的服务器的话，也可以不用GitPages，你把生成的静态文件，也就是public目录下的文件部署到你自己的服务器就行了。</p><p>如果你想部署到GitPages，那么继续接着看</p><blockquote><p>有一点需要注意，在创建GitPage仓库的时候，仓库名字最好是: 你的用户名.github.io 这种格式，如果不这样其实也行，就是分配的域名有点丑，比如说你仓库名字叫blog，那么域名就会变成 xxx.github.io/blog</p></blockquote><p>打开Hexo的配置文件_config.yml，修改repo为刚创建的仓库地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;YourgithubName&#x2F;YourgithubName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>为了更好的提交代码，我们需要安装一个插件 <code>npm install hexo-deployer-git --save</code></p><p>然后，我们使用<code>hexo d</code>就可以把代码提交到Github仓库了。</p><blockquote><p>等等。。。有人说网上很多文章还说要配置什么ssh秘钥，其实这块我觉得不是必须的，只是为了更方便的提交代码而已，具体步骤这里不再赘述。</p></blockquote><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>Hexo更换主题特别简单，只需要把主题文件夹clone到themes文件里面，然后修改_config.yml里面的 theme 配置项。</p><p>详细的步骤我这里就不解释了，你可以在Github使用 “hexo themes”关键字搜索，然后按照其readme文档说明安装即可，非常简单。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>如果你配置了ssh秘钥，则必须把deploy配置里的repo配置 https 地址改成 ssh 地址。</li><li>很多主题都有一个自己的_config.yml配置文件，里面有一些详细配置，比如是Next这个主题默认没有打开分类和标签项，需自己配置。</li><li>如果想实现“阅读全文”这种效果，有2种方式，第一种是需自己在markdown里合适的位置作注解，默认是 <code>&lt;!--more--&gt;</code>，还有一种在主题的配置里面，可以自动根据字数折叠，但是默认不推荐这种方式。</li><li>每个主题都有很多自定义的配置项，比如样式、字体、评论、浏览数，很多默认都没开启，可以好好看一下，都有注释。</li><li>最重要的一点，所有的东西都是开源的，如果你觉得很多样式或者细节不合适完全可以打开模板修改定制。</li></ol><p>最后，如果你闲麻烦，觉得我的博客还可以，想参考一下可以访问我的<a href="https://github.com/wangbjun/blog_hexo" target="_blank" rel="noopener">Github</a>，所有的文件和配置都在里面，欢迎采用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近想搭建了一个自己的博客网站，经过调研，最终决定使用Hexo+Github的形式搭建，大概花了3个小时的时间，这里简单记录一下过程，备用。&lt;/p&gt;
&lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;Github提供了一个免费的GIthub Pages功能，简单说就是可以让你存放静态的资源文件，比如css、js、html、image，同时会给你分配一个免费域名，格式：&lt;a href=&quot;http://xxx.github.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://xxx.github.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以你只需要注册一个Github账号，然后新建一个repository就行了，一毛线都不用花。&lt;/p&gt;
&lt;p&gt;由于Github Pages只能托管静态资源，所以像WordPress这类博客肯定是无法运行的，这时候你有2种选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;手写静态页面，如果是前端大牛可以尝试这样&lt;/li&gt;
&lt;li&gt;第三方博客工具生成，如Hexo、jekyll&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://wangbjun.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Hexo" scheme="https://wangbjun.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>解决Golang测试配置文件加载问题</title>
    <link href="https://wangbjun.github.io/2019/11/19/golang-gin-config/"/>
    <id>https://wangbjun.github.io/2019/11/19/golang-gin-config/</id>
    <published>2019-11-19T03:49:25.000Z</published>
    <updated>2020-01-08T17:51:03.557Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写Go的项目，使用的框架是Gin，众所周知，Gin是一个比较简单的框架，只提供了核心功能，并没有配置文件模块，所以这块得自己搞了，Go的第三方解析配置的库非常多，无论是ini、yaml、json文件支持都非常好，而且Go的项目一般都是常驻进程的，所以只需要在项目启动的时候解析一次就行可以了。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>最简单的办法通常就是定义一个全局的配置变量供其它包使用，在init函数里面初始化加载配置文件，示例如下：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package config</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;gopkg.in&#x2F;ini.v1&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var Conf Config</span><br><span class="line"></span><br><span class="line">type Config struct &#123;</span><br><span class="line">App      App</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type App struct &#123;</span><br><span class="line">Port    string</span><br><span class="line">Debug   string</span><br><span class="line">Url     string</span><br><span class="line">LogFile string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">envFile :&#x3D; &quot;app.ini&quot;</span><br><span class="line">conf, err :&#x3D; ini.Load(envFile)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">log.Panicf(&quot;parse conf file [%s] failed, err: %s&quot;, envFile, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">sectionApp :&#x3D; conf.Section(&quot;APP&quot;)</span><br><span class="line">Conf.App &#x3D; App&#123;</span><br><span class="line">Port:    sectionApp.Key(&quot;PORT&quot;).String(),</span><br><span class="line">Debug:   sectionApp.Key(&quot;DEBUG&quot;).String(),</span><br><span class="line">Url:     sectionApp.Key(&quot;URL&quot;).String(),</span><br><span class="line">LogFile: sectionApp.Key(&quot;LOG_FILE&quot;).String(),</span><br><span class="line">&#125;</span><br><span class="line">log.Println(&quot;init config file success&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，入口文件main.go文件都是位于项目根目录下面，和app.ini文件同级，所以这种写法完全没问题。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>但是当你跑测试用例的时候，而且当这个测试用例并不在项目根目录的时候就会产生问题: 找不到配置文件。</p><p>原因很简单，Go的测试用例最佳实践是和被测试的文件放在一起，所以测试文件可能在二级、三级甚至多级目录里面，如下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">├── app.ini</span><br><span class="line">├── config</span><br><span class="line">│   ├── Config.go</span><br><span class="line">│   └── DataBase.go</span><br><span class="line">├── controller</span><br><span class="line">│   ├── BaseController.go</span><br><span class="line">├── lib</span><br><span class="line">│   ├── function</span><br><span class="line">│   │   ├── Aes.go</span><br><span class="line">│   │   ├── Rsa.go</span><br><span class="line">│   │   ├── Rsa_test.go</span><br><span class="line">│   │   └── Uuid.go</span><br><span class="line">│   ├── httpLogger</span><br><span class="line">│   │   └── HttpLogger.go</span><br><span class="line">│   └── zlog</span><br><span class="line">│       ├── SqlLog.go</span><br><span class="line">│       └── ZapLogger.go</span><br><span class="line">├── main.go</span><br></pre></td></tr></table></figure><p>所以在测试文件的目录下肯定是找不到app.ini的，咋办呢？解决方法有很多</p><ul><li>copy一个配置到测试文件。这种方法最简单粗暴，但是太不灵活，测试用例可能在任何目录里面，这样搞有点难受</li><li>配置文件路径写成绝对路径。这种方法也不灵活，毕竟每个人的项目目录位置不一样，以后线上部署也麻烦</li><li>采用依赖注入的高级写法，测试的时候使用mock的方式注入配置。这种方法可以，也是比较好的方式，但是需要引入依赖注入组件，整个项目的架构需要更改，不推荐使用依赖注入把简单的问题复杂化。</li><li>跑测试的时候传入外部参数，依然不够灵活，而且麻烦</li></ul><p>这个问题，我思考了很久，最终想了一个足够简单灵活的方式，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">envFile :&#x3D; &quot;app.ini&quot;</span><br><span class="line">&#x2F;&#x2F; 读取配置文件, 解决跑测试的时候找不到配置文件的问题，最多往上找5层目录</span><br><span class="line">for i :&#x3D; 0; i &lt; 5; i++ &#123;</span><br><span class="line">if _, err :&#x3D; os.Stat(envFile); err &#x3D;&#x3D; nil &#123;</span><br><span class="line">break</span><br><span class="line">&#125; else &#123;</span><br><span class="line">envFile &#x3D; &quot;..&#x2F;&quot; + envFile</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">conf, err :&#x3D; ini.Load(envFile)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">log.Panicf(&quot;parse conf file [%s] failed, err: %s&quot;, envFile, err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一个for循环解决了这个问题，如果怕不够保险，可以改成10，大多数项目目录应该不会这么深，虽然不够优雅，但是还是相对比较简单的。</p><p>各位有什么更好的方法吗？有的话请留言指教</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在写Go的项目，使用的框架是Gin，众所周知，Gin是一个比较简单的框架，只提供了核心功能，并没有配置文件模块，所以这块得自己搞了，Go的第三方解析配置的库非常多，无论是ini、yaml、json文件支持都非常好，而且Go的项目一般都是常驻进程的，所以只需要在项目启动的时候解析一次就行可以了。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h2&gt;&lt;p&gt;最简单的办法通常就是定义一个全局的配置变量供其它包使用，在init函数里面初始化加载配置文件，示例如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程开发" scheme="https://wangbjun.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Golang的recover异常处理机制</title>
    <link href="https://wangbjun.github.io/2019/11/10/golang-recover/"/>
    <id>https://wangbjun.github.io/2019/11/10/golang-recover/</id>
    <published>2019-11-10T12:22:04.000Z</published>
    <updated>2020-01-08T17:38:26.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-error"><a href="#1-error" class="headerlink" title="1.error"></a>1.error</h2><p>Golang被诟病非常多的一点就是缺少强大方便的异常处理机制，大部分高级编程语言，比如Java、PHP、Python等都拥有一种try catch机制，这种异常捕获机制可以非常方便的处理程序运行中可能出现的各种意外情况。</p><p>严格来说，在Go里面，错误和异常是2种不同的类型，错误一般是指程序产生的逻辑错误，或者意料之中的意外情况，而且异常一般就是panic，比如角标越界、段错误。</p><a id="more"></a><p>对于错误，Golang采用了一种非常原始的手段，我们必须手动处理可能产生的每一个错误，一般会把错误返回给调用方，下面这种写法在Go里面十分常见：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s, err := say()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, err.Error())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"something error"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法最大的问题就是每一个error都需要判断处理，非常繁琐，如果使用try catch机制，我们就可以统一针对多个函数调用可能产生的错误做处理，节省一点代码和时间。不过咱们今天不是来讨论Go的异常错误处理机制的，这里只是简单说一下。</p><h2 id="2-panic"><a href="#2-panic" class="headerlink" title="2.panic"></a>2.panic</h2><p>一般错误都是显示的，程序明确返回的，而异常往往是隐示的，不可预测的，比如下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>, cal(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>, cal(<span class="number">5</span>,<span class="number">2</span>))</span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>, cal(<span class="number">5</span>,<span class="number">0</span>)) <span class="comment">//panic: runtime error: integer divide by zero </span></span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>, cal(<span class="number">9</span>,<span class="number">5</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a / b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行第三个计算的时候会发生一个panic，这种错误会导致程序退出，下面的代码的就无法执行了。当然你可以说这种错误理论上是可以预测的，我们只要在cal函数内部做好处理就行了。</p><p>然而实际开发中，会发生panic的地方可能特别多，而且不是这种一眼就能看出来的，在Web服务中，这样的panic会导致整个Web服务挂掉，特别危险。</p><h2 id="3-recover"><a href="#3-recover" class="headerlink" title="3.recover"></a>3.recover</h2><p>虽然没有try catch机制，Go其实有一种类似的recover机制，功能弱了点，用法很简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>, cal(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>, cal(<span class="number">5</span>, <span class="number">2</span>))</span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>, cal(<span class="number">5</span>, <span class="number">0</span>))</span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>, cal(<span class="number">9</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> a / b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，大家得理解defer的作用，简单说defer就类似于面向对象里面的析构函数，在这个函数终止的时候会执行，即使是panic导致的终止。</p><p>所以，在cal函数里面每次终止的时候都会检查有没有异常产生，如果产生了我们可以处理，比如说记录日志，这样程序还可以继续执行下去。</p><h2 id="4-注意的坑"><a href="#4-注意的坑" class="headerlink" title="4.注意的坑"></a>4.注意的坑</h2><p>一般defer recover这种机制经常用在常驻进程的应用，比如Web服务，在Go里面，每一个Web请求都会分配一个goroutine去处理，在没有做任何处理的情况下，假如某一个请求发生了panic，就会导致整个服务挂掉，这是不可接受的，所以在Web应用里面必须使用recover保证即使某一个请求发生错误也不影响其它请求。</p><p>这里我使用一小段代码模拟一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">requests := []<span class="keyword">int</span>&#123;<span class="number">12</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">41</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">31</span>&#125;</span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">range</span> requests &#123;</span><br><span class="line"><span class="keyword">go</span> run(n) <span class="comment">//开启多个协程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//模拟请求错误</span></span><br><span class="line"><span class="keyword">if</span> num%<span class="number">5</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"请求出错"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>, num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码无法完整执行下去，因为其中某一个协程必然会发生panic，从而导致整个应用挂掉，其它协程也停止执行。</p><p>解决方法和上面一样，我们只需要在run函数里面加入defer recover，整个程序就会非常健壮，即使发生panic，也会完整的执行下去。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>();err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">if</span> num%<span class="number">5</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"请求出错"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>, num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码只是演示，真正的坑是：如果你在run函数里面又启动了其它协程，这个协程发生的panic是无法被recover的，还是会导致整个进程挂掉,我们改造了一下上面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">if</span> num%<span class="number">5</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"请求出错"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> myPrint(num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myPrint</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> num%<span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"请求又出错了"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>, num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在run函数里面又通过协程的方式调用了另一个函数，而这个函数也会发生panic，你会发现整个程序也挂了，即使run函数有recover也没有任何作用，这意味着我们还需要在myPrint函数里面加入recover。但是如果你不使用协程的方式调用myPrint函数，直接调用的话还是可以捕获recover的。</p><p>总结一下就是defer recover这种机制只是针对当前函数和以及直接调用的函数可能产生的panic，它无法处理其调用产生的其它协程的panic，这一点和try catch机制不一样。</p><p>理论上讲，所有使用协程的地方都必须做defer recover处理，这样才能保证你的应用万无一失，不过开发中可以根据实际情况而定，对于一些不可能出错的函数加了还影响性能。</p><p>Go的Web服务也是一样，默认的recover机制只能捕获一层，如果你在这个请求的处理中又使用了其它协程，那么必须非常慎重，毕竟只要发生一个panic，整个Web服务就会挂掉。</p><p>最后，总结一下，Go的异常处理机制虽然没有很多其它语言高效，但是基本上还是能满足需求，目前官方已经在着完善这一点，Go2可能会见到。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-error&quot;&gt;&lt;a href=&quot;#1-error&quot; class=&quot;headerlink&quot; title=&quot;1.error&quot;&gt;&lt;/a&gt;1.error&lt;/h2&gt;&lt;p&gt;Golang被诟病非常多的一点就是缺少强大方便的异常处理机制，大部分高级编程语言，比如Java、PHP、Python等都拥有一种try catch机制，这种异常捕获机制可以非常方便的处理程序运行中可能出现的各种意外情况。&lt;/p&gt;
&lt;p&gt;严格来说，在Go里面，错误和异常是2种不同的类型，错误一般是指程序产生的逻辑错误，或者意料之中的意外情况，而且异常一般就是panic，比如角标越界、段错误。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程开发" scheme="https://wangbjun.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Protobuf入门和实战</title>
    <link href="https://wangbjun.github.io/2019/10/22/golang-protobuf/"/>
    <id>https://wangbjun.github.io/2019/10/22/golang-protobuf/</id>
    <published>2019-10-22T09:15:43.000Z</published>
    <updated>2020-01-09T04:58:49.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>Protobuf（Google Protocol Buffer）是 Google公司内部的混合语言数据标准，目前已经开源，支持多种语言（C++、C#、Go、JS、Java、Python、PHP），它是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。</p><p>说简单点，Protobuf就是类似JSON、XML这样的数据交换格式，当今互联网JSON是最流行的格式了，XML用的也挺多，最初接触到Protobuf是因为gRPC默认使用它作为数据编码，相比于JSON和XML，它更小，更快！</p><a id="more"></a><p>举个例子：如果我们想表达一个人名字叫John，年龄是28岁，邮箱是<a href="mailto:jdoe@gmail.com">jdoe@gmail.com</a>这样的结构化数据，并且需要在互联网上传输</p><ul><li><p>使用XML表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;person&gt;</span><br><span class="line">   &lt;name&gt;John&lt;&#x2F;name&gt;</span><br><span class="line">   &lt;age&gt;28&lt;&#x2F;age&gt;</span><br><span class="line">   &lt;email&gt;jdoe@example.com&lt;&#x2F;email&gt;</span><br><span class="line"> &lt;&#x2F;person&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用JSON表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: John,</span><br><span class="line">    age: 28,</span><br><span class="line">    email: jdoe@example.com</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用Protobuf表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message Person &#123;</span><br><span class="line">    string name &#x3D; 1;</span><br><span class="line">    int32 age &#x3D; 2;</span><br><span class="line">    string email &#x3D; 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>从可读性和表达能力上看，XML最好，JSON其次，而Protobuf这个其实只是一个DSL，用来定义数据结构和类型，实际生成的数据是二进制的，不可读，但Protobuf追求的是性能和速度，关于它们之间的对比，后面再说，咱们先说用法。</p><h2 id="2-安装环境"><a href="#2-安装环境" class="headerlink" title="2.安装环境"></a>2.安装环境</h2><p>Protobuf的使用比较麻烦，首先需要安装Protobuf的编译工具(Protocol Buffers compiler)，Ubuntu环境下自带编译环境，其它平台可自行安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jwang@jwang:~$ protoc --version</span><br><span class="line">libprotoc 3.8.0</span><br></pre></td></tr></table></figure><p>然后还需要安装不同语言的运行环境，具体可以参考<a href="https://github.com/protocolbuffers/Protobuf" target="_blank" rel="noopener">github.com/protocolbuffers/Protobuf</a></p><h2 id="3-编写proto文件"><a href="#3-编写proto文件" class="headerlink" title="3.编写proto文件"></a>3.编写proto文件</h2><p>proto其实是一种DSL语法，这个proto文件最终会使用protoc编译成不同语言的文件，然后在程序里面调用，这也是Protobuf跨平台的关键。关于proto文件的语法这里不详细介绍，建议大家参考<a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="noopener">官方文档</a>，东西很多，也很详细。</p><p>我这里拿一个简单实际的例子（person.proto）来说明一下，建议大家使用Goland安装一个插件，这样有颜色还可以检查语法：</p><ul><li>第一行syntax是声明proto语法版本，如果不声明默认是2，建议使用3版本</li><li>然后是package也就包，这个影响到最后生成的go文件的包</li><li>后面message是用来声明一个数据对象，我觉得可以理解为结构体struct，这个数据对象有自己的数据成员，每个字段有类型和默认值。</li><li>proto的数据类型有标量类型和枚举类型，由于不同语言的数据类型不太一样，所以这里的类型和实际语言的类型有一个对应转换关系，具体可以参考官方文档</li><li>repeated 相当于声明一个数组，比如在上面的例子，意思就是car是一个string类型的数组</li><li>message可以嵌套声明，也可以引用一个类型</li><li>最迷惑的东西估计就是后面那个1,2,3,4…了，据官方文档的说法是为了在二进制格式里面标记数据，在每一个message里面必须是唯一的，从最小的1开始，一直可以到2的29次方-1，也就是536870911，但是19000到19999是保留的数字。</li></ul><p>基本语法还是挺简单的，不过有些深入的用法这里没有介绍到，想要了解的话务必查看官方文档，不过定义数据结构和类型只是第一步，接下来我们还要使用protoc把这个文件编译成对应语言的文件。</p><h2 id="4-编译proto文件"><a href="#4-编译proto文件" class="headerlink" title="4.编译proto文件"></a>4.编译proto文件</h2><p>以Go语言为例，建议切换到proto文件目录执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out&#x3D;. person.proto</span><br></pre></td></tr></table></figure><p>其中–go_out表示输出go版本的，其它语言把go替换就行了，比如–php_out、–java_out,=后面是需要输出的目录，我选择.表示当前目录，当然你也可以指定输入和输出目录，最后面则是需要编译的文件，可以指定单个文件，也可以使用通配符同时编译多个文件。</p><p>执行完命令之后，你会发现当前目录多了一个person.pb.go文件，这是一个标准的go语法文件，里面主要是一个结构体和一些getter函数，其它的我也不太懂是什么意思就不说了，但是并不影响我们使用。</p><h2 id="5-使用"><a href="#5-使用" class="headerlink" title="5.使用"></a>5.使用</h2><p>以Go为例，我们需要安装一个<a href="github.com/golang/Protobuf/proto">运行库</a>，其它语言也差不多，官方针对每一个语言都有一个单独的介绍文档，务必查阅一下。</p><p>下面是一个完整的案例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/golang/Protobuf/proto"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//实例化模型对象，填充数据</span></span><br><span class="line">p := &amp;Person&#123;</span><br><span class="line">Id:    <span class="number">1</span>,</span><br><span class="line">Name:  <span class="string">"jun"</span>,</span><br><span class="line">Age:   <span class="number">25</span>,</span><br><span class="line">Money: <span class="number">24.5</span>,</span><br><span class="line">Car:   []<span class="keyword">string</span>&#123;<span class="string">"car1"</span>, <span class="string">"car2"</span>&#125;,</span><br><span class="line">Phone: &amp;Person_Phone&#123;Number: <span class="string">"0551-12323232"</span>, Type: <span class="string">"1"</span>&#125;,</span><br><span class="line">Sex:   Person_female,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Marshal序列化</span></span><br><span class="line">out, err := proto.Marshal(p)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//序列化得到结果是二进制的，是不可读的，所以这里保存到文件</span></span><br><span class="line">file, _ := os.OpenFile(<span class="string">"out"</span>, os.O_CREATE|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">_, _ = file.Write(out)</span><br><span class="line">_ = file.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">//unMarshal还原数据，从文件里面读取</span></span><br><span class="line">in, _ := os.Open(<span class="string">"out"</span>)</span><br><span class="line">bytes, err := ioutil.ReadAll(in)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">p1 := &amp;Person&#123;&#125;</span><br><span class="line">err = proto.Unmarshal(bytes, p1)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//调用string()方法打印，也可以使用其生成的getter函数</span></span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, p1.String())</span><br><span class="line">        fmt.Printf(<span class="string">"%d\n"</span>, p1.GetId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-与JSON对比"><a href="#6-与JSON对比" class="headerlink" title="6.与JSON对比"></a>6.与JSON对比</h2><p>由于XML目前很少使用在Web API接口上，所以这里就不对比了，主要看一下和JSON的对比，包含2个方面：速度和大小。</p><p>为了测试，我在proto文件里面又加了一个数据对象，表示一个组里面有多个person对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message Group &#123;</span><br><span class="line">    repeated Person person &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别测试有1,10,100个对象的时候对比情况，测试代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkProto(b *testing.B) &#123;</span><br><span class="line">g :&#x3D; &amp;Group&#123;&#125;</span><br><span class="line">for i :&#x3D; 0; i &lt; 100; i++ &#123;</span><br><span class="line">p :&#x3D; &amp;Person&#123;</span><br><span class="line">Id:    int32(i),</span><br><span class="line">Name:  &quot;测试名称&quot;,</span><br><span class="line">Age:   int32(25 * i),</span><br><span class="line">Money: 240000.5,</span><br><span class="line">Car:   []string&#123;&quot;car1&quot;, &quot;car2&quot;, &quot;car3&quot;, &quot;car4&quot;, &quot;car5&quot;, &quot;car7&quot;, &quot;car6&quot;, &quot;car21&quot;, &quot;car22&quot;,&#125;,</span><br><span class="line">Phone: &amp;Person_Phone&#123;Number: &quot;0551-12323232&quot;, Type: &quot;1&quot;&#125;,</span><br><span class="line">Sex:   Person_female,</span><br><span class="line">&#125;</span><br><span class="line">g.Person &#x3D; append(g.Person, p)</span><br><span class="line">&#125;</span><br><span class="line">b.ResetTimer()</span><br><span class="line">        b.N &#x3D; 1000</span><br><span class="line">for i :&#x3D; 0; i &lt; b.N; i++ &#123;</span><br><span class="line">out, err :&#x3D; proto.Marshal(g)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">g1 :&#x3D; &amp;Group&#123;&#125;</span><br><span class="line">err &#x3D; proto.Unmarshal(out, g1)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkJson(b *testing.B) &#123;</span><br><span class="line">g :&#x3D; &amp;Group&#123;&#125;</span><br><span class="line">for i :&#x3D; 0; i &lt; 100; i++ &#123;</span><br><span class="line">p :&#x3D; &amp;Person&#123;</span><br><span class="line">Id:    int32(i),</span><br><span class="line">Name:  &quot;测试名称&quot;,</span><br><span class="line">Age:   int32(25 * i),</span><br><span class="line">Money: 240000.5,</span><br><span class="line">Car:   []string&#123;&quot;car1&quot;, &quot;car2&quot;, &quot;car3&quot;, &quot;car4&quot;, &quot;car5&quot;, &quot;car7&quot;, &quot;car6&quot;, &quot;car21&quot;, &quot;car22&quot;,&#125;,</span><br><span class="line">Phone: &amp;Person_Phone&#123;Number: &quot;0551-12323232&quot;, Type: &quot;1&quot;&#125;,</span><br><span class="line">Sex:   Person_female,</span><br><span class="line">&#125;</span><br><span class="line">g.Person &#x3D; append(g.Person, p)</span><br><span class="line">&#125;</span><br><span class="line">b.ResetTimer()</span><br><span class="line">        b.N &#x3D; 1000</span><br><span class="line">for i :&#x3D; 0; i &lt; b.N; i++ &#123;</span><br><span class="line">out, err :&#x3D; json.Marshal(g)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">g1 :&#x3D; &amp;Group&#123;&#125;</span><br><span class="line">err &#x3D; json.Unmarshal(out, g1)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便对比，指定了测试次数为1000次，测试结果如下：</p><p>在1个person的级别：</p><p>可以看出，理论上proto明显比json要快不少，每次操作大概是4-5倍差距。后面在10，100个person的级别的测试中，基本上都是保持在4-5倍性能的差距，这个结果也和网上大部分测试结果一致。</p><p>关于生成的数据大小，这里也简单测试了一遍，还是上面的例子，我使用了10个person，Protobuf生成的文件大小是1030个byte,json生成的文件大小是1842个byte。</p><p>需要注意一点，虽然在大小上Protobuf也领先很多，但是据网上文章介绍，在经过nginx的gzip压缩之后，这2者大小基本上差不多。</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><p>Protobuf作为一种新的数据交换编码方式，虽然使用起来麻烦点，但是在性能和大小上面领先很多，可以用来替换json，使用在一些对性能要求高的场景，比如移动端设备通信。除此之外，目前Protobuf主要用在gRPC用作默认数据编码格式。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.简介&quot;&gt;&lt;/a&gt;1.简介&lt;/h2&gt;&lt;p&gt;Protobuf（Google Protocol Buffer）是 Google公司内部的混合语言数据标准，目前已经开源，支持多种语言（C++、C#、Go、JS、Java、Python、PHP），它是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。&lt;/p&gt;
&lt;p&gt;说简单点，Protobuf就是类似JSON、XML这样的数据交换格式，当今互联网JSON是最流行的格式了，XML用的也挺多，最初接触到Protobuf是因为gRPC默认使用它作为数据编码，相比于JSON和XML，它更小，更快！&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程开发" scheme="https://wangbjun.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>GRPC入门和实践</title>
    <link href="https://wangbjun.github.io/2019/08/28/golang-grpc/"/>
    <id>https://wangbjun.github.io/2019/08/28/golang-grpc/</id>
    <published>2019-08-28T15:15:43.000Z</published>
    <updated>2020-01-09T04:58:49.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gPRC"><a href="#gPRC" class="headerlink" title="gPRC"></a>gPRC</h1><p>首先，先阐述一个误区，很多人以为gRPC只能go语言使用，以为这个g代表的就是go，其实并不是，这个g应该理解成Google，这个rpc框架是Google出品，不过Go对这个框架的支持确实非常好，看一下官网的介绍：</p><blockquote><p>gRPC is a modern open source high performance RPC framework that can run in any environment. It can efficiently connect services in and across data centers with pluggable support for load balancing, tracing, health checking and authentication. It is also applicable in last mile of distributed computing to connect devices, mobile applications and browsers to backend services.</p></blockquote><p>详细的介绍可以参考<a href="http://grpc.io" target="_blank" rel="noopener">官网</a>（grpc.io）,简单说，gRPC是一个开源的高性能rpc框架。</p><p>说到rpc，很多搞微服务的都喜欢用，特别是Java领域，rpc全称 Remote Procedure Call，翻译过来叫远程过程调用，这个翻译并不是特别好理解。</p><a id="more"></a><p>举个例子，假设你写了一个算法，非常牛逼，你想把这个算法给别人用，你会咋办？</p><p>首先，得确定这个调用方在哪里？如果这个调用方都在一个项目里面，那我们只需要写个函数，告诉别人函数名字就行了:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lib</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"something very NB"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是现实是，这个调用方不是同一个项目的，代码不在一起，是其它项目需要用，咋办呢？</p><p>有人说，把代码copy给别人，比较low，而且有时候代码要保密。</p><p>有人说，使用http服务，写个接口出来，扔一个API文档，这个方案完全可以，但是不是今天的主角。</p><p>或许，我们也可以使用rpc通信。</p><h2 id="Golang-RPC"><a href="#Golang-RPC" class="headerlink" title="Golang RPC"></a>Golang RPC</h2><p>不少语言都有自己的rpc框架，比如PHP有phprpc和yar，但是这些rpc框架局限在这个语言，无法做到跨语言之间的调用，而Go也是类似，Go标准库自带的rpc有好几种，默认采用Gob编码，只能在Go语言之间使用,还有一种jsonrpc，采用的是json编码，如果你需要跨语言的话，最好采用gRPC。</p><p>Go RPC的函数只有符合下面的条件才能被远程访问：</p><ul><li>函数必须是导出的(首字母大写)</li><li>必须有两个参数，并且是导出类型或者内建类型</li><li>第二个参数必须是指针类型的</li><li>函数还要有一个返回值 error</li></ul><p>下面看一个简单例子：</p><h3 id="入参出参"><a href="#入参出参" class="headerlink" title="入参出参"></a>入参出参</h3><p>我们首先单独定义了需要被远程调用的方法，以及方法的入参和出参，后面的服务端和客户端都会用到：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> golang_rpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"log"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Add <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Add)</span> <span class="title">Plus</span><span class="params">(request Request, response *Response)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">response.Result = request.A + request.B</span><br><span class="line">log.Printf(<span class="string">"Add...%d + %d"</span>, request.A, request.B)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">A <span class="keyword">int</span></span><br><span class="line">B <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Response <span class="keyword">struct</span> &#123;</span><br><span class="line">Result <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h3><p>这里使用的http协议，其实还有一种tcp的用法，主要作用是注册rpc服务，开启服务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">. <span class="string">"gRPC/golang-rpc"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/rpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">add := <span class="built_in">new</span>(Add)</span><br><span class="line">_ = rpc.Register(add)</span><br><span class="line">rpc.HandleHTTP()</span><br><span class="line">log.Println(<span class="string">"rpc server started at port 8888"</span>)</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":8888"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h3><p>客户端根据定义的入参结构体拼装好请求参数，调用rpc</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">. <span class="string">"gRPC/golang-rpc"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/rpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">dial, err := rpc.DialHTTP(<span class="string">"tcp"</span>, <span class="string">":8888"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">args := Request&#123;</span><br><span class="line">A: <span class="number">1</span>,</span><br><span class="line">B: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> response = Response&#123;&#125;</span><br><span class="line">err = dial.Call(<span class="string">"Add.Plus"</span>, args, &amp;response)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"a = %d, b= %d, result = %d"</span>, args.A, args.B, response.Result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这只是展示了Go rpc的一种用法，Go rpc的除了支持tcp之外，还可以使用json，也就是jsonrpc，其编码方式是使用json而不是默认的Gob。</p><h2 id="RPC-vs-HTTP"><a href="#RPC-vs-HTTP" class="headerlink" title="RPC vs HTTP"></a>RPC vs HTTP</h2><p>我所参与项目大部分都是基于http，很少使用rpc，原因之一就是因为http特别成熟，文本协议，简单易用，支持广泛，而且其它支持比如负载均衡，流量控制都非常好用。</p><p>本质上，这个2种通信方式都可以实现远程过程调用，也就说把数据从一个地方传输到另一个地方（经过处理再返回回来）。当然也有人说http也是rpc的一种实现形式，这些概念性的东西这里就不争论了。</p><p>但是rpc确实有一些优点，其中最主要的就是传输效率高，因为http是文本协议，而rpc数据协议往往是二进制。</p><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><p>gRPC相比于其它rpc语言，目前发展迅速，不仅仅支持多语言（Go、Java、Python、JS），目前也支持Web端，意味着可以在某种程度上替代http了。</p><p>先不过多介绍太多理论的东西，这里先结合实际代码来看，默认情况下，gRPC使用Protobuf作为 Interface Definition Language（IDL），所谓IDL就是接口定义语言，说的通俗点就是描述这个服务的结构包括请求参数和响应结果。</p><p>这里说到的Protobuf又是什么东西呢？</p><blockquote><p>Protobuf(Google Protocol Buffers)是Google提供一个具有高效的协议数据交换格式工具库(类似Json)，但相比于Json，Protobuf有更高的转化效率，时间效率和空间效率都是JSON的3-5倍。</p></blockquote><p>下面，咱们先看一个demo，先写个helloWorld，gRPC的写法比起http服务确实复杂很多，我们不仅仅要写server端，还要写client端，而http服务的client端一般都有现成的工具（浏览器、curl），但gRPC的client必须是一对一定制化的，需根据IDL生成。</p><ol><li>Go的运行环境咱就不说了，目前gRPC要求Go版本在1.6以上</li><li>安装gRPC: go get -u google.golang.org/grpc</li><li>安装Protobuf v3 compiler，我的Ubuntu系统是自带这个，如果不带的话可以使用apt安装，其它系统可以参考<a href="https://github.com/protocolbuffers/Protobuf" target="_blank" rel="noopener">github</a></li><li>安装go的Protobuf插件： go get -u github.com/golang/Protobuf/protoc-gen-go</li></ol><p>这个IDL文件并不是Go的语法，只是Protobuf的描述语法，大概的意思相信大部分都能看懂，service 是用来定义服务，然后还定义了请求和响应的参数类型，详细的用法可以参考Protobuf的<a href="https://developers.google.com/protocol-buffers/docs/proto3#simple" target="_blank" rel="noopener">官方文档</a>。</p><p>项目的整理结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├── client</span><br><span class="line">│   └── client.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── proto</span><br><span class="line">│   ├── hello.pb.go</span><br><span class="line">│   └── hello.proto</span><br><span class="line">└── server.go</span><br></pre></td></tr></table></figure><p>切换到终端，在proto目录下执行<code>protoc --go_out=plugins=grpc:. *.proto</code>命令生成一个pb.go文件，这是一个go语法的文件，里面的东西非常多，我们真正用到的就是这个。</p><p>下面完成server端的开发：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">pb <span class="string">"gRPC/proto"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *HelloService)</span> <span class="title">Hello</span><span class="params">(ctx context.Context, r *pb.HelloRequest)</span> <span class="params">(*pb.HelloResponse, error)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"new request..."</span>)</span><br><span class="line"><span class="keyword">return</span> &amp;pb.HelloResponse&#123;Response: r.GetRequest() + <span class="string">" Server"</span>&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PORT = <span class="string">"8080"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server := grpc.NewServer()</span><br><span class="line">pb.RegisterHelloServiceServer(server, &amp;HelloService&#123;&#125;)</span><br><span class="line"></span><br><span class="line">listen, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":"</span>+PORT)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"net.Listen err: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">_ = server.Serve(listen)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>server端的主要作用是实现服务定义的接口，然后把服务注册到rpc server里面，最后启动服务等待请求的到来，和http服务有点类似。</p><p>虽然服务启动了，但是这时候无法像像http一样使用浏览器或者其它工具去访问，我们必须使用特定的客户端来访问服务，下面是客户端的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line">pb <span class="string">"gRPC/proto"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PORT = <span class="string">"8080"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">conn, err := grpc.Dial(<span class="string">":"</span>+PORT, grpc.WithInsecure())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"grpc.Dial err: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">client := pb.NewHelloServiceClient(conn)</span><br><span class="line">resp, err := client.Hello(context.Background(), &amp;pb.HelloRequest&#123;</span><br><span class="line">Request: <span class="string">"Hello gRPC"</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"client.Search err: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">"resp: %s"</span>, resp.GetResponse())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，先启动server，然后运行client。</p><p>有人可能会说，废了这么大劲，到最后结果和http服务有啥区别？我使用http服务分分钟钟搞定的事情，gRPC还需要定义这个那个…但是gRPC的功能不止这些。</p><h2 id="流式请求"><a href="#流式请求" class="headerlink" title="流式请求"></a>流式请求</h2><p>上面的demo只是一个simple模型，类似于http的request和response模型，但是gRPC还支持流式请求，其交互模型包括：</p><ol><li>服务端流。客户端发出一个请求，服务端返回一个响应流</li><li>客户端流。客户端发出一个请求流，服务端返回一个响应</li><li>双向流。客户端和服务端可以互相通信，类似websocket一样</li></ol><p>具体的应用场景可以结合业务需求来定，这里demo就不展示了，官方有非常详细的example，其实大部分时候还是使用simple模型比较多。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>目前gRPC已经支持移动端和Web，如果拿来替代http也可行，但是http很容易调试和测试，而gRPC则很难，而且http的通用性更广泛，如果是对外提供的公开API，非http莫属。</p><p>目前来说gPRC比较适合用在一些对性能要求高而且比较稳定的场景，比如项目内部微服务之间的通信，这也是大多数rpc框架的主要应用场景。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;gPRC&quot;&gt;&lt;a href=&quot;#gPRC&quot; class=&quot;headerlink&quot; title=&quot;gPRC&quot;&gt;&lt;/a&gt;gPRC&lt;/h1&gt;&lt;p&gt;首先，先阐述一个误区，很多人以为gRPC只能go语言使用，以为这个g代表的就是go，其实并不是，这个g应该理解成Google，这个rpc框架是Google出品，不过Go对这个框架的支持确实非常好，看一下官网的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;gRPC is a modern open source high performance RPC framework that can run in any environment. It can efficiently connect services in and across data centers with pluggable support for load balancing, tracing, health checking and authentication. It is also applicable in last mile of distributed computing to connect devices, mobile applications and browsers to backend services.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;详细的介绍可以参考&lt;a href=&quot;http://grpc.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;（grpc.io）,简单说，gRPC是一个开源的高性能rpc框架。&lt;/p&gt;
&lt;p&gt;说到rpc，很多搞微服务的都喜欢用，特别是Java领域，rpc全称 Remote Procedure Call，翻译过来叫远程过程调用，这个翻译并不是特别好理解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程开发" scheme="https://wangbjun.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Grpc" scheme="https://wangbjun.github.io/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>短网址原理和实现</title>
    <link href="https://wangbjun.github.io/2019/07/09/short-url/"/>
    <id>https://wangbjun.github.io/2019/07/09/short-url/</id>
    <published>2019-07-09T11:02:46.000Z</published>
    <updated>2020-01-09T05:52:50.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1.背景介绍"></a>1.背景介绍</h2><p>相信很多人手机上都收到过一些营销短信，短信里面有时候会附带一些网址，如下图<br><img src="https://wangbjun.github.io/images/16ada545111ae94d.jpg" alt=""><br>这些网址往往都是非常短，但是当我们打开之后，如果你仔细观察，中间会有跳转，最终浏览器地址栏显示的网址并不是你短信里面看到的网址，这就是短网址！</p><a id="more"></a><h2 id="2-原理和应用"><a href="#2-原理和应用" class="headerlink" title="2.原理和应用"></a>2.原理和应用</h2><p>短网址一般是采用一个非常短域名下，路径参数一般只有3-6个字符组成，非常简洁！</p><p>使用短网址的前提是先生成短网址，主要是采用某种算法让一段短的字符对应一个长的字符，比如说从常用的0-9、a-z、A-Z共62个字符中选择6个字符，那意味着有62的6次方种组合，大概有568亿不重复的短网址可用！</p><p>服务器通过路径参数查询到真实的长网址，然后使用301/302跳转到真实的网址即可！</p><p>关于跳转，301 是永久重定向，302 是临时重定向。短地址一经生成就不会变化，所以用 301 是符合 http 语义的，浏览器会记录跳转地址，同时对服务器压力也会有一定减少。但是如果使用了 301，我们就无法统计到短地址被点击的次数了，如果对数据统计有要求的话，使用302跳转可能比较好一些！</p><p>短网址的主要好处是方便传输记忆，特别是在短信里面使用的时候，短信对内容字数有限制，还有比如说微博分享也使用了短网址！</p><h2 id="3-市面现有案例"><a href="#3-市面现有案例" class="headerlink" title="3.市面现有案例"></a>3.市面现有案例</h2><p>目前市面上有很多免费的短链接服务，功能基本上都一样，也没有什么限制！</p><p>(1)百度的短链接(<a href="https://dwz.cn/)，百度不仅仅提供了网页入口，也提供了接口和开发文档，简单易用！" target="_blank" rel="noopener">https://dwz.cn/)，百度不仅仅提供了网页入口，也提供了接口和开发文档，简单易用！</a></p><p>(2)新浪的短链接(<a href="http://sina.lt/)，目前仅提供网页入口，未发现接口服务！" target="_blank" rel="noopener">http://sina.lt/)，目前仅提供网页入口，未发现接口服务！</a></p><p>(3)淘宝的短链接(<a href="https://tb.am/)，目前仅提供网页入口，未发现接口服务！" target="_blank" rel="noopener">https://tb.am/)，目前仅提供网页入口，未发现接口服务！</a></p><p>市面还有很多其它的小的公司提供短链接服务，有些是部分免费，有些短链接是有效期的，这里不一一介绍！</p><h2 id="4-常用算法"><a href="#4-常用算法" class="headerlink" title="4.常用算法"></a>4.常用算法</h2><p>网上比较流行的算法有进制算法、摘要（Hash）算法、随机数算法，下面简单介绍一下：</p><h3 id="一-进制算法"><a href="#一-进制算法" class="headerlink" title="一.进制算法"></a>一.进制算法</h3><p>这个算法网上也有叫作自增序列算法，特点就是永不重复，设置 id 自增，一个 10进制 id 对应一个62进制的数值，1对1，也就不会出现重复的情况，这个利用的就是低进制转化为高进制时，字符数会减少的特性。</p><p>计算机中常见的进制有2进制，8进制，10进制，16进制，进制越大，能够表示的数越大，占用的字数也越少。下面举个例：</p><p>10进制的1000，在8进制里面是1750，在16进制里面就是3E8，那在62进制里面呢？有人说，计算机里面没有62进制。。。虽然没有，但是我们可以造一个，进制的转换算法是固定的，最常见的就是“除基取余法”！</p><p>我们假设62进制的字符序列为 0-9a-zA-Z，顺序可以打乱，但是应该固定下来，是一个从0角标开始的到61的数组，我们暂且称之为字母表！</p><p>====&gt; 1000/62 = 16，余8</p><p>====&gt; 16/62 = 0，余16</p><p>余数得到的数字是16、8，然后找到字母表里面角标为16和8的字符拼起来，就是g8，非常短，只有2位数！假如说我们想至少产生6位字符，那么我们可以从一个比较大的数字开始，具体可以看下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1位620 - 61</span><br><span class="line">2位384462 - 3843</span><br><span class="line">3位约 23万3844 - 238327</span><br><span class="line">4位约 1400万238328 - 14776335</span><br><span class="line">5位约 9.1亿14776336 - 916132831</span><br><span class="line">6位约 568亿916132832 - 56800235583</span><br></pre></td></tr></table></figure><h3 id="二-Hash算法"><a href="#二-Hash算法" class="headerlink" title="二.Hash算法"></a>二.Hash算法</h3><h4 id="第一种方式："><a href="#第一种方式：" class="headerlink" title="第一种方式："></a>第一种方式：</h4><p>简单的对长链接进行加盐md5，会生成一个32位的字符串，随机从里面取6个字符，或者简单粗暴取最后6位，但是md5只包含0-9A-Fa-f,比字母表的里面字符还少，冲突几率更大！</p><h4 id="第二种方式："><a href="#第二种方式：" class="headerlink" title="第二种方式："></a>第二种方式：</h4><p>1.将长网址 md5 生成 32 位签名串,分为 4 段, 每段 8 个字节</p><p>2.对这四段循环处理, 取 8 个字节, 将他看成 16 进制串与 0x3fffffff(30位1) 与操作, 即超过 30 位的忽略处理</p><p>3.这 30 位分成 6 段, 每 5 位的数字作为字母表的索引取得特定字符, 依次进行获得 6 位字符串</p><p>4.总的 md5 串可以获得 4 个 6 位串,取里面的任意一个就可作为这个长 url 的短 url 地址</p><p>生成的方式更加复杂，重复的几率低，但是依然会出现冲突！</p><h3 id="三-随机数算法"><a href="#三-随机数算法" class="headerlink" title="三.随机数算法"></a>三.随机数算法</h3><p>这个更简单，直接对这个62个字符数组做随机选择，选择其中6个字符当作短链接码，简单易用，但是难免会出现重复冲突！</p><h3 id="四-算法对比"><a href="#四-算法对比" class="headerlink" title="四.算法对比"></a>四.算法对比</h3><p>第一种算法只要解决自增id问题就可以避免冲突，自增id可以采用数据库自增主键，每次生成短码只需一次数据库操作（insert操作，获取主键id，然后算出短码即可）</p><p>第二种和第三种算法其实都差不多，都是依赖于程序随机，容易出现冲突，这就需要每次在插入数据库的时候判重，效率低一些！</p><h2 id="5-安全"><a href="#5-安全" class="headerlink" title="5.安全"></a>5.安全</h2><p>短链接虽然方便了传输和记忆，但是由于链接组成的字符个数少，更容易被爆破、猜测攻击，攻击者可以轻松遍历所有字符组成的链接！</p><p>所以不建议使用短链接发送具有私密性的网址，比如说重置密码链接，对一些权限、敏感信息的链接要做好二次鉴权！</p><p>最后，推荐一个使用golang写的短网址项目，可以作为一个单独服务部署使用: <a href="https://github.com/praglody/shorturl" target="_blank" rel="noopener">https://github.com/praglody/shorturl</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-背景介绍&quot;&gt;&lt;a href=&quot;#1-背景介绍&quot; class=&quot;headerlink&quot; title=&quot;1.背景介绍&quot;&gt;&lt;/a&gt;1.背景介绍&lt;/h2&gt;&lt;p&gt;相信很多人手机上都收到过一些营销短信，短信里面有时候会附带一些网址，如下图&lt;br&gt;&lt;img src=&quot;https://wangbjun.github.io/images/16ada545111ae94d.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;这些网址往往都是非常短，但是当我们打开之后，如果你仔细观察，中间会有跳转，最终浏览器地址栏显示的网址并不是你短信里面看到的网址，这就是短网址！&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程开发" scheme="https://wangbjun.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="短网址" scheme="https://wangbjun.github.io/tags/%E7%9F%AD%E7%BD%91%E5%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 下nvidia显卡驱动安装</title>
    <link href="https://wangbjun.github.io/2019/07/01/ubuntu-nvidia-dirver/"/>
    <id>https://wangbjun.github.io/2019/07/01/ubuntu-nvidia-dirver/</id>
    <published>2019-07-01T04:11:09.000Z</published>
    <updated>2020-01-08T17:44:37.451Z</updated>
    
    <content type="html"><![CDATA[<p>Linux下面的显卡驱动一直是个麻烦事，主要是独立显卡，特别是（NVIDIA）英伟达的显卡，气的当年祖师爷怒竖中指，虽然很多年过去了，情况有所改变，但也不是特别好！</p><h2 id="集成显卡"><a href="#集成显卡" class="headerlink" title="集成显卡"></a>集成显卡</h2><p>如果你在Linux下面不打游戏，也不搞深度学习，强烈建议你卸载独立显卡已提高性能，当然前提是你使用的intel带集显CPU，大部分intel自带集显的性能已经能满足了</p><p>Intel对Linux支持很好，所以Linux下面的intel集显驱动非常好，内核自带，不需要额外安装，流畅度也挺高，1080p下面60fps不是问题，但是如果你使用4k显示器，intel集显大部分都是带不动。</p><a id="more"></a><p>至于AMD的APU驱动，本人并没有试过，这里不作任何发言！</p><h2 id="独立显卡"><a href="#独立显卡" class="headerlink" title="独立显卡"></a>独立显卡</h2><p>如果你使用了一台4k显示器，大部分情况下你需要一个独立显卡，因为集显的话只有部分intel高端CPU和高端主板才能达到4k+60fps的情况（dp线），但是使用独显的话就很容易达到，毕竟集显免费送，独显可是要花钱买的。</p><p>虽然Linux自带了一个开源的 nouveau 驱动，但是性能真的堪忧，拿来带4k是不行的，必须安装独显驱动。</p><p>现在市场上大部分都是NVIDIA的显卡，我本人使用的也是N卡，至于A卡的情况这里也不作发言，下面说的只针对NVIDIA卡。</p><h2 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h2><p>虽然NVIDIA官网提供了最新Linux驱动的下载选项，但是本人并不建议大家尝试手动安装，因为非常麻烦，而且不同发行版不同版本之间可能存在兼容性问题。</p><p>不过这里还是简单说下步骤：</p><ol><li>下载安装文件，增加可执行权限，打开英伟达官网，在驱动下载页面可以下载最新的Linux驱动。</li><li>屏蔽nouveau驱动，编辑 /etc/modprobe.d/blacklist.conf 文件，在文件末尾加入一行 blacklist nouveau，然后使用 sudo update-initramfs -u 更新内核文件，成功后重启！</li><li>关闭x-server，在Ubuntu下面可以使用 service lightdm stop 命令</li><li>进入终端，执行安装文件，根据指示依次进行，这个脚本会做一些检测，如果检测到你没有屏蔽nouveau驱动会提示你，然后你可以选择自动创建，之后重启电脑，返回第3步</li><li>如果一切顺利的话，应该可以安装成功，但是往往没这么简单，比如会出现gcc版本不对的问题，还有一些第三方依赖问题，甚至卡死问题。<br>所以，我这里并不建议大家自己手动安装！！！</li></ol><h2 id="自动安装"><a href="#自动安装" class="headerlink" title="自动安装"></a>自动安装</h2><p>不同Linux发行版安装显卡驱动略有差异，有不少发行版都提供了一个比较简单的安装方式，比如Ubuntu在附加驱动里面就可以安装驱动。<br><img src="http://p1.pstatp.com/large/pgc-image/7645cd7fcf2d40079e5aa87cb7d2c6ba" alt=""></p><p>在附加驱动里面我们可以选择需要安装的驱动，在这里列出的基本上都不会有问题，安装完成之后重启即可，默认情况下会自动启用独显！英伟达的显卡会有一个驱动设置面板，可以做一些简单设置。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>正常情况下，安装显卡驱动还是非常简单的，特别是在Ubuntu下面，鼠标点点就行了，然而现实往往没有这么简单，可能会遇到很多意外，下面我就说说常见的问题：</p><h3 id="1-卡登录"><a href="#1-卡登录" class="headerlink" title="1.卡登录"></a>1.卡登录</h3><p>安装完显卡驱动之后，登录的时候输入密码点击确认之后会返回登录页面，无法进入桌面，循环登录，也就是卡登录，通常这情况都是由于驱动不兼容或者设置不正确导致。</p><p>不过不要慌，卸载掉驱动就行了，虽然无法进入图形桌面，我们可以使用 <code>Alt+F1-F5</code>进入命令行，然后登录后，使用命令行下载NVIDIA驱动，<code>sudo apt purge nvidia*</code></p><p>卸载掉驱动后，重启就可以进入桌面了，然后可以尝试安装其它版本的驱动。</p><h3 id="2-卡死机"><a href="#2-卡死机" class="headerlink" title="2.卡死机"></a>2.卡死机</h3><p>表现就是在安装驱动的过程中，卡在哪里，鼠标键盘无响应，这种情况下基本上是内核卡死了，你等多久都没用。</p><p>一般是因为主板某些设置，比如安全启动，建议关闭安全启动，也就是secure boot</p><p>还有可能是因为内存原因，我之前就是因为主板上面插了4根8G内存条，但是有2根是2400MHz，有2根是2666MHz，基频不一致。</p><p>还有比如说CPU超频了，经过我测试，Linux对CPU超频的兼容性不好，如果超频可能会导致死机，不建议大幅度超频！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux下面的显卡驱动一直是个麻烦事，主要是独立显卡，特别是（NVIDIA）英伟达的显卡，气的当年祖师爷怒竖中指，虽然很多年过去了，情况有所改变，但也不是特别好！&lt;/p&gt;
&lt;h2 id=&quot;集成显卡&quot;&gt;&lt;a href=&quot;#集成显卡&quot; class=&quot;headerlink&quot; title=&quot;集成显卡&quot;&gt;&lt;/a&gt;集成显卡&lt;/h2&gt;&lt;p&gt;如果你在Linux下面不打游戏，也不搞深度学习，强烈建议你卸载独立显卡已提高性能，当然前提是你使用的intel带集显CPU，大部分intel自带集显的性能已经能满足了&lt;/p&gt;
&lt;p&gt;Intel对Linux支持很好，所以Linux下面的intel集显驱动非常好，内核自带，不需要额外安装，流畅度也挺高，1080p下面60fps不是问题，但是如果你使用4k显示器，intel集显大部分都是带不动。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://wangbjun.github.io/categories/Linux/"/>
    
    
      <category term="Ubuntu" scheme="https://wangbjun.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Golang的常用数据结构</title>
    <link href="https://wangbjun.github.io/2019/06/19/golang-datastruct/"/>
    <id>https://wangbjun.github.io/2019/06/19/golang-datastruct/</id>
    <published>2019-06-19T13:00:33.000Z</published>
    <updated>2020-01-09T08:09:53.228Z</updated>
    
    <content type="html"><![CDATA[<p>闲着无事，随便写写，初学Go，望各位大神轻喷！Go自带的几个复合数据类型，基本数据类型咱就不说了，大部分语言常见的几种复合数据类型大概有数组、字典、对象等，不同语言叫法不一样，用法也有差异，比如说PHP里面数组其实严格来说不算数组。</p><a id="more"></a><h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h2><p>Go里面的数组和C类似，是由<strong>有序</strong>的<strong>固定长度</strong>的<strong>特定类型</strong>元素组成。画重点，固定长度和特定类型。在很多弱类型的语言里面，数组非常随意，PHP的数组本质上是一个hash table，和C的数组差异太大，所以写惯了PHP再写Go的话这点需要注意。</p><h3 id="基础用法1"><a href="#基础用法1" class="headerlink" title="基础用法1:"></a>基础用法1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var a [5]int</span><br><span class="line"></span><br><span class="line">a[1] &#x3D; 1</span><br><span class="line">a[2] &#x3D; 3</span><br><span class="line"></span><br><span class="line">var b [10]string</span><br><span class="line"></span><br><span class="line">b[0] &#x3D; &quot;a1&quot;</span><br><span class="line">b[1] &#x3D; &quot;b2&quot;</span><br><span class="line">b[2] &#x3D; &quot;c5&quot;</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;%v\n&quot;, a)</span><br><span class="line">fmt.Printf(&quot;%v\n&quot;, b)</span><br><span class="line">&#125;</span><br><span class="line">---结果---</span><br><span class="line">[0 1 3 0 0]</span><br><span class="line">[a1 b2 c5       ]</span><br></pre></td></tr></table></figure><p>从语法上看，Go定义数组的类型放在后面，这点写惯C系语言的估计蛋疼。数组也是通过索引下标访问，如果不初始化赋值的话，默认情况下，int类型的元素是0,string类型是空字符串。</p><h3 id="基础用法2"><a href="#基础用法2" class="headerlink" title="基础用法2"></a>基础用法2</h3><p>我们也可以不先定义，直接使用字面量初始化数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">a :&#x3D; [...]int&#123;1, 2, 3, 4, 5, 7&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;%v&quot;, a)</span><br><span class="line">&#125;</span><br><span class="line">---结果---</span><br><span class="line">[1 2 3 4 5 7]</span><br></pre></td></tr></table></figure><p>在这种情况下，我们可以省略长度,使用3个点代替，编译器会自动判断。</p><h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><p>主要有两种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">a :&#x3D; [...]int&#123;1, 2, 3, 4, 5, 7&#125;</span><br><span class="line"></span><br><span class="line">for i :&#x3D; 0; i &lt; len(a); i++ &#123;</span><br><span class="line">fmt.Print(a[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for k, v :&#x3D; range a &#123;</span><br><span class="line">fmt.Print(k, &quot;-&gt;&quot;, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果知道长度的话可以使用for循环，否则可以使用for range 这种语法。</p><h3 id="数组函数"><a href="#数组函数" class="headerlink" title="数组函数"></a>数组函数</h3><p>Go内置了一些函数可以操作数组，如果你使用了IDE的话，可以“点”出来：</p><p><img src="http://ww1.sinaimg.cn/large/5f6e3e27ly1fzgltdja32j20g4054wen.jpg" alt=""></p><p>然而，append并不是用来操作数组的，其实它是用来操作变长数组的，即slice, 又称切片。</p><h2 id="2-Slice（切片）"><a href="#2-Slice（切片）" class="headerlink" title="2.Slice（切片）"></a>2.Slice（切片）</h2><p>传统的数组长度固定，所以实际用途并不多，除非你明确知道自己想要多长的数组，很多时候我们需要的是一个可以改变长度大小的数组，在Go里面这类型被称为切片。</p><p>slice其实是从数组而来的，它和数组非常像，区别就在于slice没有固定长度，非常方便，所以平时一般都是用这个比较多。</p><h3 id="基础用法1-1"><a href="#基础用法1-1" class="headerlink" title="基础用法1:"></a>基础用法1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var a []int</span><br><span class="line"></span><br><span class="line">a &#x3D; append(a, 2)</span><br><span class="line">a &#x3D; append(a, 1)</span><br><span class="line">a &#x3D; append(a, 4)</span><br><span class="line">a &#x3D; append(a, 5)</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;%v&quot;, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区别就在于slice在定义的时候不需要指定长度，也不用3个点，但是这就意味着你不能使用索引下标的方法去赋值了，可以使用append函数去追加元素。</p><p>而且在使用slice的也需要注意下标，如果大于slice的长度也会出现 <code>panic: runtime error: index out of range</code>。</p><h3 id="基础用法2-1"><a href="#基础用法2-1" class="headerlink" title="基础用法2"></a>基础用法2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">a :&#x3D; [...]int&#123;1,2,3,4,5,6,7,8&#125;</span><br><span class="line"></span><br><span class="line">s1 :&#x3D; a[0:]</span><br><span class="line"></span><br><span class="line">s2 :&#x3D; a[1:5]</span><br><span class="line"></span><br><span class="line">s3 :&#x3D; a[4:6]</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;%v\n&quot;, a)</span><br><span class="line">fmt.Printf(&quot;%v\n&quot;, s1)</span><br><span class="line">fmt.Printf(&quot;%v\n&quot;, s2)</span><br><span class="line">fmt.Printf(&quot;%v\n&quot;, s3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>slice可以使用<code>[start:end]</code>这种语法从一个数组里面生成，比如<code>a[1:5]</code>意思是生成一个包含数组索引1到5的之间元素的slice。</p><blockquote><p>在Go里面不同长度但是同一类型的数组是不同类型的，比如你定义了2个int数组，一个长度为5，一个长度为10，他们其实并不是同一个类型，虽然都是int类型。cannot use a (type [10]int) as type [5]int in argument</p></blockquote><p>所以在大部分时候我们需要的是一个slice，并不是一个数组。虽然这个2个用法基本上一毛一样。。。</p><h2 id="3-Map"><a href="#3-Map" class="headerlink" title="3.Map"></a>3.Map</h2><p>在很多语言里面，map被叫作字典，这个中文名称很亲切，字典就是一种key value结构，小时候大家都用过新华字典，字典的特征就是每一个字都对应一个解释。但是Go的map是无序的，这点大家需要注意。如果有童鞋写过PHP，会发现这个数据类型类似PHP里面的关联数组。</p><p>在Go里面，它和slice的区别就是slice的索引是数值，map的索引类型就丰富了，基本上常用数据类型都支持，甚至包括结构体。</p><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><p>和其它数组类型一样，map也支持先定义后赋值，或者直接使用字面量创建。但是如果使用先定义后赋值这种方式，map需要使用make初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var m1 map[string]string</span><br><span class="line"></span><br><span class="line">m1 &#x3D; make(map[string]string)</span><br><span class="line"></span><br><span class="line">m1[&quot;name&quot;] &#x3D; &quot;Golang&quot;</span><br><span class="line">m1[&quot;address&quot;] &#x3D; &quot;BeiJin&quot;</span><br><span class="line"></span><br><span class="line">m2 :&#x3D; map[string]string&#123;</span><br><span class="line">&quot;name&quot;: &quot;GoLand&quot;,</span><br><span class="line">&quot;addr&quot;: &quot;ShangHai&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;%v\n&quot;, m1)</span><br><span class="line">fmt.Printf(&quot;%v&quot;, m2)</span><br><span class="line">&#125;</span><br><span class="line">---结果---</span><br><span class="line">map[name:Golang address:BeiJin]</span><br><span class="line">map[name:GoLand addr:ShangHai]</span><br></pre></td></tr></table></figure><p>map可以使用for range 语法遍历，但是需要注意的是每次遍历的顺序是无序的。</p><p>如何判断一个key是否存在map里面？在PHP里面我们有一个array_key_exists函数，在Go里面写法略有不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age, ok :&#x3D; m1[&quot;age&quot;]</span><br><span class="line">if !ok &#123;</span><br><span class="line">    fmt.Println(&quot;age 不存在&quot;, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实如果你不判断是否存在直接取也可以，并不会报错，只不过获取到的值是一个对应类型的零值。</p><h2 id="4-结构体"><a href="#4-结构体" class="headerlink" title="4.结构体"></a>4.结构体</h2><p>Go的结构体也类似C，类似于现在很多面向对象的语言里面的类，往往用来存储一组相关联的数据，Go虽然不是一个完全面向对象的语言，但是使用结构体可以实现类似效果。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Goods struct &#123;</span><br><span class="line">name    string</span><br><span class="line">price   int</span><br><span class="line">pic     string</span><br><span class="line">address string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var goods Goods</span><br><span class="line">goods.name &#x3D; &quot;商品1&quot;</span><br><span class="line">goods.price &#x3D; 100</span><br><span class="line">goods.pic &#x3D; &quot;http:&#x2F;&#x2F;xxxx.jpg&quot;</span><br><span class="line">goods.address &#x3D; &quot;中国&quot;</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;%v\n&quot;, goods)</span><br><span class="line"></span><br><span class="line">goods2 :&#x3D; Goods&#123;</span><br><span class="line">name:    &quot;商品2&quot;,</span><br><span class="line">price:   200,</span><br><span class="line">pic:     &quot;http:&#x2F;&#x2F;xxxx.png&quot;,</span><br><span class="line">address: &quot;日本&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;%v&quot;, goods2)</span><br><span class="line">&#125;</span><br><span class="line">---结果---</span><br><span class="line">&#123;商品1 100 http:&#x2F;&#x2F;xxxx.jpg 中国&#125;</span><br><span class="line">&#123;商品2 200 http:&#x2F;&#x2F;xxxx.png 日本&#125;</span><br></pre></td></tr></table></figure><p>先定义后赋值或者字面量赋值都可以，值得一提的是在Go里面如果结构体或者其属性的首字母大写则表示该结构体或者属性可以被导出，也就是被其它包使用。结构体里面的属性成员的类型也可以是结构体，这就变相实现了类的继承。</p><p>既然结构体和类差不多，那类的方法在哪里定义呢？这点Go实现的就比较巧妙了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (g Goods) getName() string &#123;</span><br><span class="line">return g.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要在函数的前面放一个变量，就变成了方法。在很多语言里面，函数和方法区分不是很明显，大部分时候我们都是混着叫，但是在Go里面，方法指的是针对某一类型的函数。比如在上面的例子里面，这个<strong>getName</strong>函数就是针对<strong>Goods</strong>结构体的,用面向对象的说法就是一个类方法。所以我们可以使用 <code>goods.getName()</code>的形式调用这个方法。</p><blockquote><p>上面的代码里那个附加的参数p，叫做方法的接收器（receiver），早期的面向对象语言留下的遗产将调用一个方法称为“向一个对象发送消息”。<br> 在Go语言中，我们并不会像其它语言那样用this或者self作为接收器；我们可以任意的选择接收器的名字。由于接收器的名字经常会被使用到，所以保持其在方法间传递时的一致性和简短性是不错的主意。这里的建议是可以使用其类型的第一个字母。</p></blockquote><p>在Go里面我们可以为任何类型定义方法，无论是常见的int、string，还是map、struct都没问题，下面的例子里面就是为int类型扩展一个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type MyInt int</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">myInt :&#x3D; MyInt(10)</span><br><span class="line">res :&#x3D; myInt.add(100)</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;%d&quot;, res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m MyInt) add(a int) int &#123;</span><br><span class="line">return int(m) + a</span><br><span class="line">&#125;</span><br><span class="line">---结果---</span><br><span class="line">110</span><br></pre></td></tr></table></figure><p>我们无法直接使用基本数据类型，但是我们可以起一个别名，纯属娱乐！</p><h2 id="5-JSON"><a href="#5-JSON" class="headerlink" title="5.JSON"></a>5.JSON</h2><p>严格来说，JSON并不是一种数据类型，但是json是现在最流行的数据交换格式，Go对json的支持也很好，在Go里面主要通过结构体生成json，我们也可以把一个json转换成结构体。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;encoding&#x2F;json&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Goods struct &#123;</span><br><span class="line">Name    string</span><br><span class="line">Price   int</span><br><span class="line">Address string &#96;json:&quot;address2&quot;&#96;</span><br><span class="line">Tag     string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">goods :&#x3D; Goods&#123;</span><br><span class="line">&quot;商品1&quot;, 100, &quot;中国&quot;, &quot;特价&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bytes, err :&#x3D; json.Marshal(goods)</span><br><span class="line"></span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;%s&quot;, bytes)</span><br><span class="line">&#125;</span><br><span class="line">---结果---</span><br><span class="line">&#123;&quot;Name&quot;:&quot;商品1&quot;,&quot;Price&quot;:100,&quot;address2&quot;:&quot;中国&quot;,&quot;Tag&quot;:&quot;特价&quot;&#125;</span><br></pre></td></tr></table></figure><p>把结构体转换成json可以使用Marshal方法，有一点需要注意: 结构体的属性成员首字母必须大写，但是可以使用注解的Tag标注转换成json之后的key名称。</p><p>json字符串转换成结构体步骤差不多：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;encoding&#x2F;json&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Goods struct &#123;</span><br><span class="line">Name    string</span><br><span class="line">Price   int</span><br><span class="line">Address string &#96;json:&quot;address2&quot;&#96;</span><br><span class="line">Tag     string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">jsonStr :&#x3D; &#96;&#123;&quot;Name&quot;:&quot;商品1&quot;,&quot;Price&quot;:100,&quot;address2&quot;:&quot;中国&quot;,&quot;Tag&quot;:&quot;特价&quot;&#125;&#96;</span><br><span class="line"></span><br><span class="line">goods :&#x3D; Goods&#123;&#125;</span><br><span class="line"></span><br><span class="line">err :&#x3D; json.Unmarshal([]byte(jsonStr), &amp;goods)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;%v&quot;, goods)</span><br><span class="line">&#125;</span><br><span class="line">---结果---</span><br><span class="line">&#123;商品1 100  特价&#125;</span><br></pre></td></tr></table></figure><p>这在我们平时写接口或者请求接口的时候非常好使，简单易用！</p><p>好了，今天就介绍这么多了，谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闲着无事，随便写写，初学Go，望各位大神轻喷！Go自带的几个复合数据类型，基本数据类型咱就不说了，大部分语言常见的几种复合数据类型大概有数组、字典、对象等，不同语言叫法不一样，用法也有差异，比如说PHP里面数组其实严格来说不算数组。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程开发" scheme="https://wangbjun.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>解决sudo command not found 报错</title>
    <link href="https://wangbjun.github.io/2019/06/02/sudo-command-not-found/"/>
    <id>https://wangbjun.github.io/2019/06/02/sudo-command-not-found/</id>
    <published>2019-06-02T03:29:06.000Z</published>
    <updated>2020-01-08T17:18:05.749Z</updated>
    
    <content type="html"><![CDATA[<p>偶尔发现的一个问题，平时主要使用 <strong>Ubuntu</strong> 操作系统，有时候安装一些软件会用加一些自定义PATH，往往为了方便都会把配置写到  <strong>/etc/environment</strong> 里面,这样所有用户包括root都有效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jwang@jwang:~$ cat &#x2F;etc&#x2F;environment </span><br><span class="line">PATH&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:</span><br><span class="line">&#x2F;bin:&#x2F;usr&#x2F;games:&#x2F;usr&#x2F;local&#x2F;games:&#x2F;home&#x2F;jwang&#x2F;MyBin:&#x2F;opt&#x2F;go&#x2F;bin&quot;</span><br><span class="line">export GOPATH&#x3D;&#x2F;home&#x2F;jwang&#x2F;Go</span><br></pre></td></tr></table></figure><a id="more"></a><p>比如说安装了go，在使用 <strong>sudo go</strong> 这样命令的时候会报错，但是切换到 root 用户却没有问题，使用普通用户也没问题，查了一下发现原来 sudo 里面有一些配置：</p><p><img src="https://upload-images.jianshu.io/upload_images/3571187-2c5fdea0a1fd3101.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo visudo</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/3571187-319d779b9cae7fc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在这个 <strong>/etc/sudoers</strong> 文件里面，有一个secure_path配置，大家一看就知道了，它的意思当你使用 <strong>sudo+command</strong> 这种形式执行命令的时候会从其配置的路径里面寻找命令，肯定是没有你自定义的PATH的，这个主要是安全考虑。</p><p><strong>解决方法</strong>有几种：</p><ol><li><p>直接把自定义PATH路径配置在secure_path里面，简单粗暴，就是有点麻烦</p></li><li><p>将 Defaults env_reset 改成 Defaults !env_reset 取消掉对PATH变量的重置，然后在.bashrc中最后添加alias sudo=’sudo env PATH=$PATH’，这个感觉更麻烦</p></li><li><p>直接把这3行注释掉，经测试完全没有任何问题</p></li></ol><p>我是采用第3种方式解决的，非常好用，暂时未发现问题！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;偶尔发现的一个问题，平时主要使用 &lt;strong&gt;Ubuntu&lt;/strong&gt; 操作系统，有时候安装一些软件会用加一些自定义PATH，往往为了方便都会把配置写到  &lt;strong&gt;/etc/environment&lt;/strong&gt; 里面,这样所有用户包括root都有效：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;jwang@jwang:~$ cat &amp;#x2F;etc&amp;#x2F;environment &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PATH&amp;#x3D;&amp;quot;&amp;#x2F;usr&amp;#x2F;local&amp;#x2F;sbin:&amp;#x2F;usr&amp;#x2F;local&amp;#x2F;bin:&amp;#x2F;usr&amp;#x2F;sbin:&amp;#x2F;usr&amp;#x2F;bin:&amp;#x2F;sbin:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;bin:&amp;#x2F;usr&amp;#x2F;games:&amp;#x2F;usr&amp;#x2F;local&amp;#x2F;games:&amp;#x2F;home&amp;#x2F;jwang&amp;#x2F;MyBin:&amp;#x2F;opt&amp;#x2F;go&amp;#x2F;bin&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export GOPATH&amp;#x3D;&amp;#x2F;home&amp;#x2F;jwang&amp;#x2F;Go&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://wangbjun.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Sudo" scheme="https://wangbjun.github.io/tags/Sudo/"/>
    
  </entry>
  
  <entry>
    <title>Golang的依赖注入简介</title>
    <link href="https://wangbjun.github.io/2019/05/15/golang-di/"/>
    <id>https://wangbjun.github.io/2019/05/15/golang-di/</id>
    <published>2019-05-15T13:13:49.000Z</published>
    <updated>2020-01-08T17:37:43.313Z</updated>
    
    <content type="html"><![CDATA[<p>DI - Dependency Injection，即“依赖注入”，是指组件之间依赖关系由容器在运行期决定，与此同时还有一个叫作IOC的词汇，IOC即控制反转。</p><p>理论上讲，这2个概念都是基于OOP编程而产生的思想，在OOP编程里面，我们强调对象之间的依赖关系，比如说对象B依赖对象A的某些功能，我们就说B依赖A。</p><p>DI毕竟不是Go语言的专利，它是一种编程思想，在很多语言里面都有体现和实现，相信很多具有编程经验的人也有所了解，下面咱们直接开始讲在Go语言里面怎么使用DI。</p><a id="more"></a><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>Golang的DI目前主要有2种方式，一种是使用反射特性实现，代表开源项目有facebook/inject，还有uber/dig。另一种是代码自动生成，代表开源项目有google/wire。</p><p>下面咱们看一个案例：</p><p>由于Go并不是纯OOP语言，所以这里使用struct模拟对象的概念，有3个对象，其中App依赖DB和Redis。</p><p>DB：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Object</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123;</span><br><span class="line">config <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(DB)</span> <span class="title">Get</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"I am DB"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Object</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Redis <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Redis)</span> <span class="title">Get</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"I am Redis"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>App:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Object</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> App <span class="keyword">struct</span> &#123;</span><br><span class="line">r  Redis</span><br><span class="line">db DB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p App)</span> <span class="title">Work</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"I can work"</span>)</span><br><span class="line">p.db.Get()</span><br><span class="line">p.r.Get()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不使用依赖注入，我们只能手动解决依赖，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"di/Object"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">app := Object.App&#123;</span><br><span class="line">R:  Object.Redis&#123;&#125;,</span><br><span class="line">DB: Object.DB&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">app.Work()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法并无太大问题，简单安全，不过项目非常大的时候，对象之间依赖关系复杂，手动解决依赖可能非常麻烦，这时候就需要自动注入依赖了。</p><h2 id="facebook-inject"><a href="#facebook-inject" class="headerlink" title="facebook/inject"></a>facebook/inject</h2><p>这是Facebook开源的一个项目，地址：github.com/facebookgo/inject</p><p>它使用struct的tag声明依赖，第一个无值语法是针对关联类型的单例依赖的常见情况。第二个触发器创建关联类型的私有实例。最后一个是要求一个名为 “dev logger” 的依赖关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#96;inject:&quot;&quot;&#96;</span><br><span class="line">&#96;inject:&quot;private&quot;&#96;</span><br><span class="line">&#96;inject:&quot;dev logger&quot;&#96;</span><br></pre></td></tr></table></figure><p>下面以App为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> App <span class="keyword">struct</span> &#123;</span><br><span class="line">R  Redis <span class="string">`inject:""`</span></span><br><span class="line">DB DB <span class="string">`inject:""`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"di/Object"</span></span><br><span class="line"><span class="string">"github.com/facebookgo/inject"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> g inject.Graph</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app Object.App</span><br><span class="line"></span><br><span class="line">_ = g.Provide(</span><br><span class="line">&amp;inject.Object&#123;Value: &amp;Object.DB&#123;&#125;,&#125;,</span><br><span class="line">&amp;inject.Object&#123;Value: &amp;Object.Redis&#123;&#125;,&#125;,</span><br><span class="line">&amp;inject.Object&#123;Value: &amp;app,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">_ = g.Populate()</span><br><span class="line"></span><br><span class="line">app.Work()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给struct tag只是第一步，在程序启动的时候需要先注入依赖。</p><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>一般说到依赖注入必然会用到反射，说到Go的反射，大多数人都会说性能很差。</p><p>这个inject库也是用到了反射原理，性能会不会很差呢？</p><p>其实还是看用法，官方推荐在应用程序启动的时候注入所有依赖，而不是在运行中注入依赖，这样即使慢，也只是程序每次启动的时候慢，并不影响后续的运行情况。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DI - Dependency Injection，即“依赖注入”，是指组件之间依赖关系由容器在运行期决定，与此同时还有一个叫作IOC的词汇，IOC即控制反转。&lt;/p&gt;
&lt;p&gt;理论上讲，这2个概念都是基于OOP编程而产生的思想，在OOP编程里面，我们强调对象之间的依赖关系，比如说对象B依赖对象A的某些功能，我们就说B依赖A。&lt;/p&gt;
&lt;p&gt;DI毕竟不是Go语言的专利，它是一种编程思想，在很多语言里面都有体现和实现，相信很多具有编程经验的人也有所了解，下面咱们直接开始讲在Go语言里面怎么使用DI。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程开发" scheme="https://wangbjun.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang处理TCP“粘包”问题</title>
    <link href="https://wangbjun.github.io/2019/05/10/golang-tcp-package/"/>
    <id>https://wangbjun.github.io/2019/05/10/golang-tcp-package/</id>
    <published>2019-05-10T04:05:45.000Z</published>
    <updated>2020-01-08T09:54:02.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是粘包？"><a href="#1-什么是粘包？" class="headerlink" title="1.什么是粘包？"></a>1.什么是粘包？</h2><p>“粘包”这个说法已经被诟病很久了，既然坊间流传这个说法咱们就沿用吧，关于这个问题比较准确的解释可以参考下面几点：</p><ol><li>TCP是流传输协议,是一种面向连接的、可靠的、基于字节流的传输层通信协议</li><li>TCP没有包的概念，它只负责传输字节序列，UDP是面向数据报的协议，所以不存在拆包粘包问题</li><li>应该由应用层来维护消息和消息的边界，即需要一个应用层协议，比如HTTP</li></ol><p>所以，本质上这是一个没有正确使用TCP协议的而产生的问题，有网友说了一句非常形象的话：“打开家里的水龙头， 看着自来水往下流， 然后你告诉我， 看， 自来水粘在一起了， 不是有病？”</p><a id="more"></a><h2 id="2-如何解决粘包？"><a href="#2-如何解决粘包？" class="headerlink" title="2.如何解决粘包？"></a>2.如何解决粘包？</h2><p>通常来说，一般有下面几种方式：</p><ol><li>消息长度固定，提前确定包长度，读取的时候也安固定长度读取，适合定长消息包。</li><li>使用特殊的字符或字符串作为消息的边界，例如 HTTP 协议的 headers 以“\r\n”为字段的分隔符</li><li>自定义协议，将消息分为消息头和消息体，消息头中包含表示消息总长度</li></ol><h2 id="3-Golang实战"><a href="#3-Golang实战" class="headerlink" title="3.Golang实战"></a>3.Golang实战</h2><p>首先，来看一个存在粘包问题的例子：</p><h3 id="一、Server端："><a href="#一、Server端：" class="headerlink" title="一、Server端："></a>一、Server端：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listen, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8888"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> listen.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := listen.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">data := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">_, err := conn.Read(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"%s\n"</span>, err.Error())</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">receive := <span class="keyword">string</span>(data)</span><br><span class="line">log.Printf(<span class="string">"receive msg: %s\n"</span>, receive)</span><br><span class="line"></span><br><span class="line">send := []<span class="keyword">byte</span>(strings.ToUpper(receive))</span><br><span class="line">_, err = conn.Write(send)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"send msg failed, error: %s\n"</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">"send msg: %s\n"</span>, receive)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单说一下这段代码，有点socket编程的基础的话应该很容易理解，基本上都是Listen -&gt; Accept -&gt; Read这个套路。</p><blockquote><p>有些人一下子就看出来这个服务有点“问题”，它是同步阻塞的，也就意味着这个服务同一时间只能处理一个连接请求，其实解决这个问题也很简单，得益于Go协程的强大，我们只需要开启一个协程单独处理每一个连接就行了。不过这不是今天的主题，有兴趣的童鞋可以自行研究。</p></blockquote><h3 id="二、Client端："><a href="#二、Client端：" class="headerlink" title="二、Client端："></a>二、Client端：</h3><p>这个服务的功能特别简单，客户端输入什么我就返回什么，客户端的话，这里我使用telnet来演示：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jwang@jwang:~$ telnet 127.0.0.1 8888</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to 127.0.0.1.</span><br><span class="line">Escape character is '^]'.</span><br><span class="line">111111</span><br><span class="line">111111</span><br><span class="line">123456</span><br><span class="line">123456</span><br></pre></td></tr></table></figure><blockquote><p>当你按回车键的时候telnet会在消息后面自动追加”\r\n“换行符并发送消息！</p></blockquote><p>从代码里面可以看到，在接受消息的时候我们每次读取10个字节的内容输出并返回，如果输入的消息小于等于8（减去换行符）个字符的时候没有问题，但是当我们在telnet里面输入大于10个字符的内容的时候，这些数据的时候会被强行拆开处理。</p><p>当然这里有人说了，可不可以一次读多点，然而读多少都会存在这个问题，而且TCP会有缓存区，不一定能够及时把消息发出去，像Nagle优化算法会将多次间隔较小、数据量小的数据，合并成一个大的数据块，然后进行封包，还是会存在问题。</p><p>如果我们把这个内容看作是一个业务消息，这个业务消息就被拆分放到下个消息里面处理，必然会产生问题，这就是“粘包”问题的由来。说到底，还是用的人的问题，没有确定好数据边界，如果简单粗暴的读取固定长度的内容，必然会出现问题。</p><h2 id="4-边界符解决粘包问题"><a href="#4-边界符解决粘包问题" class="headerlink" title="4.边界符解决粘包问题"></a>4.边界符解决粘包问题</h2><p>前面说过这个问题，我们可以通过定义一个边界符号解决粘包问题，比如说在上面的例子里面telnet会自动在每一条消息后面追加“\r\n”符号，我们恰好可以利用这点来区分消息。</p><ol><li>定义一个buffer来临时存放消息</li><li>从conn里面读取固定字节大小内容，判断当前内容里面有没有分隔符</li><li>如果没有找到分隔符，把当前内容追加到buffer里面，然后重复第2步</li><li>如果找到分隔符，把当前内容里面分隔符之前的内容追加到buffer后输出</li><li>然后重置buffer，把分隔符之后的内容追加到buff，重复第2步 </li></ol><p>不过Go里面提供了一个非常好用的buffer库，为我们节省了很多操作</p><p>我们可以使用bufio库里面的NewReader把conn包装一下，然后使用ReadSlice方法读取内容，该方法会一直读直到遇到分隔符，非常简单实用。</p><h3 id="一、Server端：-1"><a href="#一、Server端：-1" class="headerlink" title="一、Server端："></a>一、Server端：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listen, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8888"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> listen.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := listen.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">reader := bufio.NewReader(conn)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">slice, err := reader.ReadSlice(<span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s"</span>, slice)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、Client端：-1"><a href="#二、Client端：-1" class="headerlink" title="二、Client端："></a>二、Client端：</h3><p>Client这里可以直接使用telnet，也可以自己写一个，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8888"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">"dial error:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">_, err = conn.Write([]<span class="keyword">byte</span>(strconv.Itoa(i) + <span class="string">" =&gt; 77777\n"</span>))</span><br><span class="line">_, err = conn.Write([]<span class="keyword">byte</span>(strconv.Itoa(i) + <span class="string">" =&gt; 88888\n"</span>))</span><br><span class="line">_, err = conn.Write([]<span class="keyword">byte</span>(strconv.Itoa(i) + <span class="string">" =&gt; 555555555555555555555555555555555555555555\n"</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">_, err = conn.Write([]<span class="keyword">byte</span>(strconv.Itoa(i) + <span class="string">" =&gt; 123456\n"</span>))</span><br><span class="line">_, err = conn.Write([]<span class="keyword">byte</span>(strconv.Itoa(i) + <span class="string">" =&gt; 123456\n"</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">_, err = conn.Write([]<span class="keyword">byte</span>(strconv.Itoa(i) + <span class="string">" =&gt; 9999999\n"</span>))</span><br><span class="line">_, err = conn.Write([]<span class="keyword">byte</span>(strconv.Itoa(i) + <span class="string">" =&gt; 0000000000000000000000000000000000000000000\n"</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要说缺点，这种方式主要存在2点，第一点是分隔符的选择问题，如果需要传输的消息包含分隔符，那就需要提前做转义处理。第二点就是性能问题，如果消息体特别大，每次查找分隔符的位置的话肯定会有一点消耗。</p><h2 id="5-在头部放入信息长度"><a href="#5-在头部放入信息长度" class="headerlink" title="5.在头部放入信息长度"></a>5.在头部放入信息长度</h2><p>目前应用最广泛的是在消息的头部添加数据包长度，接收方根据消息长度进行接收；在一条TCP连接上，数据的流式传输在接收缓冲区里是有序的，其主要的问题就是第一个包的包尾与第二个包的包头共存接收缓冲区，所以根据长度读取是十分合适的。</p><h3 id="一、Server端：-2"><a href="#一、Server端：-2" class="headerlink" title="一、Server端："></a>一、Server端：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/binary"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listen, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8888"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> listen.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := listen.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">reader := bufio.NewReader(conn)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">//前4个字节表示数据长度</span></span><br><span class="line">peek, err := reader.Peek(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">buffer := bytes.NewBuffer(peek)</span><br><span class="line"><span class="comment">//读取数据长度</span></span><br><span class="line"><span class="keyword">var</span> length <span class="keyword">int32</span></span><br><span class="line">err = binary.Read(buffer, binary.BigEndian, &amp;length)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Buffered 返回缓存中未读取的数据的长度,如果缓存区的数据小于总长度，则意味着数据不完整</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">int32</span>(reader.Buffered()) &lt; length+<span class="number">4</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从缓存区读取大小为数据长度的数据</span></span><br><span class="line">data := <span class="built_in">make</span>([]<span class="keyword">byte</span>, length+<span class="number">4</span>)</span><br><span class="line">_, err = reader.Read(data)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"receive data: %s\n"</span>, data[<span class="number">4</span>:])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、Client端：-2"><a href="#二、Client端：-2" class="headerlink" title="二、Client端："></a>二、Client端：</h3><p>需要注意的是发送数据的编码，这里使用了Go的binary库，先写入4个字节的头，再写入消息主体，最后一起发送过去。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/binary"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8888"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">"dial error:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">data, _ := Encode(<span class="string">"123456789"</span>)</span><br><span class="line">_, err := conn.Write(data)</span><br><span class="line">data, _ = Encode(<span class="string">"888888888"</span>)</span><br><span class="line">_, err = conn.Write(data)</span><br><span class="line">time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">data, _ = Encode(<span class="string">"777777777"</span>)</span><br><span class="line">_, err = conn.Write(data)</span><br><span class="line">data, _ = Encode(<span class="string">"123456789"</span>)</span><br><span class="line">_, err = conn.Write(data)</span><br><span class="line">time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encode</span><span class="params">(message <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 读取消息的长度</span></span><br><span class="line"><span class="keyword">var</span> length = <span class="keyword">int32</span>(<span class="built_in">len</span>(message))</span><br><span class="line"><span class="keyword">var</span> pkg = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line"><span class="comment">// 写入消息头</span></span><br><span class="line">err := binary.Write(pkg, binary.BigEndian, length)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入消息实体</span></span><br><span class="line">err = binary.Write(pkg, binary.BigEndian, []<span class="keyword">byte</span>(message))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pkg.Bytes(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p>世界上本没有“粘包”，只不过是少数人没有正确处理TCP数据边界问题，成熟的应用层协议（http、ssh）都不会存在这个问题。但是如果你使用纯TCP自定义协议，那就需要自己处理好了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-什么是粘包？&quot;&gt;&lt;a href=&quot;#1-什么是粘包？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是粘包？&quot;&gt;&lt;/a&gt;1.什么是粘包？&lt;/h2&gt;&lt;p&gt;“粘包”这个说法已经被诟病很久了，既然坊间流传这个说法咱们就沿用吧，关于这个问题比较准确的解释可以参考下面几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TCP是流传输协议,是一种面向连接的、可靠的、基于字节流的传输层通信协议&lt;/li&gt;
&lt;li&gt;TCP没有包的概念，它只负责传输字节序列，UDP是面向数据报的协议，所以不存在拆包粘包问题&lt;/li&gt;
&lt;li&gt;应该由应用层来维护消息和消息的边界，即需要一个应用层协议，比如HTTP&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，本质上这是一个没有正确使用TCP协议的而产生的问题，有网友说了一句非常形象的话：“打开家里的水龙头， 看着自来水往下流， 然后你告诉我， 看， 自来水粘在一起了， 不是有病？”&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程开发" scheme="https://wangbjun.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 4K显示器缩放设置</title>
    <link href="https://wangbjun.github.io/2019/05/03/ubuntu-4k-scale/"/>
    <id>https://wangbjun.github.io/2019/05/03/ubuntu-4k-scale/</id>
    <published>2019-05-03T04:21:06.000Z</published>
    <updated>2020-01-09T04:55:13.604Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://wangbjun.github.io/images/16d0f0f03263cb7b.jpg" alt=""></p><p>开头一张图介绍一下我现在日常生活和开发使用的电脑配置：Ubuntu 16.04 + i7-8700k + 1060 + nvme ssd + 32G RAM + 4k显示器，这个配置倒不算很高端，但是开发用体验很高，系统的流畅程度非常高</p><a id="more"></a><p>电脑CPU和内存可以差点，ssd是必须有的，另外还有一个亮点是LG的4k显示器，这个体验非常棒，现在4k显示器非常便宜，我这个也就2k左右的价格。</p><p>今天的主题就是4k显示器，众所周知，Mac的显示效果之所以出众是由于其高超的屏幕分辨率，几年前Mac都已经用上了3k分辨率，而且大多数Windows笔记本还用着1080p，苹果的IMac早已经用上了5k显示器。</p><p>换句话说，买Mac买的就是显示屏，没有屏幕的硬件加持，什么操作系统优化都是扯淡！有了4k显示器，你发现装上Windows显示效果也不差，不过这块我需要说一下，同等硬件下，Linux和Mac的显示效果确实要比Windows好一点，对高分屏的支持好很多。</p><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>我个人比较喜欢unity桌面，所以还是用Ubuntu 16.04，我曾经尝试过Ubuntu 18.04，但是感觉gnome桌面在流畅度和易用性方面和unity还是有不少差距，所以本篇文章可能支持适合unity桌面吧</p><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>如果你要换4k显示屏，有一点需要注意，不少i7 CPU 内置集显理论上是带的动4k+60fps的，但是只支持dp接口，不支持hdmi，这一点可以在intel官网的cpu详细规格里面可以查阅。但是大部分主板都不会带dp接口，很少很少，只有极少部分高端主板会带，而现在大部分独显都会带dp口。</p><p>众所周知，NVIDIA的独显在Linux上面的驱动支持都不是太好，但是intel的集显支持非常好，如果你想要使用4k显示器，一个独显少不了，不过据我目前的使用体验来说，1060 表现还不错，建议大家开启高性能模式，如下图：<br><img src="https://wangbjun.github.io/images/16d0f203bbf9601b.jpg" alt=""></p><h2 id="缩放设置"><a href="#缩放设置" class="headerlink" title="缩放设置"></a>缩放设置</h2><p>这是重点，根据我经验，在4k+27英寸显示器的配置下，缩放设置很简单，不需要什么环境变量，直接在显示里面设置缩放就行，默认是1，设置一个1.75-2比较合适。<br><img src="https://wangbjun.github.io/images/16d0f23300cd21d1.jpg" alt=""><br>实际上，上面这个设置好，已经可以解决99%的缩放问题了，不需要什么环境变量，上一些应用的图给大家看看：</p><p><img src="https://wangbjun.github.io/images/16d0f26799e5bf08.jpg" alt=""></p><p><img src="https://wangbjun.github.io/images/16d0f27645283d4e.jpg" alt=""></p><p><img src="https://wangbjun.github.io/images/16d0f27f294742ce.jpg" alt=""></p><h2 id="deepin缩放"><a href="#deepin缩放" class="headerlink" title="deepin缩放"></a>deepin缩放</h2><p>有些软件不走上面的缩放设置，比如deepin qq或wechat，估计很多用Linux的都会使用移植的deepin应用，但是也有办法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WINEPREFIX&#x3D;~&#x2F;.deepinwine&#x2F;Deepin-WeChat deepin-wine winecfg</span><br></pre></td></tr></table></figure><p>在弹出的对话框里面找到graphics设置，设置一个比较合适的dpi，以我个人经验，150-170比较合适，如下图：<br><img src="https://wangbjun.github.io/images/16d0f2ba8e833515.jpg" alt=""></p><h2 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h2><p>网易云的软件在4k下面也是个刺头，暂时没有完美的方案，但是有一个可以凑合用，在网易的desktop文件Exec配置里面加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--force-device-scale-factor&#x3D;1.75</span><br></pre></td></tr></table></figure><h2 id="搜狗输入法"><a href="#搜狗输入法" class="headerlink" title="搜狗输入法"></a>搜狗输入法</h2><p>搜狗输入法其实也是不支持4k自动缩放的，不过我们可以把皮肤的字体设置大一点，达到的效果是一样的：<br><img src="https://wangbjun.github.io/images/16d0f301af11cca2.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://wangbjun.github.io/images/16d0f0f03263cb7b.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;开头一张图介绍一下我现在日常生活和开发使用的电脑配置：Ubuntu 16.04 + i7-8700k + 1060 + nvme ssd + 32G RAM + 4k显示器，这个配置倒不算很高端，但是开发用体验很高，系统的流畅程度非常高&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://wangbjun.github.io/categories/Linux/"/>
    
    
      <category term="Ubuntu" scheme="https://wangbjun.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Go面向对象写法</title>
    <link href="https://wangbjun.github.io/2019/04/19/golang-oop/"/>
    <id>https://wangbjun.github.io/2019/04/19/golang-oop/</id>
    <published>2019-04-19T14:05:43.000Z</published>
    <updated>2020-01-08T17:37:51.849Z</updated>
    
    <content type="html"><![CDATA[<p>Go并不是一个类似于Java、C++，或PHP这样内置面向对象语法的操作的语言，在Go里面名义上是没有类（class）这个概念的，但是这并不代表Go不能面向对象，毕竟面向对象只是一种设计思想！</p><p>为什么Go并不原生支持面向对象呢？这是一个问题</p><p>接下来，我会从面向对象的三大特性封装、继承、多态这个几个方面来讲讲Go是怎么实现的OOP的。</p><a id="more"></a><h3 id="1-封装"><a href="#1-封装" class="headerlink" title="1.封装"></a>1.封装</h3><p>闲话少说，在Go里面可以使用结构体模拟类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Goods struct &#123;</span><br><span class="line">    name  string</span><br><span class="line">    price int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Go里面有一个约定俗称的规则，变量名、结构体名、结构体属性成员名大写代表是公开权限，可以被其它包使用。类似于类的<strong>public</strong>属性。如果小写就类似于<strong>private</strong>属性。</p><p>类里面除了属性之外，一般会有自己的方法，在Go里面可以这样实现(这里我采用的是Go modules结构)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package models</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Goods struct &#123;</span><br><span class="line">    Name  string</span><br><span class="line">    Price int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (g *Goods) GetName() string &#123;</span><br><span class="line">    return g.Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (g *Goods) SetName(name string) &#123;</span><br><span class="line">    g.Name &#x3D; name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (*Goods) String() &#123;</span><br><span class="line">    fmt.Println(&quot;I am Goods&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是在函数名前加一个类型声明，如果你在方法里面不需要使用类本身，则可以省略参数标识。</p><p>如何使用这个“类呢”？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;demo&#x2F;models&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    goods :&#x3D; models.Goods&#123;</span><br><span class="line">        &quot;笔记本&quot;, 100,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Printf(&quot;Goods name is %s\n&quot;, goods.GetName())</span><br><span class="line">    </span><br><span class="line">    goods.SetName(&quot;小米笔记本&quot;)</span><br><span class="line">    </span><br><span class="line">    fmt.Printf(&quot;Goods name is %s\n&quot;, goods.GetName())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以采用字面量赋值的方式初始化对象，虽然结构体并没有构造函数这个东西，但是我们可以造个差不多的方式出来。</p><p>新增这个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func NewGoods(name string, price int) Goods &#123;</span><br><span class="line">    g :&#x3D; Goods&#123;</span><br><span class="line">        Name:  name,</span><br><span class="line">        Price: price,</span><br><span class="line">    &#125;</span><br><span class="line">    return g</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就可以这样使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var goods models.Goods</span><br><span class="line">goods &#x3D; models.NewGoods(&quot;笔记本&quot;, 1000)</span><br></pre></td></tr></table></figure><p>其实区别倒是不大，封装了一下，更加简洁，虽然达不到构造函数自动调用的效果。</p><h3 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h3><p>Go里面并没有extends这样的语法，但是结构体的成员可以是结构体，这实际上是使用组合实现了继承的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package models</span><br><span class="line"></span><br><span class="line">type Apple struct &#123;</span><br><span class="line">    Goods &#x2F;&#x2F;继承了Goods</span><br><span class="line">    Color string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 构造函数</span><br><span class="line">func NewApple(name string, price int, color string) Apple &#123;</span><br><span class="line">    apple :&#x3D; Apple&#123;</span><br><span class="line">        Goods&#123;name, price&#125;,</span><br><span class="line">        color,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return apple</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.go:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;demo&#x2F;models&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    apple :&#x3D; models.NewApple(&quot;红富士苹果&quot;, 200, &quot;red&quot;)</span><br><span class="line">    fmt.Printf(&quot;Apple name is %s&quot;, apple.GetName())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Apple可以使用Goods的方法和属性，使用组合的好处就是不存在多继承的限制，在很多面向对象的语言里面，只能单继承。</p><h3 id="3-多态"><a href="#3-多态" class="headerlink" title="3.多态"></a>3.多态</h3><p>虽然Go里面也没有implements这样的关键字，但是在Go里面可以使用interface来实现多态效果，而且Go里面的接口相当灵活。</p><p>定义接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package models</span><br><span class="line"></span><br><span class="line">type Saleable interface &#123;</span><br><span class="line">    Sell()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现接口(Apple)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (Apple) Sell()  &#123;</span><br><span class="line">    fmt.Println(&quot;我实现了saleable接口&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    apple :&#x3D; models.NewApple(&quot;红富士苹果&quot;, 200, &quot;red&quot;)</span><br><span class="line">    </span><br><span class="line">    var i models.Saleable</span><br><span class="line">    </span><br><span class="line">    i &#x3D; &amp;apple</span><br><span class="line">    </span><br><span class="line">    i.Sell()</span><br><span class="line">&#125;</span><br><span class="line">---结果---</span><br><span class="line">我实现了saleable接口</span><br></pre></td></tr></table></figure><p>划重点，在GO里面只要一个结构体（struct）定义了一个接口(interface)里面的所有方法，就意味着这个这个struct实现了这个接口，这是隐式的。可见，在Go里面接口还是挺好用的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go并不是一个类似于Java、C++，或PHP这样内置面向对象语法的操作的语言，在Go里面名义上是没有类（class）这个概念的，但是这并不代表Go不能面向对象，毕竟面向对象只是一种设计思想！&lt;/p&gt;
&lt;p&gt;为什么Go并不原生支持面向对象呢？这是一个问题&lt;/p&gt;
&lt;p&gt;接下来，我会从面向对象的三大特性封装、继承、多态这个几个方面来讲讲Go是怎么实现的OOP的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程开发" scheme="https://wangbjun.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>详解中间件设计模式</title>
    <link href="https://wangbjun.github.io/2019/03/12/designpattern-middleware/"/>
    <id>https://wangbjun.github.io/2019/03/12/designpattern-middleware/</id>
    <published>2019-03-12T02:02:46.000Z</published>
    <updated>2020-01-08T09:49:48.919Z</updated>
    
    <content type="html"><![CDATA[<p>说到中间件（middleware），很多人应该都听说过，但是大体有2种意思，一种是一些衔接不同软件活系统的中间软件，比如说数据库中间件、消息中间件。另一种是在Web软件开发中代码层面的一种设计模式，比如说用户认证中间件、日志中间件，这些中间件的主要作用就是以一种集中统一、几乎无侵入的的方式去处理用户请求,而今天我们要讲的就是中间件设计模式。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>说起中间件模式，估计很多人都想起来下面这张图，一个Web请求经过多个中间件的过滤，像pipeline一样处理这个请求，最终返回响应。</p><p><img src="http://ww1.sinaimg.cn/large/5f6e3e27ly1g3ow77jcovj20it0e9aas.jpg" alt=""></p><p>中间件往往部署在路由的地方，用于统一过滤请求，举个例子，我们有一个特殊的服务，必须要求用户的年龄大于18岁，如果不使用中间件，我们传统的做法就是在每个请求的控制器或者方法里面做判断，从功能上说没啥问题，但是代码不够优雅，需要写很多重复代码，而且不利于维护，哪天我们要把这个年龄改成20岁呢？</p><p><img src="http://ww1.sinaimg.cn/large/5f6e3e27ly1g3owo9uj4hj20i30a1t9o.jpg" alt=""></p><p>但是常见的23种设计模式里面并没有中间件模式，其实中间件是管道模式（也有人说是装饰模式）的一种实现，我也不知道为什么大部分框架都叫做中间件(middleware)…?</p><p>说个题外话，大部分设计模式主要就是为了解耦，提高代码可维护性和扩展性，并不是必须的，但是大部分情况下还是有益的。</p><h2 id="管道模式"><a href="#管道模式" class="headerlink" title="管道模式"></a>管道模式</h2><p>管道又称为pipeline，又叫流水线，工厂里面流水线大家应该都见过，一个产品需要经过很多道工序才能完成，比如苹果手机的一根数据线，大概有20多道工序，在工厂里面这些数据线会被放到传送带上面，依次完成各个工序，我们可以把一个请求看作是一个产品，流水线的每道工序看作是处理对象。</p><p>下面直接看代码：</p><p>1.Middleware.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Middleware</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">execute</span><span class="params">(Closure $next)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.LogMiddleware.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogMiddleware</span> <span class="keyword">implements</span> <span class="title">Middleware</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">execute</span><span class="params">(Closure $next)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Before Log!\n"</span>;</span><br><span class="line">        $next();</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"After Log!\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.AuthMiddleware.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthMiddleware</span> <span class="keyword">implements</span> <span class="title">Middleware</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">execute</span><span class="params">(Closure $next)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Before Check Auth!\n"</span>;</span><br><span class="line">        $next();</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"After Check Auth!\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.Client.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $middlewares = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addMiddleware</span><span class="params">(Middleware $middleware)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;middlewares[] = $middleware;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getClosure</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">($current, $next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($current, $next)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">new</span> $next)-&gt;execute($current);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">defaultHandler</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"开始处理!\n"</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handler</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        call_user_func(array_reduce(<span class="keyword">$this</span>-&gt;middlewares, <span class="keyword">$this</span>-&gt;getClosure(), <span class="keyword">$this</span>-&gt;defaultHandler()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们定义了一个Middleware接口，规定了需要实现的方法，然后定义了多个具体实现类。有一个非常关键的地方就是这个方法的参数是有一个闭包函数，然后在实现类里面我们都必须调用这个方法。</p><p>最核心的代码在于Client类，首先它有一个成员变量，里面存储了多个实现了Middleware接口的对象，这个类里面最关键的方法就是getClosure，它返回一个闭包函数，这个闭包函数接受2个参数，这2个参数都是实现了Middleware接口的对象，但是这个闭包函数并没有立马执行。</p><p>其中一个非常关键的函数就是array_reduce,根据官方文档，array_reduce() 将回调函数 callback 迭代地作用到 array 数组中的每一个单元中，从而将数组简化为单一的值。先看一个非常简单的例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">$sum = array_reduce($arr, <span class="string">'sum'</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">($a, $b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"before add: $a, $b\n"</span>;</span><br><span class="line">  $sum =  $a + $b;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"after add: $a, $b\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> $sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump($sum);</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">before add: <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">after add: <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">before add: <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">after add: <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">before add: <span class="number">3</span>, <span class="number">3</span></span><br><span class="line">after add: <span class="number">3</span>, <span class="number">3</span></span><br><span class="line">before add: <span class="number">6</span>, <span class="number">4</span></span><br><span class="line">after add: <span class="number">6</span>, <span class="number">4</span></span><br><span class="line">before add: <span class="number">10</span>, <span class="number">5</span></span><br><span class="line">after add: <span class="number">10</span>, <span class="number">5</span></span><br><span class="line"></span><br><span class="line">int(<span class="number">15</span>)</span><br></pre></td></tr></table></figure><p>可见array_reduce会循环的把数组里面的数据两两代入函数，然后把返回的结果当作新的参数再次代入函数,最终会返回一个多层嵌套的闭包函数，然后通过call_user_func触发调用，这时候就会像拨洋葱一样，先从外面到里面，再从里面往外面。。。</p><p>上面的例子运行代码和结果如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$client = <span class="keyword">new</span> Client();</span><br><span class="line"></span><br><span class="line">$client-&gt;addMiddleware(<span class="keyword">new</span> LogMiddleware())</span><br><span class="line">    -&gt;addMiddleware(<span class="keyword">new</span> AuthMiddleware());</span><br><span class="line"></span><br><span class="line">$client-&gt;handler();</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Before Check age!</span><br><span class="line">Before Log!</span><br><span class="line">开始处理!</span><br><span class="line">After Log!</span><br><span class="line">After Check Age!</span><br></pre></td></tr></table></figure><p>仔细看一下这个结果，是不是非常像第一张图那样，不过这个例子里面少了一个非常重要的request对象，这里纯粹只是展示中间件运行原理，完整的实战代码可以参考laravel框架里面的源码，实现原理差不多，只不过框架功能更加全面，考虑的东西更多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说到中间件（middleware），很多人应该都听说过，但是大体有2种意思，一种是一些衔接不同软件活系统的中间软件，比如说数据库中间件、消息中间件。另一种是在Web软件开发中代码层面的一种设计模式，比如说用户认证中间件、日志中间件，这些中间件的主要作用就是以一种集中统一、几乎无侵入的的方式去处理用户请求,而今天我们要讲的就是中间件设计模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程开发" scheme="https://wangbjun.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="中间件" scheme="https://wangbjun.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Golang字符串处理函数浅析</title>
    <link href="https://wangbjun.github.io/2019/02/12/golang-string-function/"/>
    <id>https://wangbjun.github.io/2019/02/12/golang-string-function/</id>
    <published>2019-02-12T12:15:43.000Z</published>
    <updated>2020-01-09T07:39:30.361Z</updated>
    
    <content type="html"><![CDATA[<p>很多从PHP转Go的小伙伴经常会怀恋PHP丰富的字符串函数，Go的标准库针对字符串的操作函数虽然不少但是还是不够丰富，很多时候还得自己造，下面我就结合PHP里面字符串的操作函数来说说Go里面怎么实现。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>Go是强类型语言，有一个单独的字符串类型 string，如果熟悉Go语言的人应该了解string底层是切片，切片底层是数组，所以字符串也叫字符数组。</p><p>举个最简单的例子，有一个字符串 12ab34cd56, 我们要获取其第3到第5个字符之间的元素怎么做呢？</p><p>熟悉PHP的童鞋可以会想到PHP里面有一个 substr的函数可以做到，但是Go里面呢？</p><p>我们打开IDE看一下，其实标准库里面的 strings 包已经有非常多的函数了，大约有20多个，包含常见的trim、index、replace、contain等功能，但是没有找到我们想要的？</p><p>其实很简单，因为string本质上是切片，所以我们可以直接使用切片来分割字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := <span class="string">"12ab34cd56"</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, str[<span class="number">2</span>:<span class="number">4</span>]) <span class="comment">//ab</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, str[<span class="number">3</span>:]) <span class="comment">//b34cd56</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, str[:<span class="number">3</span>]) <span class="comment">//12a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片的切割用法就不多说了，从0角标开始，包含开始，不包含结束。</p><p>不过这种写法是有bug的，它只可以针对单字节字符，针对中文这种多字节字符串就不可以了，PHP里面也一样，PHP里面针对多字节字符有一个 mbstring 扩展，也有 mb_substr 这样的函数专门处理多字节字符。</p><h2 id="Rune"><a href="#Rune" class="headerlink" title="Rune"></a>Rune</h2><p>在国内编程，大部分时候不可避免的要处理中文字符串，所以像计算长度、切割一定要处理好多字节的问题，Go里面针对多字节的字符有一个rune类型，针对上面的这个问题，我们这样做：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := <span class="string">"我爱学习Go语言"</span></span><br><span class="line"></span><br><span class="line">rStr := []<span class="keyword">rune</span>(str)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, <span class="keyword">string</span>(rStr[<span class="number">2</span>:<span class="number">4</span>])) <span class="comment">//学习</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, <span class="keyword">string</span>(rStr[<span class="number">3</span>:])) <span class="comment">//习Go语言</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, <span class="keyword">string</span>(rStr[:<span class="number">3</span>])) <span class="comment">//我爱学</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式完全没问题，如果说问题可能就在于多了一次内存分配，那rune到底是什么呢？</p><p>rune类型在Go里面实际上是int32的别名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is</span></span><br><span class="line"><span class="comment">// used, by convention, to distinguish byte values from 8-bit unsigned</span></span><br><span class="line"><span class="comment">// integer values.</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rune is an alias for int32 and is equivalent to int32 in all ways. It is</span></span><br><span class="line"><span class="comment">// used, by convention, to distinguish character values from integer values.</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br></pre></td></tr></table></figure><p>byte是8位，可以表示-128-127之间的数，用来存储单字节字符刚好，但是中文一般使用2-3个字节表示，byte就无能为力了，但是int32用来表示世界上所有字符也绰绰有余。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">r := <span class="string">"我爱学习Go语言"</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, r)</span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, []<span class="keyword">byte</span>(r))</span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, []<span class="keyword">rune</span>(r))</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果如下：</span></span><br><span class="line">我爱学习Go语言</span><br><span class="line">[<span class="number">230</span> <span class="number">136</span> <span class="number">145</span> <span class="number">231</span> <span class="number">136</span> <span class="number">177</span> <span class="number">229</span> <span class="number">173</span> <span class="number">166</span> <span class="number">228</span> <span class="number">185</span> <span class="number">160</span> <span class="number">71</span> <span class="number">111</span> <span class="number">232</span> <span class="number">175</span> <span class="number">173</span> <span class="number">232</span> <span class="number">168</span> <span class="number">128</span>]</span><br><span class="line">[<span class="number">25105</span> <span class="number">29233</span> <span class="number">23398</span> <span class="number">20064</span> <span class="number">71</span> <span class="number">111</span> <span class="number">35821</span> <span class="number">35328</span>]</span><br></pre></td></tr></table></figure><p>从上面的例子也可以说明，中文“我”实际上是以230 136 145 3个字节表示的，但是在rune类型里面是以25105表示的，这个数是Unicode编码的10进制表现形式。</p><p>所以，我们可以把一个字符串先转成rune数组，然后再使用切片切割。</p><h2 id="for…range"><a href="#for…range" class="headerlink" title="for…range"></a>for…range</h2><p>字符串本质上是字符数组，所以有也可以使用range遍历，而且range在迭代字符串的时候也是按字符遍历的，我们也可以利用这点分割字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubString</span><span class="params">(str <span class="keyword">string</span>, start, end <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> n, i, k <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k = <span class="keyword">range</span> str &#123;</span><br><span class="line"><span class="keyword">if</span> n == start &#123;</span><br><span class="line">i = k</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n == end &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">n++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> str[i:k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><p>再看一个比较常见的PHP函数，反转字符串，在Go标准库里面也没有相应的实现</p><p>如果只考虑单字节我们可以很容易写出下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReverseString</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">b := []<span class="keyword">byte</span>(str)</span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(b)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(b)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">b[i], b[j] = b[j], b[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果考虑到中文等多字节字符可以参考下面这种方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReverseRuneString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> start, size, end <span class="keyword">int</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(s))</span><br><span class="line"><span class="keyword">for</span> end &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">_, size = utf8.DecodeRuneInString(s[start:])</span><br><span class="line">end = start + size</span><br><span class="line"><span class="built_in">copy</span>(buf[<span class="built_in">len</span>(buf)-end:], s[start:end])</span><br><span class="line">start = end</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(buf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p>除了字符串之外，PHP的数组功能也很强大，如果你不想自己造轮子，可以使用现成的第三方库，下面简单介绍一下几个项目：</p><h3 id="1-https-github-com-syyongx-php2go"><a href="#1-https-github-com-syyongx-php2go" class="headerlink" title="1.https://github.com/syyongx/php2go"></a>1.<a href="https://github.com/syyongx/php2go" target="_blank" rel="noopener">https://github.com/syyongx/php2go</a></h3><p>这个项目是使用Go实现PHP内置的函数库，东西比较多，不过这个库里面并没有特殊处理多字节字符串，需要注意一下。</p><h3 id="2-https-github-com-thinkeridea-go-extend"><a href="#2-https-github-com-thinkeridea-go-extend" class="headerlink" title="2.https://github.com/thinkeridea/go-extend"></a>2.<a href="https://github.com/thinkeridea/go-extend" target="_blank" rel="noopener">https://github.com/thinkeridea/go-extend</a></h3><p>这个项目收集了一些常用的操作函数，辅助更快的完成开发工作，并减少重复代码，都是一些比较实用的函数，虽然没有第一个那么全。</p><h3 id="3-https-github-com-jianfengye-collection"><a href="#3-https-github-com-jianfengye-collection" class="headerlink" title="3.https://github.com/jianfengye/collection"></a>3.<a href="https://github.com/jianfengye/collection" target="_blank" rel="noopener">https://github.com/jianfengye/collection</a></h3><p>Collection包目标是用于替换golang原生的Slice，使用场景是在大量不追求极致性能，追求业务开发效能的场景。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很多从PHP转Go的小伙伴经常会怀恋PHP丰富的字符串函数，Go的标准库针对字符串的操作函数虽然不少但是还是不够丰富，很多时候还得自己造，下面我就结合PHP里面字符串的操作函数来说说Go里面怎么实现。&lt;/p&gt;
&lt;h2 id=&quot;String&quot;&gt;&lt;a href=&quot;#String
      
    
    </summary>
    
    
      <category term="编程开发" scheme="https://wangbjun.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.github.io/tags/Golang/"/>
    
  </entry>
  
</feed>
