<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JWang的博客</title>
  
  <subtitle>一点记录，一点想法，一点思考</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wangbjun.site/"/>
  <updated>2020-07-01T15:18:09.269Z</updated>
  <id>https://wangbjun.site/</id>
  
  <author>
    <name>Ben Jun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Web框架Gin的封装处理</title>
    <link href="https://wangbjun.site/2020/coding/golang/gen.html"/>
    <id>https://wangbjun.site/2020/coding/golang/gen.html</id>
    <published>2020-07-01T14:40:10.000Z</published>
    <updated>2020-07-01T15:18:09.269Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，Golang非常适合用于开发高性能的API，开源的Web框架也很多，比如国产的Beego，以及在目前最流行的Gin，还有Echo、Iris、Revel等框架。</p><p>由于博主之前从事过PHP，相比来说，感觉Go的这些框架都比较轻量，很多时候还需要自己花点功夫再打理一下，比如这些框架都没有处理数据库这块，Beego虽然自带了一个ORM，但是可用性极差，需要我们自己手动去集成一些开源的组件。</p><p>就拿我用过比较多的Gin框架（ <a href="https://github.com/gin-gonic/gin" target="_blank" rel="noopener">https://github.com/gin-gonic/gin</a> ）来说，它属于其中最轻量级的框架，主要功能包括路由、请求参数、中间件、模板等，存在一些缺失的东西，比如：</p><ul><li><p>没有推荐项目结构模块划分，很多人不知道代码咋存放</p></li><li><p>缺少数据库ORM，虽说Go标准库支持数据库，但是缺少封装，用起来麻烦</p></li><li><p>缺少配置文件加载功能，任何项目都少不了配置文件</p></li><li><p>日志处理功能不够强大</p></li></ul><p>所以，我基于Gin加上一些开源的组件，封装了一个不算是框架的框架，这里暂且称其为Gen，主要是便于快速开发，解决一些通用性的问题。</p><p>地址：<a href="https://github.com/wangbjun/gen" target="_blank" rel="noopener">https://github.com/wangbjun/gen</a></p><a id="more"></a><h2 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1.项目结构"></a>1.项目结构</h2><p>这里参照了PHP的Web框架 <strong>Laravel</strong> 的结构，整体上是一个MVC结构：</p><img src="/images/2020-07-01_22-15.png" width="50%"/><p>基本上包含一个Web框架应该有的东西，包括路由、控制器层、模型层、service层等，便于我们存放代码，开发起来也方便很多，通过文件夹名字我们就能了解各个包的主要作用。</p><p>项目使用Go Mod解决依赖，接下来我依次介绍一些主要模块的功能</p><h2 id="2-Main入口"><a href="#2-Main入口" class="headerlink" title="2.Main入口"></a>2.Main入口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"gen/config"</span></span><br><span class="line">    <span class="string">"gen/router"</span></span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gin.SetMode(getMode())</span><br><span class="line">    engine := gin.New()</span><br><span class="line">    engine.Use(gin.Recovery())</span><br><span class="line">    <span class="comment">// 加载路由</span></span><br><span class="line">    router.Route(engine)</span><br><span class="line">    <span class="comment">// 启动服务器</span></span><br><span class="line">    log.Println(<span class="string">"server started success"</span>)</span><br><span class="line">    err := engine.Run(<span class="string">":"</span> + config.GetAPP(<span class="string">"PORT"</span>).String())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"server start failed, error: %s"</span>, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMode</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    debug := config.GetAPP(<span class="string">"DEBUG"</span>).String()</span><br><span class="line">    <span class="keyword">if</span> debug == <span class="string">"true"</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gin.DebugMode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gin.ReleaseMode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main里面第一步就是加载配置文件，然后根据配置文件设置Gin的模式以及服务监听的端口，然后这里还有一些”隐藏“的init初始化操作，比如在初始化路由的过程中加载了数据库配置并且建立数据库连接、还有初始化日志配置等，具体可以查看各个包的init函数。</p><h2 id="3-配置文件"><a href="#3-配置文件" class="headerlink" title="3.配置文件"></a>3.配置文件</h2><p>默认配置文件是同级目录下的 <strong>app.ini</strong>，这里采用了<code>gopkg.in/ini.v1</code>开源库解析配置，格式也是非常简单的k-v格式，举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[APP]</span><br><span class="line">PORT &#x3D; 8080</span><br><span class="line">DEBUG &#x3D; true</span><br><span class="line">URL &#x3D; http:&#x2F;&#x2F;127.0.0.1:8080</span><br><span class="line">LOG_FILE &#x3D; storage&#x2F;logs&#x2F;app.log</span><br><span class="line">LOG_LEVEL &#x3D; info</span><br><span class="line"></span><br><span class="line">[DB]</span><br><span class="line">Dialect &#x3D; mysql</span><br><span class="line">DSN &#x3D; root:123456@tcp(127.0.0.1:3306)&#x2F;blog?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local</span><br><span class="line">MAX_IDLE_CONN &#x3D; 5</span><br><span class="line">MAX_OPEN_CONN &#x3D; 50</span><br></pre></td></tr></table></figure><p>加载配置文件的代码位于<code>config/Config.go</code>文件里面，逻辑非常简单，也支持通过”-c“指定配置文件，这里定义了一个包全局变量，一次加载，终身使用，具体的日志读取API可以参考这个库的官方文档。</p><h2 id="4-日志处理"><a href="#4-日志处理" class="headerlink" title="4.日志处理"></a>4.日志处理</h2><p>日志这块采用了来自uber的 <strong>zap</strong> 库，高性能，扩展性也很强，代码位于<code>zlog/ZapLogger.go</code>文件，主要操作是根据加载的配置文件初始化日志级别、存储位置、存储格式以及自动分割等配置。</p><p>默认情况下，日志存储在<code>storage/logs</code>文件夹下，格式是JSON</p><p>日志这块有一个特殊的功能，可以选择为每个日志加上traceId，便于追踪排查问题，核心代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getContext</span><span class="params">(ctx *gin.Context)</span> []<span class="title">zap</span>.<span class="title">Field</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        now          = time.Now().Format(<span class="string">"2006-01-02 15:04:05.000"</span>)</span><br><span class="line">        processId    = os.Getpid()</span><br><span class="line">        startTime, _ = ctx.Get(<span class="string">"startTime"</span>)</span><br><span class="line">        duration     = <span class="keyword">float64</span>(time.Now().Sub(startTime.(time.Time)).Nanoseconds()/<span class="number">1e4</span>) / <span class="number">100.0</span> <span class="comment">//单位毫秒,保留2位小数</span></span><br><span class="line">        serviceStart = startTime.(time.Time).Format(<span class="string">"2006-01-02 15:04:05.000"</span>)</span><br><span class="line">        request      = ctx.Request.RequestURI</span><br><span class="line">        hostAddress  = ctx.Request.Host</span><br><span class="line">        clientIp     = ctx.ClientIP()</span><br><span class="line">        traceId      = ctx.GetString(<span class="string">"traceId"</span>)</span><br><span class="line">        parentId     = ctx.GetString(<span class="string">"parentId"</span>)</span><br><span class="line">        params       = ctx.Request.PostForm</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> []zap.Field&#123;</span><br><span class="line">        zap.String(<span class="string">"traceId"</span>, traceId),</span><br><span class="line">        zap.String(<span class="string">"serviceStart"</span>, serviceStart),</span><br><span class="line">        zap.String(<span class="string">"serviceEnd"</span>, now),</span><br><span class="line">        zap.Int(<span class="string">"processId"</span>, processId),</span><br><span class="line">        zap.String(<span class="string">"request"</span>, request),</span><br><span class="line">        zap.String(<span class="string">"params"</span>, params.Encode()),</span><br><span class="line">        zap.String(<span class="string">"hostAddress"</span>, hostAddress),</span><br><span class="line">        zap.String(<span class="string">"clientIp"</span>, clientIp),</span><br><span class="line">        zap.String(<span class="string">"parentId"</span>, parentId),</span><br><span class="line">        zap.Float64(<span class="string">"duration"</span>, duration)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想记录当前请求的一些信息可以使用<code>zlog.WithContext(ctx).Sugar().Infof(&quot;log msg&quot;)</code>这种写法来记录，同理，详细API可以参考其官方文档。</p><h2 id="5-数据库处理"><a href="#5-数据库处理" class="headerlink" title="5.数据库处理"></a>5.数据库处理</h2><p>这里采用了知名的<strong>gorm</strong>开源库，数据库的配置在<code>Conf/Database.go</code>里面，这里可以定义多个数据库配置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> config</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DBConfig <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    DBConfig = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">"default"</span>: &#123;</span><br><span class="line">            <span class="string">"dialect"</span>:      Conf.Section(<span class="string">"DB"</span>).Key(<span class="string">"Dialect"</span>).String(),</span><br><span class="line">            <span class="string">"dsn"</span>:          Conf.Section(<span class="string">"DB"</span>).Key(<span class="string">"DSN"</span>).String(),</span><br><span class="line">            <span class="string">"maxIdleConns"</span>: Conf.Section(<span class="string">"DB"</span>).Key(<span class="string">"MAX_IDLE_CONN"</span>).String(),</span><br><span class="line">            <span class="string">"maxOpenConns"</span>: Conf.Section(<span class="string">"DB"</span>).Key(<span class="string">"MAX_OPEN_CONN"</span>).String(),</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"user"</span>: &#123;</span><br><span class="line">            <span class="string">"dialect"</span>:      Conf.Section(<span class="string">"DB"</span>).Key(<span class="string">"Dialect"</span>).String(),</span><br><span class="line">            <span class="string">"dsn"</span>:          Conf.Section(<span class="string">"DB"</span>).Key(<span class="string">"DSN"</span>).String(),</span><br><span class="line">            <span class="string">"maxIdleConns"</span>: Conf.Section(<span class="string">"DB"</span>).Key(<span class="string">"MAX_IDLE_CONN"</span>).String(),</span><br><span class="line">            <span class="string">"maxOpenConns"</span>: Conf.Section(<span class="string">"DB"</span>).Key(<span class="string">"MAX_OPEN_CONN"</span>).String(),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>model/DB.go</code>文件里面，初始化了所有的DB配置，并且提供一个快速访问的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取默认db</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DB</span><span class="params">()</span> *<span class="title">gorm</span>.<span class="title">DB</span></span> &#123;</span><br><span class="line">    conn, ok := dbConnections[<span class="string">"default"</span>]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> conn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取user db</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserDB</span><span class="params">()</span> *<span class="title">gorm</span>.<span class="title">DB</span></span> &#123;</span><br><span class="line">    conn, ok := dbConnections[<span class="string">"user"</span>]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> conn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取db连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetDB</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">gorm</span>.<span class="title">DB</span></span> &#123;</span><br><span class="line">    conn, ok := dbConnections[name]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> conn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于gorm的详细用法可以参考其官方文档：<a href="https://gorm.io/" target="_blank" rel="noopener">https://gorm.io/</a></p><h2 id="6-其它"><a href="#6-其它" class="headerlink" title="6.其它"></a>6.其它</h2><p>middleware文件夹里面主要一些中间件，比如说用户鉴权、请求日志的中间件，使用的时候需要在路由里面配置，这个可以参考Gin框架文档。</p><p>目前我的习惯是<strong>MVC+Service</strong>这套结构（纯api的话就没有V了），不过如果业务逻辑简单，直接全写在控制器里面也没多大问题。但是如果使用这套结构一定要注意划分好代码层次，不要出现相互引用的情况，比如说model包使用controller包定义的东西，然后controller又使用了model包里面的东西，这样的写法在PHP里面没问题，但是在Go里面无法通过编译。</p><p>所以，从最佳实践上说，应该是controller调model，model调service这个顺序，不可反向操作。</p><p>最后，这个项目自带了一个包括用户注册登录以及发表文章、查看文章的API的功能，具体可以查看项目README文件，如果想使用的话建议直接clone本项目，然后在这个基础上修改。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，Golang非常适合用于开发高性能的API，开源的Web框架也很多，比如国产的Beego，以及在目前最流行的Gin，还有Echo、Iris、Revel等框架。&lt;/p&gt;
&lt;p&gt;由于博主之前从事过PHP，相比来说，感觉Go的这些框架都比较轻量，很多时候还需要自己花点功夫再打理一下，比如这些框架都没有处理数据库这块，Beego虽然自带了一个ORM，但是可用性极差，需要我们自己手动去集成一些开源的组件。&lt;/p&gt;
&lt;p&gt;就拿我用过比较多的Gin框架（ &lt;a href=&quot;https://github.com/gin-gonic/gin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/gin-gonic/gin&lt;/a&gt; ）来说，它属于其中最轻量级的框架，主要功能包括路由、请求参数、中间件、模板等，存在一些缺失的东西，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;没有推荐项目结构模块划分，很多人不知道代码咋存放&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;缺少数据库ORM，虽说Go标准库支持数据库，但是缺少封装，用起来麻烦&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;缺少配置文件加载功能，任何项目都少不了配置文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;日志处理功能不够强大&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，我基于Gin加上一些开源的组件，封装了一个不算是框架的框架，这里暂且称其为Gen，主要是便于快速开发，解决一些通用性的问题。&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&quot;https://github.com/wangbjun/gen&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/wangbjun/gen&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="https://wangbjun.site/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.site/tags/Golang/"/>
    
      <category term="Gin" scheme="https://wangbjun.site/tags/Gin/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Go网络编程</title>
    <link href="https://wangbjun.site/2020/coding/golang/tcp-programing.html"/>
    <id>https://wangbjun.site/2020/coding/golang/tcp-programing.html</id>
    <published>2020-06-22T14:00:00.000Z</published>
    <updated>2020-06-22T15:06:29.295Z</updated>
    
    <content type="html"><![CDATA[<p>聊一聊Go网络编程开发，说到网络编程开发必然离不开网络协议，大家最熟知的莫过于TCP/IP体系，实际上开发中，大家接触的最多的还是HTTP协议。在理论上，OSI模型把网络分成7层，但实际应用中是分为4层，从下到上分别是物理接口层、网络层、传输层、应用层。</p><p>每一层做不同的事情，分工明确，同时便于扩展，比如物理层指的就是网卡，又被称为调制解调器，它负责把电信号和数字信号之间做转换，这一块其实很多人不理解，也是非常难理解的地方，下面咱就聊一聊。</p><a id="more"></a><h2 id="1-OSI网络模型"><a href="#1-OSI网络模型" class="headerlink" title="1.OSI网络模型"></a>1.OSI网络模型</h2><img src="/images/2020-06-22_21-53.png" width="70%"><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>首先，大家需要知道，我们在电脑上（虚拟世界）在键盘上敲的文字最终会被转换成<strong>01010011</strong>这样的形式去保存或传输。有人就杠了，我明明看到记事本里面存的是中文啊，不是0和1。你可以这么理解，记事本只是一个软件，它运行在操作系统之上，当你查看一个文档的时候，首先这个软件会通过IO调用，打开存储在你磁盘上的文件，这个文件必然是二进制的，如果软件直接显示给你，你肯定看不懂（不排除有高手可以人眼读懂二进制）。这个时候这个软件就做了一件事，它根据你保存文件时候的编码方式（GBK或者UTF8），把0和1转换成了你能看懂的字符（人类的文字）。</p><p>这个过程是必须的，实际上任何人类可读的文本都必须有编码方式，不然像记事本这类工具就歇菜了，比如以前中文还分为了GBK、GB2130等好几种编码，好在现在全世界基本上都统一用UTF8了，编码问题不常见了。</p><p>但是在物理上（现实世界）并没有0和1这2个东西，0和1这只是人类为了方便记忆虚构的一个概念，我们需要能够代表0和1意思的东西或者机制。</p><p>人类为了记录数据，最原始的做法就是刻字，后来发明了纸和笔。现代的机械硬盘得工作原理就像是刻字，只不过笔是磁头，纸是磁盘，它通过一种复杂的机制去保存0和1的状态。可以说，人类发明的所有计算机以及网络设备都是在以各种花样的形式处理、保存、读取0和1，二进制是所有计算机文明的基础。</p><p>磁盘解决了存储问题，我们只需要把磁盘插入电脑设备接口，然后读取里面的内容，但是通过网络传输就不太一样了，因为这个网线并不认识0和1，所以就有人发明了网卡，它能把通过网线传输的电信号转换成计算机认识的0和1，现在很多都是光纤网络，光猫的作用就算把光信号转换成数字信号。</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>越过物理层之后，来到网络层就相对简单很多了，这一层就开始有代码了，这也是IP协议所在的地方，IP协议本质上解决的是2个网络设备之间<strong>端到端</strong>的传输问题，至于包里面放的是TCP还是UDP它不管。</p><p>可能有人觉得这一层比较简单，实际上并不是，如果单纯的只是局域网里面2台机器端对端之间传输确实不复杂，但是如果放大到整个国家，两台电脑之间通信得经过无数台路由器、交换机等通信设备，如何选择最快的路径、如何高效的转发数据等也并非易事。</p><p>然而，作为程序员，一般也很少接触这一层，这一层更多还是基于硬件做一些开发，比如说交换机、路由器等通信设备。</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>到了这一层，基本上就算代码的世界了，也是程序员接触非常多的一层，比如TCP协议，TCP人如其名：传输<strong>控制</strong>协议，其中重点在于控制。说白了，就是怎么保证数据传输完整可靠，所以就有了三次握手、拥堵控制等机制。</p><p>当然能在这一层做开发的都是大神级别的程序员，很多时候我们只是去用、理解这个TCP协议，更多的普通程序员还在下一层。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>这一层最知名的就是HTTP协议，相比上面的TCP协议简单多了，协议内容都是文本的，人眼直接看就明白了。</p><p>这块有个误区，有人说HTTP协议是超文本传输协议，是不是意味着传输的内容都是文本？肯定不是，虽然说HTTP经常用来做Web开发，并不是说人家只能用来传输HTML，二进制内容也是没问题的，这里的文本是指协议内容，具体就是指请求头和响应头。</p><p>应用层的协议非常之多，因为门槛太低了，是个人都能开发一个协议，算上那种私有和公有的协议，估计得有几千种，很多公司一言不合就搞个协议出来自己玩，但是这么多年过去了，成为事实标准的协议并不多，开发常用的也就那几个。</p><h2 id="2-封包和拆包"><a href="#2-封包和拆包" class="headerlink" title="2.封包和拆包"></a>2.封包和拆包</h2><p>理解了OSI模型之外，我们还需要知道一点，那就网络通信的时候是有2个端，虽然来说有server端和client端之分，实际上区别不大，因为TCP的通信是双向的，无论是client还是server都可以发送接受数据。</p><p>实际上，每一次完整的通信都需要经过2个过程，一个是封包，一个是解包，这个2个过程是相反的，这有点像是剥洋葱，从一边到另一边，必须先从外向里剥，然后再从里向外剥，洋葱芯就是物理层。</p><img src="/images/2020-06-22_21-56.png" width="70%"><p>其实这个过程对于开发者来说是隐藏的，实际上开发中我们也不需要一步步一层层封装，但是我们需要了解这个过程。</p><h2 id="3-Go编程实战"><a href="#3-Go编程实战" class="headerlink" title="3.Go编程实战"></a>3.Go编程实战</h2><p>Go自带的net库有着非常丰富的功能，封装的非常强大，有时候我们也称之为Socket编程，它是介于传输层和应用层之间的抽象层，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><p>一张经典的TCP网络编程的流程图即可解释完整过程：</p><img src="/images/2020-06-22_22-13.png" width="70%"><p>下面让咱一下实战代码：</p><h3 id="一、server端"><a href="#一、server端" class="headerlink" title="一、server端"></a>一、server端</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.Listen</span></span><br><span class="line">    listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8080"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"Listen error!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> listener.Close()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 2.Accept</span></span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">"Accept error!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">        <span class="comment">// 3.Read</span></span><br><span class="line">        length, err := conn.Read(buf)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">"Read from conn error!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fmt.Printf(<span class="string">"Recived Data: %s\n"</span>, <span class="keyword">string</span>(buf[:length]))</span><br><span class="line"></span><br><span class="line">        conn.Write([]<span class="keyword">byte</span>(<span class="string">"Hello from server\n"</span>))</span><br><span class="line">        <span class="comment">// 4.Close</span></span><br><span class="line">        conn.Close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码基本上没什么难度，就是那几个调用，但是这几个调用的背后才是网络通信的核心，今天先不说原理，单论这段代码，它实现了一个TCP服务器，能够接受请求，读取输入，写入一段输出，然后关闭连接。但是这个服务只是演示，实际应用存在很多问题，比如说并发能力弱、存在”粘包“问题。</p><p>怎么去验证这个服务呢？咱先拿Telnet试一下,Telnet发送的数据是纯TCP数据</p><img src="/images/2020-06-22_22-26.png" width="70%"><p>不过我们也可以拿ssh试试，你会发现会报错，当然这很正常，我们又没有去实现ssh协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jwang@jun:~$ ssh root@127.0.0.1 -p 8080</span><br><span class="line">ssh_exchange_identification: Connection closed by remote host</span><br></pre></td></tr></table></figure><p>同时server端这边的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Recived Data: SSH-2.0-OpenSSH_7.2p2 Ubuntu-4ubuntu2.10</span><br></pre></td></tr></table></figure><p>这说明一个事情，ssh客户端发的第一个包的内容是ssh的版本，当然由于服务端没有按照协议的方式正确的响应结果，所以自然无法正常连接。</p><h3 id="二、client端"><a href="#二、client端" class="headerlink" title="二、client端"></a>二、client端</h3><p>除了使用一些现成的工具之外，我们也可以自己实现一个客户端去连接我们刚刚写的服务端，也是非常简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.Dial</span></span><br><span class="line">    conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8080"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.Write</span></span><br><span class="line">    conn.Write([]<span class="keyword">byte</span>(<span class="string">"Hello from client\n"</span>))</span><br><span class="line"></span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">    <span class="comment">// 3.Read</span></span><br><span class="line">    length, err := conn.Read(buf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Recived Data: %s\n"</span>, <span class="keyword">string</span>(buf[:length]))</span><br><span class="line">    <span class="comment">// 4.Close</span></span><br><span class="line">    conn.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码也非常简单不作多说，就是建立一个连接，然后发送数据、接受数据、关闭连接的过程。大家在使用这个net库的时候会发现还有<code>ListenTCP</code>、<code>DialTCP</code>等方法，其实底层都一样，只是参数写法上<code>ListenTCP</code>更加严谨。虽然只是几个简单的函数调用，但是其背后却代表整个OSI网络模型，Go在这方面是大大简化了网络编程的复杂度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;聊一聊Go网络编程开发，说到网络编程开发必然离不开网络协议，大家最熟知的莫过于TCP/IP体系，实际上开发中，大家接触的最多的还是HTTP协议。在理论上，OSI模型把网络分成7层，但实际应用中是分为4层，从下到上分别是物理接口层、网络层、传输层、应用层。&lt;/p&gt;
&lt;p&gt;每一层做不同的事情，分工明确，同时便于扩展，比如物理层指的就是网卡，又被称为调制解调器，它负责把电信号和数字信号之间做转换，这一块其实很多人不理解，也是非常难理解的地方，下面咱就聊一聊。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="https://wangbjun.site/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.site/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Go定时器应用</title>
    <link href="https://wangbjun.site/2020/coding/golang/ticker.html"/>
    <id>https://wangbjun.site/2020/coding/golang/ticker.html</id>
    <published>2020-06-18T15:00:00.000Z</published>
    <updated>2020-06-18T16:03:51.778Z</updated>
    
    <content type="html"><![CDATA[<p>很多人都用过Linux的定时任务，举个例子，我们有一个任务需要每个1分钟运行一次，如果使用Linux的crontab可以用 <code>* * * * *</code>表示。</p><p>在Go里面自带类似的功能实现，我们称之为定时器，非常简单易用，举个例子，这里使用time包里面的ticker实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Println(<span class="string">"等待10秒钟。。。"</span>)</span><br><span class="line"></span><br><span class="line">    ticker := time.NewTicker(<span class="number">10</span> * time.Second)</span><br><span class="line">    &lt;-ticker.C</span><br><span class="line"></span><br><span class="line">    log.Println(<span class="string">"执行"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020&#x2F;06&#x2F;18 21:53:31 等待10秒钟。。。</span><br><span class="line">2020&#x2F;06&#x2F;18 21:53:41 执行</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="1-for…select"><a href="#1-for…select" class="headerlink" title="1.for…select"></a>1.for…select</h2><p>假设我们想实现一种定时执行的效果，只要把它放到一个for循环里面即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   ticker := time.NewTicker(<span class="number">10</span> * time.Second)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        &lt;-ticker.C</span><br><span class="line">        log.Println(<span class="string">"执行"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们通常更常见的一种写法是配合select使用，其实如果只是一个定时任务，这2者没什么差异。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ticker := time.NewTicker(<span class="number">10</span> * time.Second)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">            log.Println(<span class="string">"执行"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-注意的坑"><a href="#2-注意的坑" class="headerlink" title="2.注意的坑"></a>2.注意的坑</h2><p>很多人以为这个定时任务和Linux的一样，是<code>定时</code>执行的,举个例子，我们有2个定时器，一个10s执行一次，1个20s执行一次，一般是这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t1 := time.NewTicker(<span class="number">10</span> * time.Second)</span><br><span class="line">    t2 := time.NewTicker(<span class="number">20</span> * time.Second)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-t1.C:</span><br><span class="line">            log.Println(<span class="string">"执行10s"</span>)</span><br><span class="line">            <span class="comment">// time.Sleep(15*time.Second)</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-t2.C:</span><br><span class="line">            log.Println(<span class="string">"执行20s"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，假如第一个10s的任务执行耗时超过了20s，那么多第二个定时任务就无法<code>按时</code>执行了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2020&#x2F;06&#x2F;18 22:23:25 执行10s</span><br><span class="line">2020&#x2F;06&#x2F;18 22:23:50 执行20s</span><br><span class="line">2020&#x2F;06&#x2F;18 22:23:50 执行10s</span><br><span class="line">2020&#x2F;06&#x2F;18 22:24:15 执行10s</span><br><span class="line">2020&#x2F;06&#x2F;18 22:24:40 执行20s</span><br><span class="line">2020&#x2F;06&#x2F;18 22:24:40 执行10s</span><br></pre></td></tr></table></figure><p>究其原因，是因为select在同一时间只能选择一个分支执行，当你前面那个分支任务“阻塞“住了，就无法抽出空来执行第二个任务，即使已经过了定时器设定的时间。</p><p>熟悉Linux的crontab定时任务的人知道，它不会管你上一个任务有没有执行完成，会“非常准时”的执行。</p><p>在上面这个例子，由于select是随机选择一个分支执行，所以你会发现这2个任务并不是交互执行，比如上面的例子里面，10s执行了2次。</p><p>所以严格依赖定时的任务得考虑任务本身执行耗费的时间，不然可能会得到你预想之外的结果，其实有一个非常简单的方法可以解决这个问题，我们只要把需要执行的任务用go启动一个协程去执行即可。</p><h2 id="3-timer延迟执行"><a href="#3-timer延迟执行" class="headerlink" title="3.timer延迟执行"></a>3.timer延迟执行</h2><p>细心的人注意了，time包里面还有一个timer，它和这个ticker有啥区别呢？tick原指机械钟表指针转动的声音，它表示的意思是每隔固定的时间段做一件事。</p><p>而timer则是“定时炸弹”的定时，只不过它只执行一次（定时炸弹炸完就没），某些时候是和之前的ticker一样，比如延迟执行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Println(<span class="string">"等待10秒钟。。。"</span>)</span><br><span class="line"></span><br><span class="line">    timer := time.NewTimer(<span class="number">10</span> * time.Second)</span><br><span class="line">    &lt;-timer.C</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">"执行"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有人说，这和我写个<code>time.Sleep(10 * time.Second)</code>有啥区别？这个。。。有待研究！</p><p>这个包里面还有2个等价的简化写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Println(<span class="string">"等待10秒钟。。。"</span>)</span><br><span class="line"></span><br><span class="line">    &lt;-time.After(<span class="number">10</span>*time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//time.AfterFunc(10*time.Second, func() &#123;</span></span><br><span class="line">    <span class="comment">//   log.Printf("执行")</span></span><br><span class="line">    <span class="comment">//&#125;)</span></span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">"执行"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那这个timer存在的意义到底在哪呢？</p><p>首先，这个timer是一次性的，所以没法向之前那样放到for循环里面来实现定时执行的功能。</p><p>其次，除了可以作为一个一次性延迟执行功能之外，还可以作为一个实现超时的功能，举个例子，从一个管道中等待获取数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    t := time.NewTimer(<span class="number">5</span> * time.Second)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">        t.Stop()</span><br><span class="line">        <span class="comment">//do something....</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">        fmt.Println(<span class="string">"5s已经过去，任务超时"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于Go定时器的介绍就说这么多，下次再说说其内部实现原理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多人都用过Linux的定时任务，举个例子，我们有一个任务需要每个1分钟运行一次，如果使用Linux的crontab可以用 &lt;code&gt;* * * * *&lt;/code&gt;表示。&lt;/p&gt;
&lt;p&gt;在Go里面自带类似的功能实现，我们称之为定时器，非常简单易用，举个例子，这里使用time包里面的ticker实现：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;log&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;time&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    log.Println(&lt;span class=&quot;string&quot;&gt;&quot;等待10秒钟。。。&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ticker := time.NewTicker(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; * time.Second)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;-ticker.C&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    log.Println(&lt;span class=&quot;string&quot;&gt;&quot;执行&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;2020&amp;#x2F;06&amp;#x2F;18 21:53:31 等待10秒钟。。。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2020&amp;#x2F;06&amp;#x2F;18 21:53:41 执行&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="https://wangbjun.site/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.site/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang限速算法和应用</title>
    <link href="https://wangbjun.site/2020/coding/golang/limiter.html"/>
    <id>https://wangbjun.site/2020/coding/golang/limiter.html</id>
    <published>2020-06-15T14:00:00.000Z</published>
    <updated>2020-06-19T14:19:02.624Z</updated>
    
    <content type="html"><![CDATA[<p>今天来说说限速算法，其实这个倒不是什么神秘的事情，本文主要做一个总结，并且从Golang这么语言的角度做一个实践。</p><p>假设作为一个完全不懂算法的人，让你去实现一个限速功能（1秒内最多100次），你可能会想到的最简单方式就是记录一个开始时间，然后开始计数，当计数达到100之后限制调用，等待时间间隔达到1秒的时候重置计数器，然后重新计数，如此往复。</p><p>这种算法也是日常生活中应用广泛，比如说坐地铁，在北京，很多地铁站在早晚高峰时期都会限流，方法非常简单，地铁站门口有安检员，每过一段时间放几个人进去，虽然安检员也不会掐着表计时，但是基本上是这个规律。</p><p>这种方式被称为<code>计数器算法</code>，有些文章也称之为<code>固定时间窗口计数法</code>，因为与之对应的还有一个方法叫作<code>滑动时间窗口计数法</code>。</p><a id="more"></a><h2 id="1-计数器法"><a href="#1-计数器法" class="headerlink" title="1.计数器法"></a>1.计数器法</h2><p>这种算法实现起来并不难，主要要点在于重置计数器和开始时间，我这里用Go，以一个方法的调用为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> sTime = time.Now()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> time.Now().Sub(sTime).Seconds() &gt; <span class="number">1</span>  &#123;</span><br><span class="line">            count = <span class="number">1</span></span><br><span class="line">            sTime = time.Now()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> count &gt; <span class="number">100</span>  &#123;</span><br><span class="line">            time.Sleep(time.Millisecond * <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        doSomething(count)</span><br><span class="line">        count++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"do something #%d\n"</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种算法最大问题在于临界点问题，比如说在上面这个例子里面，假设我们在前面1秒钟中最后999ms的时候打印了100个，又在第二个1秒的前1ms内又打印了100个，那么总得算起来，其在2ms内就打印了200个，超出了我们限制。</p><p>另外，还有一个问题就是1ms就会打印完100个，后面999ms都会在等待中，假设在实际应用中，比如说接口限流，假如说某个客户端请求速度比较快，那么就会瞬间消耗所有配额，导致其它用户无法正常访问，这是不可接受的。</p><p>但是这不意味着这个算法没用，很多时候我们的需求就是很简单，只需要控制并发数，如果不考虑上述情况的话是完全可用的。</p><h2 id="2-滑动窗口计数法"><a href="#2-滑动窗口计数法" class="headerlink" title="2.滑动窗口计数法"></a>2.滑动窗口计数法</h2><p>这个算法实际上是前面这种算法的改进版，第一种方法的问题在于统计的时间太粗了，不够精细，假设我们把1s细分为1000ms，那么也就是10ms一个请求，这时候我们只需要统计最近100个10ms段内的请求数就可以了，而不是一个固定的开始时间。这个算法有一个非常知名的应用就是在TCP网络中流量控制中用于计算窗口大小。</p><img src="/images/2020-06-16_22-52.png" /><p>滑动窗口的核心思想是把时间段切割成更小的区块，每个区块单独计数，最后统计这个时间段内各个小区块的总计数，其重点在于这个时间段并不是一个固定的时间段，而是在动态变化。</p><p>为了便于演示，这里假设限流条件为10s内最多500个请求，我们以1s为区块划分为10个区块，每个区块单独计数，这个算法实现的核心在于维持一个队列，这里使用了Go自带的list实现，参考代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"container/list"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> part <span class="keyword">struct</span> &#123;</span><br><span class="line">    Time <span class="keyword">int64</span></span><br><span class="line">    Count <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> listPart = list.New()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> nowSecond = time.Now().Unix()</span><br><span class="line">        <span class="keyword">if</span> listPart.Len() == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">                listPart.PushBack(part&#123;</span><br><span class="line">                    Time: nowSecond+<span class="keyword">int64</span>(i),</span><br><span class="line">                    Count: <span class="number">0</span>,</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印方便调试</span></span><br><span class="line">        <span class="keyword">for</span> e := listPart.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"e = %v\n"</span>, e.Value)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> listSum(listPart) &gt;= <span class="number">500</span> &#123;</span><br><span class="line">            <span class="comment">// 右移动队列元素</span></span><br><span class="line">            <span class="keyword">if</span> listPart.Back().Value.(part).Time == nowSecond&#123;</span><br><span class="line">                listPart.Remove(listPart.Front())</span><br><span class="line">                listPart.PushBack(part&#123;</span><br><span class="line">                    Time: nowSecond+<span class="number">1</span>,</span><br><span class="line">                    Count: <span class="number">0</span>,</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">"reach limit"</span>)</span><br><span class="line">                time.Sleep(time.Second)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        time.Sleep(time.Millisecond*<span class="number">10</span>)</span><br><span class="line">        doSomething()</span><br><span class="line"></span><br><span class="line">        element := listGet(listPart, nowSecond)</span><br><span class="line">        count := element.Value.(part).Count</span><br><span class="line">        element.Value = part&#123;</span><br><span class="line">            Time: nowSecond,</span><br><span class="line">            Count: count+<span class="number">1</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"do something \n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列求和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listSum</span><span class="params">(l *list.List)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> e := l.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">        sum += e.Value.(part).Count</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找队列元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listGet</span><span class="params">(l *list.List, t <span class="keyword">int64</span>)</span> *<span class="title">list</span>.<span class="title">Element</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> e := l.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">        <span class="keyword">if</span> e.Value.(part).Time == t &#123;</span><br><span class="line">            <span class="keyword">return</span> e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际运行中，整个队列元素保持不变，一直是10个，但是其时间段一直在变，比如下面这个情况下，前面所有的时间区块计数之和已经达到500，开始限流。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">e &#x3D; &#123;1592323440 53&#125; &#x2F;&#x2F;即将被移除</span><br><span class="line">------------------------------------</span><br><span class="line">e &#x3D; &#123;1592323441 98&#125;</span><br><span class="line">e &#x3D; &#123;1592323442 98&#125;</span><br><span class="line">e &#x3D; &#123;1592323443 98&#125;</span><br><span class="line">e &#x3D; &#123;1592323444 98&#125;</span><br><span class="line">e &#x3D; &#123;1592323445 55&#125;</span><br><span class="line">e &#x3D; &#123;1592323446 0&#125;</span><br><span class="line">e &#x3D; &#123;1592323447 0&#125;</span><br><span class="line">e &#x3D; &#123;1592323448 0&#125;</span><br><span class="line">e &#x3D; &#123;1592323449 0&#125;</span><br><span class="line">-------------------------------------</span><br><span class="line">e &#x3D; &#123;1592323450 0&#125; &#x2F;&#x2F;即将新入列</span><br><span class="line">-------------------------------------</span><br></pre></td></tr></table></figure><p>随着时间的推进，新加入一个区块，就有新的流量可用了，如此往复不间断，实现了动态时间窗口！</p><p>这种实现方法区块划分的越多越精确,但是到底该设置多少个格子才足够精确呢？而且这种方式依然没有解决突发流量瞬间占用的情况，所以又延伸出了2种流行的平滑限流算法分别是<code>漏桶算法</code>和<code>令牌桶算法</code>。</p><h2 id="3-漏桶算法"><a href="#3-漏桶算法" class="headerlink" title="3.漏桶算法"></a>3.漏桶算法</h2><p>所谓漏桶算法就是有一个固定大小的桶，进水速率不确定，但是出水速率固定，这里所谓的进水指的就是请求，而出水则是处理请求。<br>漏桶算法有以下特点：</p><ul><li>漏桶具有固定容量，出水速率是固定常量（流出请求）</li><li>如果桶是空的，则不需流出水滴</li><li>可以以任意速率流入水滴到漏桶（流入请求）</li><li>如果流入水滴超出了桶的容量，则流入的水滴溢出（新请求被拒绝）</li></ul><p>漏桶算法实现的重点在于有一个桶的容量、速率、当前水量、一个动态的时间戳，我们通过每次计算当前时间和上次时间的间隔*速率得到一个漏去的水量，把当前水量减去这个值就是当前剩余水量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> capacity <span class="keyword">int64</span> = <span class="number">100</span> <span class="comment">// 桶容量</span></span><br><span class="line">    <span class="keyword">var</span> rate = <span class="number">10</span>            <span class="comment">// 出水速度，每秒10个</span></span><br><span class="line">    <span class="keyword">var</span> water <span class="keyword">int64</span> = <span class="number">0</span>      <span class="comment">// 当前水量</span></span><br><span class="line">    <span class="keyword">var</span> lastTime = time.Now().Unix()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        now := time.Now().Unix()</span><br><span class="line">        di := water - (now-lastTime)*<span class="keyword">int64</span>(rate) <span class="comment">//计算过去的时间内产生的水量</span></span><br><span class="line">        <span class="keyword">if</span> di &gt; <span class="number">0</span> &#123;</span><br><span class="line">            water = di</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            water = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        lastTime = now</span><br><span class="line">        <span class="keyword">if</span> water &lt; capacity &#123;</span><br><span class="line">            water++</span><br><span class="line">            doSomething()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"reach limit"</span>)</span><br><span class="line">            time.Sleep(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"do something \n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法依然有一个缺点：就是无法应对突发流量，所以下面有了令牌桶算法。</p><h2 id="4-令牌桶算法"><a href="#4-令牌桶算法" class="headerlink" title="4.令牌桶算法"></a>4.令牌桶算法</h2><p>令牌桶算法和漏桶算法的方向刚好是相反的，我们有一个固定的桶，桶里存放着令牌（token）。一开始桶是空的，系统按固定的时间（rate）往桶里添加令牌，直到桶里的令牌数满，多余的请求会被丢弃。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> rate = <span class="number">10</span>        <span class="comment">// 令牌生成速度，每秒10个</span></span><br><span class="line">    <span class="keyword">var</span> tokens <span class="keyword">int64</span> = <span class="number">0</span> <span class="comment">// 当前令牌数量</span></span><br><span class="line">    <span class="keyword">var</span> timeStamp = time.Now().Unix()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        now := time.Now().Unix()</span><br><span class="line">        di := tokens + (now-timeStamp)*<span class="keyword">int64</span>(rate) <span class="comment">//计算过去的时间段产生的令牌数</span></span><br><span class="line">        <span class="keyword">if</span> di &gt; <span class="number">0</span> &#123;</span><br><span class="line">            tokens = di</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tokens = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        timeStamp = now</span><br><span class="line">        <span class="keyword">if</span> tokens &lt; <span class="number">1</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"reach limit"</span>)</span><br><span class="line">            time.Sleep(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tokens--</span><br><span class="line">            doSomething()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"do something \n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说到这个算法，在Go里面我们还可以使用chanel结合生产者消费者模式轻松实现，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int64</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 开启协程，每隔100ms往管道里面放一个数，也就是实现每秒10s的限速效果</span></span><br><span class="line">        <span class="keyword">var</span> ticker = time.NewTicker(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">                ch &lt;- <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        &lt;-ch    <span class="comment">//利用管道的阻塞特性</span></span><br><span class="line">        doSomething()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">" %s :do something \n"</span>, time.Now().Format(<span class="string">"2006-01-02 15:04:05"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Go-WaitGroup-限速"><a href="#5-Go-WaitGroup-限速" class="headerlink" title="5.Go WaitGroup 限速"></a>5.Go WaitGroup 限速</h2><p>在日常开发中，很多时候我们对限速要求并不是十分精准，比如说我们要用协程并发调一个接口100次，一个接口耗时3s，但是这个接口的并发能力不强，如果不做限制很可能把接口打垮，假设要求qps低于10，也就说最多每秒10个请求，利用Go的协程可以轻松实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg = sync.WaitGroup&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> doSomething(&amp;wg)</span><br><span class="line">        count++</span><br><span class="line">        <span class="keyword">if</span> count &gt; <span class="number">10</span> &#123;</span><br><span class="line">            wg.Wait()</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">    fmt.Printf(<span class="string">" %s :do something \n"</span>, time.Now().Format(<span class="string">"2006-01-02 15:04:05"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-Go“标准库”的限速包"><a href="#6-Go“标准库”的限速包" class="headerlink" title="6.Go“标准库”的限速包"></a>6.Go“标准库”的限速包</h2><p>说是Go标准库，其实严格来说并不是，这是<code>golang.org/x</code>下面的包，一般被认为是Go的一些正在开发或者验证中的包，我觉得有点类似开发版的味道，这些包需要手动安装，并不是直接可以用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">These packages are part of the Go Project but outside the main Go tree. They are developed under looser compatibility requirements than the Go core.</span><br></pre></td></tr></table></figure><p>这里面的包还是挺多的，有些非常实用，但是在国内用有个小问题，直接go get拉不下来，需要设置一下goproxy，具体就不细说了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get golang.org/x/time/rate</span><br></pre></td></tr></table></figure><p>这个包使用的限速算法就是令牌桶算法，示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"golang.org/x/time/rate"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    limiter := rate.NewLimiter(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%s: allow\n"</span>, time.Now().Format(<span class="string">"2006-01-02 15:04:05"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>NewLimiter</strong>有2个参数，第一个是rate速率，单位时间内的产生的令牌数，第二个则是桶的容量，然后使用<strong>Allow()</strong>，这个函数的意思如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allow is shorthand for AllowN(time.Now(), 1).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span> <span class="title">Allow</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lim.AllowN(time.Now(), <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AllowN reports whether n events may happen at time now.</span></span><br><span class="line"><span class="comment">// Use this method if you intend to drop / skip events that exceed the rate limit.</span></span><br><span class="line"><span class="comment">// Otherwise use Reserve or Wait.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span> <span class="title">AllowN</span><span class="params">(now time.Time, n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lim.reserveN(now, n, <span class="number">0</span>).ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>啥意思呢？截止到某一时刻，目前桶中数目是否至少为n个，满足则返回 true，同时从桶中消费n个token，运行结果是第一秒打印产生15个记录，然后是每秒5个记录，有人说为什么第一秒15个，那是因为桶里面初始化的时候有10个，也就是第二个参数的作用。</p><p>最后说几句，在实际应用中，对于Web应用的限速一般都在网关处理，比如nginx就有限速模块可以使用，包括按连接数限速(ngx_http_limit_conn_module)、按请求速率限速(ngx_http_limit_req_module)，基本上可以满足需求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来说说限速算法，其实这个倒不是什么神秘的事情，本文主要做一个总结，并且从Golang这么语言的角度做一个实践。&lt;/p&gt;
&lt;p&gt;假设作为一个完全不懂算法的人，让你去实现一个限速功能（1秒内最多100次），你可能会想到的最简单方式就是记录一个开始时间，然后开始计数，当计数达到100之后限制调用，等待时间间隔达到1秒的时候重置计数器，然后重新计数，如此往复。&lt;/p&gt;
&lt;p&gt;这种算法也是日常生活中应用广泛，比如说坐地铁，在北京，很多地铁站在早晚高峰时期都会限流，方法非常简单，地铁站门口有安检员，每过一段时间放几个人进去，虽然安检员也不会掐着表计时，但是基本上是这个规律。&lt;/p&gt;
&lt;p&gt;这种方式被称为&lt;code&gt;计数器算法&lt;/code&gt;，有些文章也称之为&lt;code&gt;固定时间窗口计数法&lt;/code&gt;，因为与之对应的还有一个方法叫作&lt;code&gt;滑动时间窗口计数法&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="https://wangbjun.site/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.site/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>再谈阿里外包</title>
    <link href="https://wangbjun.site/2020/life/ali-waibao.html"/>
    <id>https://wangbjun.site/2020/life/ali-waibao.html</id>
    <published>2020-06-07T15:08:19.000Z</published>
    <updated>2020-06-08T14:03:13.748Z</updated>
    
    <content type="html"><![CDATA[<p>之前有写一篇文章叫作<a href="https://wangbjun.site/2020/life/2019-4.html">《谈一谈阿里外包工作》</a> ，至今3个月已经过去了，今天抽空再写点东西补充一下，希望对有些人有用。</p><h2 id="1-疫情影响"><a href="#1-疫情影响" class="headerlink" title="1.疫情影响"></a>1.疫情影响</h2><p>据我了解，很多在年前没有找工作的同事，基本上都空了3-4个月，因为北京这边大概到了4-5月份招聘才多了起来，而且也很奇怪，这时候找工作好像更简单，很多同事都同时拿到了好几个offer，其中也不乏一些大中型互联网公司。</p><a id="more"></a><p>不知道是不是因为疫情影响跳槽的人少了，所以竞争压力小，反而更好找工作了，不管咋样，基本上都找到工作了，并没有出现失业情况。</p><p>至于我，在此期间也并没有另找工作的打算，所以也一直在阿里外包工作。</p><h2 id="2-外包坑不坑？"><a href="#2-外包坑不坑？" class="headerlink" title="2.外包坑不坑？"></a>2.外包坑不坑？</h2><p>我估计很多人都比较关心这个问题，从我个人经历来看，截止目前公司并没有坑我，至少合同是透明的，工资也按时发放。当然很多人认为的坑是指待遇差，这点确实没得洗，外包一般都是12薪，也谈不上什么奖金，更没有什么补助，社保公积金往往也最低水平，所以你们懂的，只能在base上面多要点。</p><p>另外，大家说的坑可能是指工作没前景，没有成长，这点确实也没得洗，外包确实很难接触核心业务，而且有一些阿里的内部系统外包没法申请权限，时间越久你就会发现很多地方受限，无法发挥自己的能力。</p><p>其实正式员工也很难，每天都要想着KPI、想着怎么出绩效。在一般公司，开发流程是这样的：产品给你提需求，你负责开发，开发完了扔给测试，然后改bug上线就行了。</p><p>但是在阿里，至少在我们部门，很多需求并不是产品提出来的，甚至没有产品，你得自己去想，也就是自己去寻找增长点。因为大厂很多能干的事情都有人去干，很多系统也很完善了，你如果等着需求找你，那往往不是什么好需求。</p><p>如果你只是待在那里，领导让你干啥你就干啥，我估计你的述职报告会很难写，还可能会被扣上一个积极性主动性不强的帽子…最后落个3.25。</p><p>但是对于外包来说简单很多，基本上就是主管或者其它正式员工同事给我们分配一些活，我们的工作基本上是类似于王者荣耀里面的辅助，比如有些数据处理的活外包干，有些数据需要页面展示外包干，外包不用carry，甚至有些牛逼的c都不需要辅助。</p><p>我认识一个在腾讯做外包的PHP开发，据他说，基本上也就是写一些游戏活动，很多库都是封装好的，基本上只要学着用就行，你说能有多大技术含量，显而易见，但是这种游戏活动特别多，经常变，所以得有人去做。</p><h2 id="3-外包加班吗？"><a href="#3-外包加班吗？" class="headerlink" title="3.外包加班吗？"></a>3.外包加班吗？</h2><p>从阿里的外包大本营国门大厦看，下午6点半的时候很多人就开始走了，基本上到7点钟左右就走的差不多了，但是如果你晚点走，会发现晚上8-9点钟的时候依然有人，只是很少。</p><p>我个人来说，如果工作都完成了或者不紧急的情况下，一般最晚7点钟走（早上最迟10点到），我之所以不加班的一个原因是确实没必要，另外国门大厦这个破地方并没有什么吃饭的地方，不像是阿里望京那边有很多食堂，所以这边很多人都是点外卖。</p><p>至于正式员工，虽然不如外界所说的996，但是995还是稳的，他们一般6点钟去吃饭，7点钟回办公室，然后加班到9点撤退，这是阿里常态，至于周末，除非特殊情况，其实也不加班，看部门看项目吧，不能一概而论。</p><p>如果你不在国门大厦，而是在望京办公，并且是和正式员工一起，好处就是和正式员工沟通交流方便，甚至还可以学习一下，享受阿里食堂的丰富食物，但坏处就是可能要和他们一起加班了，毕竟他们一般都干到9点，你跑那么早也不好意思吧！</p><p>所以总结就是，外包不加班，加班的外包不能干。</p><h2 id="4-工作环境"><a href="#4-工作环境" class="headerlink" title="4.工作环境"></a>4.工作环境</h2><p>国门大厦总共有4层，其中2-4这3层都有阿里的办公室，但是也有其它公司，每层1个卫生间，一层大概200-300个工位，所以卫生间排队是常态，经常得跑好几趟，从4楼找到2楼都没坑。</p><p>办公室是开放式办公，有不同公司的人员，也有不同项目的人员，所以环境比较嘈杂，打电话的、视频会议的、讨论问题的都有，但时间长也就习惯了。</p><p>对于我个人来说，去国门大厦只是占个工位，并没有其它意义，因为和我沟通工作需求的人不是在望京就是在杭州，都不在国门大厦，日常交流全靠视频会议，基本上算是远程办公吧，去不去办公室都一样。</p><h2 id="5-一点建议"><a href="#5-一点建议" class="headerlink" title="5.一点建议"></a>5.一点建议</h2><p>如果你暂时没有更好的offer，而外包给到的base还行，可以尝试一下，毕竟外包不加班，虽然工资不高，但是落个轻松。如果你奔着外包转正式员工而来，请慎重，几率不大，而且看主管，如果你能力确实非常优秀，自身硬件条件也好，那直接去社招面，何必走这个歪路子。</p><p>其次，不建议长期从事外包岗位工作，从我目前的工作内容来看，基本无挑战、无压力，Go的代码没写多少，倒是写了不少react，阿里前端都是react为主，再加上antd组件，确实挺香。虽然不确定以后会不会分配其它更有技术含量和成就感的活，就目前来说，基本上也就这样了，在此我也决定半年后会再更新一篇文章，算是一个交待，虽然这只代表我个人遇到的情况。</p><p>最后，对于国内很多互联网大公司，在经济形势差的时候反而会多招人，毕竟有党组织入驻，大公司更应该带头解决就业，所以外包岗位可能更多，有些时候这个岗位并不是必须的，但是必须有人，只是一个指标而已。所以，外包并没有那么差劲，至少它解决了很多人就业问题，何乐不为呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前有写一篇文章叫作&lt;a href=&quot;https://wangbjun.site/2020/life/2019-4.html&quot;&gt;《谈一谈阿里外包工作》&lt;/a&gt; ，至今3个月已经过去了，今天抽空再写点东西补充一下，希望对有些人有用。&lt;/p&gt;
&lt;h2 id=&quot;1-疫情影响&quot;&gt;&lt;a href=&quot;#1-疫情影响&quot; class=&quot;headerlink&quot; title=&quot;1.疫情影响&quot;&gt;&lt;/a&gt;1.疫情影响&lt;/h2&gt;&lt;p&gt;据我了解，很多在年前没有找工作的同事，基本上都空了3-4个月，因为北京这边大概到了4-5月份招聘才多了起来，而且也很奇怪，这时候找工作好像更简单，很多同事都同时拿到了好几个offer，其中也不乏一些大中型互联网公司。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Life" scheme="https://wangbjun.site/categories/Life/"/>
    
    
      <category term="Life" scheme="https://wangbjun.site/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>Golang的HttpServer解析</title>
    <link href="https://wangbjun.site/2020/coding/golang/http-server.html"/>
    <id>https://wangbjun.site/2020/coding/golang/http-server.html</id>
    <published>2020-06-07T14:00:00.000Z</published>
    <updated>2020-06-07T14:03:32.839Z</updated>
    
    <content type="html"><![CDATA[<p>Golang之所以非常适合用于网络编程的原因之一就是其自带网络库可以非常简单快速的建立一个基于http或者tcp的服务应用，以http服务为例，只需几行代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        _, _ = writer.Write([]<span class="keyword">byte</span>(<span class="string">"Hello"</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">    err := http.ListenAndServe(<span class="string">":8888"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这几行代码就启动了一个http服务，运行在8888端口，虽然说非常简陋，也不区分GET或者POST，但是其性能缺十分高效，主要是得益于其底层使用了协程，对每一个请求都会分配一个协程去处理，并发能力强。</p><a id="more"></a><h2 id="1-ISO网络模型"><a href="#1-ISO网络模型" class="headerlink" title="1.ISO网络模型"></a>1.ISO网络模型</h2><p>说到网络，不得不说一下这个模型，http本质上是一个基于tcp协议的应用层协议，而且http是超文本传输协议，注意这里的文本是指其通信协议是文本形式（具体表现就是请求头和响应头），其传输的内容并不一定是文本，可以是任何内容，图片等二进制内容都可以。</p><img src="https://wangbjun.site/images/old/5f6e3e27ly1g371bhib22j20da0dn0t2.jpg" /><p>说到tcp就不得不说下socket网络编程，上面这张图基本上描述了tcp网络通信的一个流程，这和http有什么关系呢？</p><p>实际上，这种图里面<code>处理请求</code>这部分则是http服务应该做的东西，tcp只负责传输控制，至于内容，其协议可能是http，也可能是ftp，甚至有可能是自定义的协议。</p><p>网上借张http协议报文的图看一下：</p><img src="/images/2020-06-07_16-30.png" /><p>实际上，协议内容非常复杂，对于每一个字段代表的意思和应该出现的位置都有规定，有人可能说，我拿chrome F12打开控制台看到和这个不一样啊，那是因为浏览器把请求解析了一行行显示出来方便咱调试而已。</p><p>如果你理解了这2张图，你应该理解了一个http请求是怎么发起，怎么响应的，但是实际应用中，Go又是怎么做到解析协议并且响应结果的呢？</p><h2 id="2-DefaultServeMux"><a href="#2-DefaultServeMux" class="headerlink" title="2.DefaultServeMux"></a>2.DefaultServeMux</h2><p>让我们点开源码，看看这几行代码到底干了啥，首先看一下个 <code>HandlFunc()</code>，Go里面关于http server的代码都在server.go这个文件里面，总共3000多行，有点多，这里摘取部分。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu    sync.RWMutex</span><br><span class="line">    m     <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry</span><br><span class="line">    es    []muxEntry <span class="comment">// slice of entries sorted from longest to shortest.</span></span><br><span class="line">    hosts <span class="keyword">bool</span>       <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">    h       Handler</span><br><span class="line">    pattern <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// DefaultServeMux is the default ServeMux used by Serve.</span></span><br><span class="line"><span class="keyword">var</span> DefaultServeMux = &amp;defaultServeMux</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultServeMux ServeMux</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleFunc registers the handler function for the given pattern</span></span><br><span class="line"><span class="comment">// in the DefaultServeMux.</span></span><br><span class="line"><span class="comment">// The documentation for ServeMux explains how patterns are matched.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleFunc registers the handler function for the given pattern.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的核心是<code>ServeMux</code>这个结构体，按照注释的介绍，这个是一个http server的多路复用分发器，顾名思义，它是用来处理分发请求的，下面是它实现的一些方法：</p><img src="/images/2020-06-07_19-01.png" /><p>这个结构体有4个成员属性，其中mu是一个读写互斥锁；m是一个map，其key是一个string（实际上也是路由），value是一个muxEntry；这个muxEntry则是代表了handler和pattern，其中pattern就是咱说的路由，又叫请求path。</p><p>HandleFunc最终调用了Handle方法，其主要目的是把路由和handler函数做一个映射关系，简单说就是注册路由：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle registers the handler for the given pattern.</span></span><br><span class="line"><span class="comment">// If a handler already exists for pattern, Handle panics.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123;</span><br><span class="line">    mux.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mux.mu.Unlock()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> pattern == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: invalid pattern"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _, exist := mux.m[pattern]; exist &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: multiple registrations for "</span> + pattern)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> mux.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        mux.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry)</span><br><span class="line">    &#125;</span><br><span class="line">    e := muxEntry&#123;h: handler, pattern: pattern&#125;</span><br><span class="line">    mux.m[pattern] = e</span><br><span class="line">    <span class="keyword">if</span> pattern[<span class="built_in">len</span>(pattern)<span class="number">-1</span>] == <span class="string">'/'</span> &#123;</span><br><span class="line">        mux.es = appendSorted(mux.es, e)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">        mux.hosts = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意一点的是<code>ServeMux</code>里面包含一个es，它保存了一个有序的entry，是根据pattern从长到短排序，不知道有啥用。。。</p><p>总结，这里面的<code>DefaultServeMux</code>就是库里面自己已经初始化好的一个结构体，我们可以直接用，使用它的handle方法就可以注册路由，这时有人可能会问，那咱自己动手行不行呢？当然可以</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myServer = <span class="built_in">new</span>(http.ServeMux)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myServer.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        _, _ = writer.Write([]<span class="keyword">byte</span>(<span class="string">"Hello"</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">    err := http.ListenAndServe(<span class="string">":8888"</span>, myServer)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种写法就是自己new一个ServeMux，如果我们点开<code>ListenAndServe</code>这个方法，可以看到注释非常明确的写到如果第二个参数为nil则会默认使用<code>DefaultServeMux</code>，这也就解释了为什么第一种写法这个参数是nil。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListenAndServe listens on the TCP network address addr and then calls</span></span><br><span class="line"><span class="comment">// Serve with handler to handle requests on incoming connections.</span></span><br><span class="line"><span class="comment">// Accepted connections are configured to enable TCP keep-alives.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The handler is typically nil, in which case the DefaultServeMux is used.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ListenAndServe always returns a non-nil error.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">    <span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-ListenAndServe"><a href="#2-ListenAndServe" class="headerlink" title="2.ListenAndServe"></a>2.ListenAndServe</h2><p>前面只是一些准备工作，真正的逻辑是在这个方法里面，首先，这个方法接受2个参数，一个是监听的地址，一个<code>Handler</code>，handler是一个interface，它只有一个方法需要实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Handler responds to an HTTP request.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ServeHTTP should write reply headers and data to the ResponseWriter</span></span><br><span class="line"><span class="comment">// and then return. Returning signals that the request is finished; it</span></span><br><span class="line"><span class="comment">// is not valid to use the ResponseWriter or read from the</span></span><br><span class="line"><span class="comment">// Request.Body after or concurrently with the completion of the</span></span><br><span class="line"><span class="comment">// ServeHTTP call.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Depending on the HTTP client software, HTTP protocol version, and</span></span><br><span class="line"><span class="comment">// any intermediaries between the client and the Go server, it may not</span></span><br><span class="line"><span class="comment">// be possible to read from the Request.Body after writing to the</span></span><br><span class="line"><span class="comment">// ResponseWriter. Cautious handlers should read the Request.Body</span></span><br><span class="line"><span class="comment">// first, and then reply.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Except for reading the body, handlers should not modify the</span></span><br><span class="line"><span class="comment">// provided Request.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If ServeHTTP panics, the server (the caller of ServeHTTP) assumes</span></span><br><span class="line"><span class="comment">// that the effect of the panic was isolated to the active request.</span></span><br><span class="line"><span class="comment">// It recovers the panic, logs a stack trace to the server error log,</span></span><br><span class="line"><span class="comment">// and either closes the network connection or sends an HTTP/2</span></span><br><span class="line"><span class="comment">// RST_STREAM, depending on the HTTP protocol. To abort a handler so</span></span><br><span class="line"><span class="comment">// the client sees an interrupted response but the server doesn't log</span></span><br><span class="line"><span class="comment">// an error, panic with the value ErrAbortHandler.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(ResponseWriter, *Request) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你留意了你会发现，之前那个<code>ServeMux</code>也是实现了这个方法，所以我们可以这么用。</p><p>哎，这时候你有一个大胆的想法，那如果我自己定义一个结构体去实现这个方法，是不是连<code>ServeMux</code>都不用new了？你别说还真是这样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myServer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myServer)</span> <span class="title">ServeHTTP</span><span class="params">(writer http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    _, _ = writer.Write([]<span class="keyword">byte</span>(<span class="string">"Hello"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := http.ListenAndServe(<span class="string">":8888"</span>, myServer&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是你这么写，就连基本的路由功能都没了。。。因为<code>ServeMux</code>本质上就是带了一个路由功能而已，相当于官方库实现的一个路由，虽然不够强大，但是基本够用，很多第三方框架甚至会自己实现更强大的路由功能。</p><p>继续看这个<code>ListenAndServe</code>源码，可以看到它初始化了一个<code>Server</code>，把地址和Handler传进去了，这个Server是最重要的一个结构体了，它里面的成员和方法特别多，这里就不列出了，直接看调用的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ListenAndServe</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> srv.shuttingDown() &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrServerClosed</span><br><span class="line">    &#125;</span><br><span class="line">    addr := srv.Addr</span><br><span class="line">    <span class="keyword">if</span> addr == <span class="string">""</span> &#123;</span><br><span class="line">        addr = <span class="string">":http"</span></span><br><span class="line">    &#125;</span><br><span class="line">    ln, err := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> srv.Serve(tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到它调用了<code>net.Listen</code>监听了端口的tcp请求，这里我就不继续往下追了，因为我认为这里面往下都是属于tcp传输层的东西，不是本文研究的重点，有兴趣的童鞋可以继续追进去看一下。</p><p>最终把<code>TCPListener</code>转换成一个<code>tcpKeepAliveListener</code>调用了方法Serve：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Serve accepts incoming connections on the Listener l, creating a</span></span><br><span class="line"><span class="comment">// new service goroutine for each. The service goroutines read requests and</span></span><br><span class="line"><span class="comment">// then call srv.Handler to reply to them.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// HTTP/2 support is only enabled if the Listener returns *tls.Conn</span></span><br><span class="line"><span class="comment">// connections and they were configured with "h2" in the TLS</span></span><br><span class="line"><span class="comment">// Config.NextProtos.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Serve always returns a non-nil error and closes l.</span></span><br><span class="line"><span class="comment">// After Shutdown or Close, the returned error is ErrServerClosed.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fn := testHookServerServe; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">        fn(srv, l) <span class="comment">// call hook with unwrapped listener</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    l = &amp;onceCloseListener&#123;Listener: l&#125;</span><br><span class="line">    <span class="keyword">defer</span> l.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := srv.setupHTTP2_Serve(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !srv.trackListener(&amp;l, <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrServerClosed</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> srv.trackListener(&amp;l, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> tempDelay time.Duration     <span class="comment">// how long to sleep on accept failure</span></span><br><span class="line">    baseCtx := context.Background() <span class="comment">// base is always background, per Issue 16220</span></span><br><span class="line">    ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        rw, e := l.Accept()</span><br><span class="line">        <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-srv.getDoneChan():</span><br><span class="line">                <span class="keyword">return</span> ErrServerClosed</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">                <span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">                    tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tempDelay *= <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">                    tempDelay = max</span><br><span class="line">                &#125;</span><br><span class="line">                srv.logf(<span class="string">"http: Accept error: %v; retrying in %v"</span>, e, tempDelay)</span><br><span class="line">                time.Sleep(tempDelay)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e</span><br><span class="line">        &#125;</span><br><span class="line">        tempDelay = <span class="number">0</span></span><br><span class="line">        c := srv.newConn(rw)</span><br><span class="line">        c.setState(c.rwc, StateNew) <span class="comment">// before Serve can return</span></span><br><span class="line">        <span class="keyword">go</span> c.serve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中比较核心的是for循环里面那一段，不断的<code>Accept</code>新的请求，然后通过<code>srv.newConn</code>创建一个新的连接，然后开启一个go协程处理这个请求。这个<code>srv.newConn</code>返回的是一个<code>conn</code>结构体，其成员和函数也非常之多，它代表的是服务的一个http连接。</p><p>下面这段代码是处理http请求协议内容的核心代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Serve a new connection.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span> <span class="title">serve</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    c.remoteAddr = c.rwc.RemoteAddr().String()</span><br><span class="line">    ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr())</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &amp;&amp; err != ErrAbortHandler &#123;</span><br><span class="line">            <span class="keyword">const</span> size = <span class="number">64</span> &lt;&lt; <span class="number">10</span></span><br><span class="line">            buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, size)</span><br><span class="line">            buf = buf[:runtime.Stack(buf, <span class="literal">false</span>)]</span><br><span class="line">            c.server.logf(<span class="string">"http: panic serving %v: %v\n%s"</span>, c.remoteAddr, err, buf)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !c.hijacked() &#123;</span><br><span class="line">            c.<span class="built_in">close</span>()</span><br><span class="line">            c.setState(c.rwc, StateClosed)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> tlsConn, ok := c.rwc.(*tls.Conn); ok &#123;</span><br><span class="line">        <span class="keyword">if</span> d := c.server.ReadTimeout; d != <span class="number">0</span> &#123;</span><br><span class="line">            c.rwc.SetReadDeadline(time.Now().Add(d))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> d := c.server.WriteTimeout; d != <span class="number">0</span> &#123;</span><br><span class="line">            c.rwc.SetWriteDeadline(time.Now().Add(d))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err := tlsConn.Handshake(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// If the handshake failed due to the client not speaking</span></span><br><span class="line">            <span class="comment">// TLS, assume they're speaking plaintext HTTP and write a</span></span><br><span class="line">            <span class="comment">// 400 response on the TLS conn's underlying net.Conn.</span></span><br><span class="line">            <span class="keyword">if</span> re, ok := err.(tls.RecordHeaderError); ok &amp;&amp; re.Conn != <span class="literal">nil</span> &amp;&amp; tlsRecordHeaderLooksLikeHTTP(re.RecordHeader) &#123;</span><br><span class="line">                io.WriteString(re.Conn, <span class="string">"HTTP/1.0 400 Bad Request\r\n\r\nClient sent an HTTP request to an HTTPS server.\n"</span>)</span><br><span class="line">                re.Conn.Close()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            c.server.logf(<span class="string">"http: TLS handshake error from %s: %v"</span>, c.rwc.RemoteAddr(), err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.tlsState = <span class="built_in">new</span>(tls.ConnectionState)</span><br><span class="line">        *c.tlsState = tlsConn.ConnectionState()</span><br><span class="line">        <span class="keyword">if</span> proto := c.tlsState.NegotiatedProtocol; validNPN(proto) &#123;</span><br><span class="line">            <span class="keyword">if</span> fn := c.server.TLSNextProto[proto]; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">                h := initNPNRequest&#123;tlsConn, serverHandler&#123;c.server&#125;&#125;</span><br><span class="line">                fn(c.server, tlsConn, h)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HTTP/1.x from here on.</span></span><br><span class="line"></span><br><span class="line">    ctx, cancelCtx := context.WithCancel(ctx)</span><br><span class="line">    c.cancelCtx = cancelCtx</span><br><span class="line">    <span class="keyword">defer</span> cancelCtx()</span><br><span class="line"></span><br><span class="line">    c.r = &amp;connReader&#123;conn: c&#125;</span><br><span class="line">    c.bufr = newBufioReader(c.r)</span><br><span class="line">    c.bufw = newBufioWriterSize(checkConnErrorWriter&#123;c&#125;, <span class="number">4</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        w, err := c.readRequest(ctx)</span><br><span class="line">        <span class="keyword">if</span> c.r.remain != c.server.initialReadLimitSize() &#123;</span><br><span class="line">            <span class="comment">// If we read any bytes off the wire, we're active.</span></span><br><span class="line">            c.setState(c.rwc, StateActive)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> errorHeaders = <span class="string">"\r\nContent-Type: text/plain; charset=utf-8\r\nConnection: close\r\n\r\n"</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> err == errTooLarge &#123;</span><br><span class="line">                <span class="comment">// Their HTTP client may or may not be</span></span><br><span class="line">                <span class="comment">// able to read this if we're</span></span><br><span class="line">                <span class="comment">// responding to them and hanging up</span></span><br><span class="line">                <span class="comment">// while they're still writing their</span></span><br><span class="line">                <span class="comment">// request. Undefined behavior.</span></span><br><span class="line">                <span class="keyword">const</span> publicErr = <span class="string">"431 Request Header Fields Too Large"</span></span><br><span class="line">                fmt.Fprintf(c.rwc, <span class="string">"HTTP/1.1 "</span>+publicErr+errorHeaders+publicErr)</span><br><span class="line">                c.closeWriteAndWait()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> isCommonNetReadError(err) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="comment">// don't reply</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            publicErr := <span class="string">"400 Bad Request"</span></span><br><span class="line">            <span class="keyword">if</span> v, ok := err.(badRequestError); ok &#123;</span><br><span class="line">                publicErr = publicErr + <span class="string">": "</span> + <span class="keyword">string</span>(v)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fmt.Fprintf(c.rwc, <span class="string">"HTTP/1.1 "</span>+publicErr+errorHeaders+publicErr)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Expect 100 Continue support</span></span><br><span class="line">        req := w.req</span><br><span class="line">        <span class="keyword">if</span> req.expectsContinue() &#123;</span><br><span class="line">            <span class="keyword">if</span> req.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &amp;&amp; req.ContentLength != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// Wrap the Body reader with one that replies on the connection</span></span><br><span class="line">                req.Body = &amp;expectContinueReader&#123;readCloser: req.Body, resp: w&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> req.Header.get(<span class="string">"Expect"</span>) != <span class="string">""</span> &#123;</span><br><span class="line">            w.sendExpectationFailed()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        c.curReq.Store(w)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> requestBodyRemains(req.Body) &#123;</span><br><span class="line">            registerOnHitEOF(req.Body, w.conn.r.startBackgroundRead)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            w.conn.r.startBackgroundRead()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// HTTP cannot have multiple simultaneous active requests.[*]</span></span><br><span class="line">        <span class="comment">// Until the server replies to this request, it can't read another,</span></span><br><span class="line">        <span class="comment">// so we might as well run the handler in this goroutine.</span></span><br><span class="line">        <span class="comment">// [*] Not strictly true: HTTP pipelining. We could let them all process</span></span><br><span class="line">        <span class="comment">// in parallel even if their responses need to be serialized.</span></span><br><span class="line">        <span class="comment">// But we're not going to implement HTTP pipelining because it</span></span><br><span class="line">        <span class="comment">// was never deployed in the wild and the answer is HTTP/2.</span></span><br><span class="line">        serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class="line">        w.cancelCtx()</span><br><span class="line">        <span class="keyword">if</span> c.hijacked() &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        w.finishRequest()</span><br><span class="line">        <span class="keyword">if</span> !w.shouldReuseConnection() &#123;</span><br><span class="line">            <span class="keyword">if</span> w.requestBodyLimitHit || w.closedRequestBodyEarly() &#123;</span><br><span class="line">                c.closeWriteAndWait()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.setState(c.rwc, StateIdle)</span><br><span class="line">        c.curReq.Store((*response)(<span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> !w.conn.server.doKeepAlives() &#123;</span><br><span class="line">            <span class="comment">// We're in shutdown mode. We might've replied</span></span><br><span class="line">            <span class="comment">// to the user without "Connection: close" and</span></span><br><span class="line">            <span class="comment">// they might think they can send another</span></span><br><span class="line">            <span class="comment">// request, but such is life with HTTP/1.1.</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> d := c.server.idleTimeout(); d != <span class="number">0</span> &#123;</span><br><span class="line">            c.rwc.SetReadDeadline(time.Now().Add(d))</span><br><span class="line">            <span class="keyword">if</span> _, err := c.bufr.Peek(<span class="number">4</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        c.rwc.SetReadDeadline(time.Time&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面的代码非常之多，不太好解析，这里捡个重点说说，其中解析http协议调用的是<code>readRequest</code>方法，里面做了很多操作，比如说解析请求头的一些属性，比如请求类型、协议版本、请求URI、缓存控制等等，把他们放入到<code>Request</code>对象里面，这个结构体也是我们日常开发中最常用到的，我们会从这里获取所需要的请求信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parseRequestLine parses "GET /foo HTTP/1.1" into its three parts.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseRequestLine</span><span class="params">(line <span class="keyword">string</span>)</span> <span class="params">(method, requestURI, proto <span class="keyword">string</span>, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    s1 := strings.Index(line, <span class="string">" "</span>)</span><br><span class="line">    s2 := strings.Index(line[s1+<span class="number">1</span>:], <span class="string">" "</span>)</span><br><span class="line">    <span class="keyword">if</span> s1 &lt; <span class="number">0</span> || s2 &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    s2 += s1 + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> line[:s1], line[s1+<span class="number">1</span> : s2], line[s2+<span class="number">1</span>:], <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然其中还有一个非常重要的操作，那就是调用我们之前注册的handler，这个操作是在解析完http请求之后的地方，然后后面就是一些收尾操作。</p><img src="/images/2020-06-07_21-46.png" /><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>相信很多人看完之后还是一脸懵逼，我也差不多，虽然说看上去都是合情合理，但是很多细节并没有深入去研究，虽然说http协议是一个文本协议，但是其解析处理也绝非易事。对于很多使用Go做Web开发的人来说，有必要简单了解一下，有助于了解网络请求的处理过程，加深对协议的理解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Golang之所以非常适合用于网络编程的原因之一就是其自带网络库可以非常简单快速的建立一个基于http或者tcp的服务应用，以http服务为例，只需几行代码：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;net/http&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    http.HandleFunc(&lt;span class=&quot;string&quot;&gt;&quot;/&quot;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(writer http.ResponseWriter, r *http.Request)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _, _ = writer.Write([]&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Hello&quot;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    err := http.ListenAndServe(&lt;span class=&quot;string&quot;&gt;&quot;:8888&quot;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;panic&lt;/span&gt;(err)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面这几行代码就启动了一个http服务，运行在8888端口，虽然说非常简陋，也不区分GET或者POST，但是其性能缺十分高效，主要是得益于其底层使用了协程，对每一个请求都会分配一个协程去处理，并发能力强。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="https://wangbjun.site/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.site/tags/Golang/"/>
    
      <category term="Http" scheme="https://wangbjun.site/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>Golang里面slice初始化的坑</title>
    <link href="https://wangbjun.site/2020/coding/golang/make-slice.html"/>
    <id>https://wangbjun.site/2020/coding/golang/make-slice.html</id>
    <published>2020-06-06T15:42:22.000Z</published>
    <updated>2020-06-07T08:02:38.763Z</updated>
    
    <content type="html"><![CDATA[<p>相信很多人对Golang里面的数组都不陌生，但实际上99%的场景我们使用的都是slice，原因很简单，Go里面的数组类似C数组长度是固定的，局限太多，而slice则是一个变长的数组，可以自动扩容，类似JS、PHP等弱类型语言里面的数组。</p><p>但实际使用slice的过程中，我们一般会遇到2种写法，下面咱们就说说这2种方式的差异和存在的坑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="1-make和new区别"><a href="#1-make和new区别" class="headerlink" title="1.make和new区别"></a>1.make和new区别</h2><p>首先，咱先说说make的使用，make是Go的内置函数，专门用于分配和初始化指定大小的slice、map、chan类型，它返回的是一个type。而new则不同，new返回的是一个*type,也就是一个指针类型，指向type的零值。</p><p>在使用make初始化slice的时候，其第二个参数是slice的长度length（必填，可为0），第三个参数是容量capacity（选填），new的话只有一个参数。</p><p>比如下面这些写法，前面2种大部分情况下是等价的，使用起来并没有多大区别，但是第三种new的写法就稍微有点区别，因为它的返回值是指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">string</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">"1"</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">"2"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ss = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">ss = <span class="built_in">append</span>(ss, <span class="string">"1"</span>)</span><br><span class="line">ss = <span class="built_in">append</span>(ss, <span class="string">"2"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sss = <span class="built_in">new</span>([]<span class="keyword">string</span>)</span><br><span class="line">*sss = <span class="built_in">append</span>(*sss, <span class="string">"1"</span>)</span><br><span class="line">*sss = <span class="built_in">append</span>(*sss, <span class="string">"2"</span>)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, s)</span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, ss)</span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, sss)</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line">&amp;[<span class="number">1</span> <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>实际应用中，slice、map、chan必须使用make初始化，new则很少用，偶尔用于结构体的初始化，但是一般结构体我们会采用更加简单的字面量声明方式。</p><h2 id="2-make指定slice大小和容量"><a href="#2-make指定slice大小和容量" class="headerlink" title="2.make指定slice大小和容量"></a>2.make指定slice大小和容量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">string</span></span><br></pre></td></tr></table></figure><p>上面这种初始化方式，length和capacity默认是为0</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">3</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>而上面这种方式，则是初始化了一个长度为3，容量为10的slice，也就是说里面已经有3个元素了，但是值是这些元素类型的零值，对于string来说就是空字符串。</p><p>实际应用中，如果你对接下来使用的容量有一个预计，则可以提前开辟好内存空间，避免slice后期自动扩容，毕竟扩容也有性能开销。</p><h2 id="3-JSON序列化"><a href="#3-JSON序列化" class="headerlink" title="3.JSON序列化"></a>3.JSON序列化</h2><p>其实这点是比较奇怪的地方，也是差异最大的地方，在拿Go写API接口的时候，我们经常需要把结果序列化成JSON返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="string">"1"</span>)</span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="string">"2"</span>)</span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="string">"3"</span>)</span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="string">"4"</span>)</span><br><span class="line">&#125;</span><br><span class="line">result, err := json.Marshal(s)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, result)</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>]</span><br></pre></td></tr></table></figure><p>比如上面这个例子，正常情况下是没问题，但是如果 if 的条件未成立，s则是一个空的slice，结果就不一样了，返回的是null，这个就不太好了，对于前端来说，空数组应该是<code>[]</code>而不是null，从接口规范来说，我们应该保持返回类型一致。</p><p>但是如果你使用make初始化则不存在这个问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">result, err := json.Marshal(s)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, result)</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p>这是为什么呢？</p><p><b>在Go里面，当一个变量被声明了但是没有初始化值的话，其默认值则是该类型的零值，比如string默认零值是空字符串，int默认是0，对于slice来说其零值是nil。</b>所以严格来说，<code>var s []string</code>申明的是一个nil slice，而<code>make</code>初始化的是一个空slice，它们俩是有区别的，看一下下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">string</span></span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, s == <span class="literal">nil</span>) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ss = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, ss == <span class="literal">nil</span>) <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>虽然说大部分情况下使用起来都没有区别，但是在json序列化的时候，nil直接就被处理成了null。。。</p><p>最后总结，建议大家使用make初始化slice，同时也不建议通过判断slice是否为nil去处理一些逻辑，建议更加靠谱的方式，比如slice的length。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信很多人对Golang里面的数组都不陌生，但实际上99%的场景我们使用的都是slice，原因很简单，Go里面的数组类似C数组长度是固定的，局限太多，而slice则是一个变长的数组，可以自动扩容，类似JS、PHP等弱类型语言里面的数组。&lt;/p&gt;
&lt;p&gt;但实际使用slice的过程中，我们一般会遇到2种写法，下面咱们就说说这2种方式的差异和存在的坑：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s []&lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s = &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;([]&lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="https://wangbjun.site/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.site/tags/Golang/"/>
    
      <category term="Slice" scheme="https://wangbjun.site/tags/Slice/"/>
    
  </entry>
  
  <entry>
    <title>详解Linux环境下各种代理设置</title>
    <link href="https://wangbjun.site/2020/linux/linux-proxy.html"/>
    <id>https://wangbjun.site/2020/linux/linux-proxy.html</id>
    <published>2020-05-30T12:31:02.000Z</published>
    <updated>2020-05-30T14:15:14.769Z</updated>
    
    <content type="html"><![CDATA[<p>做技术的人都知道，有时候为了查询一些信息，必须访问一些国外资源，由于这些资源的服务器位于国外，速度较慢，有时候甚至是根本无法访问（你们懂的），这时候拥有一个VPN或者是代理就非常重要了，这也就是国内大部分人使用代理的主要目的，当然代理还有其它很多好处，比如隐藏自己的IP地址和来源。</p><p>首先，咱们常见代理有socks代理和http(s)代理之分，比如socks代理默认端口就是在1080。这2者有啥区别呢？http代理属于应用层代理，类似的还有ftp代理，socks代理与应用层代理不同，socks代理只是简单地传递数据包，而不必关心是何种应用协议（比如FTP、HTTP请求）。所以，socks代理比其他应用层代理要快得多，目前用的最多的就是socks5代理。</p><a id="more"></a><img src="/images/2020-05-30_20-43.png" /> <p>大部分的代理应用都会同时支持这2种形式，有人说既然socks代理快，那为什么还要用http代理，原因很简单,部分应用只支持应用层代理。。。</p><h2 id="1-系统代理"><a href="#1-系统代理" class="headerlink" title="1.系统代理"></a>1.系统代理</h2><p>虽然本文是讲述Linux环境下的，但是顺便也说一下Windows，在Windows上需要在ie浏览器的网络设置页面设置，但很多代理软件在开启之后会自动修改设置，一般来说不需要大家自己手动去修改代理设置。</p><p>Linux下的代理设置也在网络设置里面，但是不同的桌面环境下的UI界面可能不是太一样，比如我上图就是Ubuntu 16.04下的设置页面。</p><p>但是无论是Windows还是Linux，设置了系统代理也不一定就有用，为什么这么说呢？</p><p>因为很多应用不走系统代理设置，虽然你设置了系统的全局代理，但是很多应用都有自己的网络代理设置页面，也就是说你需要单独去设置。</p><p>在Linux桌面下，最典型的2个案例，一个是Chrome，Chrome默认是走的系统代理设置，但是FirFox浏览器则是有自己的网络代理设置页面。</p><img src="/images/2020-05-30_20-54.png" /><p>实际上，大部分软件都不走系统代理设置，一般都有一个自己的单独设置方式，下面咱就说说Ubuntu桌面下常用软件的网络代理设置。</p><h2 id="2-命令行终端"><a href="#2-命令行终端" class="headerlink" title="2.命令行终端"></a>2.命令行终端</h2><p>在Linux下，命令行默认是不走系统代理设置的，如果想走代理必须单独设置，最简单的方法是通过export导入环境变量，比如设置http代理可以通过下面这种方式设置：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=127.0.0.1:1081</span><br><span class="line">export https_proxy=127.0.0.1:1081</span><br></pre></td></tr></table></figure><p>如果是socks代理可以这样：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export socks_proxy=127.0.0.1:1080</span><br></pre></td></tr></table></figure><p>如果嫌麻烦，可以使用all_proxy同时设置所有代理：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ALL_PROXY=socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure><p>需要提醒一点的是，使用export设置只在当前终端有效，如果你想保持这个设置，可以把命令写到<code>/etc/profile</code>或者<code>~/.profile</code>等环境设置脚本里面来实现永久效果。</p><p>设置完这些代理之后，一般常用命令，比如curl，wget是会走这个环境变量的，但是还有很多命令是不走的，特别是一些复杂的应用，它们也有自己的代理设置选项，举个例子，更新系统使用的apt命令，它就需要更改配置文件：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/apt.conf</span><br><span class="line"></span><br><span class="line">在里面加入下列配置</span><br><span class="line"></span><br><span class="line">Acquire &#123;</span><br><span class="line">  HTTP::proxy "http://127.0.0.1:1081";</span><br><span class="line">  HTTPS::proxy "https://127.0.0.1:1081";</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有命令，比如Git，也需要单独设置：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy 127.0.0.1:1081</span><br></pre></td></tr></table></figure><p>类似这样的命令工具还有很多，它们默认情况下不会使用系统代理，但是也不走终端的环境变量，都有配置项或者配置文件去设置，所以必须自己手动设置，比较麻烦。</p><h2 id="3-GUI应用"><a href="#3-GUI应用" class="headerlink" title="3.GUI应用"></a>3.GUI应用</h2><p>相对于命令行来说，大部分桌面GUI应用都会有自己的网络设置选项，使用起来也简单很多，这里就不多说了，举个例子，下面是qBittorrent软件的网络设置界面</p><img src="/images/2020-05-30_21-33.png" /><h2 id="4-终极手段"><a href="#4-终极手段" class="headerlink" title="4.终极手段"></a>4.终极手段</h2><p>如果一个应用既不走系统代理，同时也不支持网络设置，那是足够奇葩了，对于这样的软件有什么好的方式呢？</p><p>这里我提供2个思路，第一个就是使用虚拟机，比如virtualbox，我们可以给虚拟机设置一个代理，这样的话虚拟机里面的软件也得走代理。另外就是不在电脑上面设置代理，我们可以在路由器上面设置代理，这样所有的经过这台路由器上网设备都会走代理。</p><p>现在很多路由器都是基于开源的openwrt系统，非常强大，本质上就是一个简版Linux，在上面可以干很多事情，比如说设置代理、拦截广告、网速加速。</p><h2 id="5-全局模式或PAC模式"><a href="#5-全局模式或PAC模式" class="headerlink" title="5.全局模式或PAC模式"></a>5.全局模式或PAC模式</h2><p>很多人可能对这个PAC模式不了解，这里简单说一下，所谓PAC模式就是可以智能分流，通过你访问的网址判断是否走代理，为什么要这么做呢？</p><p>通常我们使用代理是因为有部分网站速度比较慢或者访问不了，全局模式下所有的请求都会走代理中转。举个例子：你要去一个超市买东西，但超市你去不了，所以你找个人帮你去超市买，这中间就多走了一道中转程序，肯定比较慢，但是有个超市你明明可以去，你也让人帮你去买，那就耽误事了。</p><p>所以全局模式不一定适合你，很多代理收费是按流量计算的，其实你访问一些国内网站速度已经很快了，不需要走代理的，就是浪费流量，浪费钱啊，另外假如这个代理网速慢的话，还会影响你访问速度。</p><p>怎么解决这个问题呢？聪明的你会想到那我就手动开关代理，如果访问一个网站速度慢我就开启代理，当我访问国内网站的时候我就关闭代理，这种策略的思想其实就是PAC模式，咱也不用那么麻烦了。</p><p>PAC模式原理是其实有一个域名名单列表，上面维护了一些（和谐）域名，当你访问这些域名的时候，它就会走代理，对于不在这些列表范围外的域名则会直接访问。现在很多代理软件都会提供这2种模式，你可以随意切换，一般推荐使用PAC模式，如果使用PAC模式无法访问某些网站，可以尝试切换到全局模式，因为某些域名可能不在这个列表范围内。</p><p>对于Chrome浏览器，可以安装一些插件来实现这种效果，比如SwitchyOmega：</p><img src="/images/2020-05-30_21-55.png" /><p>最后说一下，如果你只有socks代理，也可以通过一些软件转为http代理，具体详情可以查看我之前写的一篇文章：<a href="https://wangbjun.site/2018/linux/socks-to-http.html">科学上网之socks代理转http(s)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做技术的人都知道，有时候为了查询一些信息，必须访问一些国外资源，由于这些资源的服务器位于国外，速度较慢，有时候甚至是根本无法访问（你们懂的），这时候拥有一个VPN或者是代理就非常重要了，这也就是国内大部分人使用代理的主要目的，当然代理还有其它很多好处，比如隐藏自己的IP地址和来源。&lt;/p&gt;
&lt;p&gt;首先，咱们常见代理有socks代理和http(s)代理之分，比如socks代理默认端口就是在1080。这2者有啥区别呢？http代理属于应用层代理，类似的还有ftp代理，socks代理与应用层代理不同，socks代理只是简单地传递数据包，而不必关心是何种应用协议（比如FTP、HTTP请求）。所以，socks代理比其他应用层代理要快得多，目前用的最多的就是socks5代理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://wangbjun.site/categories/Linux/"/>
    
    
      <category term="Proxy" scheme="https://wangbjun.site/tags/Proxy/"/>
    
  </entry>
  
  <entry>
    <title>疫情之下之口罩乱象</title>
    <link href="https://wangbjun.site/2020/life/mask-story.html"/>
    <id>https://wangbjun.site/2020/life/mask-story.html</id>
    <published>2020-05-16T02:00:00.000Z</published>
    <updated>2020-05-16T04:09:53.547Z</updated>
    
    <content type="html"><![CDATA[<p>这次疫情出人意料的持续时间长，口罩瞬间成为一种刚需和战略物资，虽然很多人可能不太愿意戴口罩，但是在中国如果你不戴口罩是没法出门的，这是一种强制措施。我国人多，对口罩的需求更大，在前期口罩基本上买不到，不仅需要抢，而且需要拖关系，甚至由于口罩闹出很多丑事，比如武汉红十字会。而且很多人喜欢囤积，假如你有找到了货源，你可能不会只买1个，你会买未来2个月的用量，那可能就是几百个。</p><p>我2月初回北京的时候只戴了一个布口罩，主要是确实没有医用口罩可用，对于我来说，这种口罩完全是形式大于实际意义，但是你如果不戴口罩是没法出门、坐火车，确实很无赖，对于检查人员来说，他们不关心你戴的是什么口罩，只要把脸遮住，哪怕是自己拿布缝的也没问题。</p><a id="more"></a><h2 id="1-口罩-印钞机"><a href="#1-口罩-印钞机" class="headerlink" title="1.口罩 === 印钞机"></a>1.口罩 === 印钞机</h2><p>实际上在1月20号左右，武汉还没宣布封城的时候，口罩已经买不到了，那会很多人已经慌了，跑到各大医院去买口罩，北京有些公司已经开始给员工发口罩了。</p><p>也就是从这时候开始，口罩进入暴利时期，有人戏说口罩机就是印钞机。原来卖5毛钱一个的一次性口罩现在可以卖5块钱，很多人抢着要，便宜一点也要2-3块钱。至于N95、KN95这样的外科医用口罩，已经被炒到十几块钱一个了。实际上，时至今日大部分人用的都是医用一次性口罩，N95这种口罩大多数都是供应给医院护士使用，普通人很少用，一个是贵，另外戴着也太闷了，不舒服。</p><p>这里看一下一个普通的一次性口罩的结构，下图就是最常见的这种：</p><img src = "/images/2020-05-16.jpeg"/><p>大体来说，一次性口罩分为2大部分，方形的是口罩主体，然后有2个带子，其中口罩主体有一个金属条是方便我们戴的时候固定在鼻子位置。如果从生产上说，口罩主体部分是完全自动化的，专业人士称之为打片机，速度非常快，一天可以打几万个，但是把口罩带子焊接在口罩主体上很多厂还需要人工操作，使用一种机器叫作点焊机。还有生产口罩还需要一种非常核心的原料，熔喷布，可以说生产熔喷布的企业才是这个食物链的最顶端。</p><p>这次涨价首先是从销售端开始的，起先很多商店、企业都会有一些口罩库存，这批货的成本相当于来说比较低，利润是最大的。紧接着，整个口罩供应链都涨起来了，打片机原来的价格是几万，现在需要几十万，点焊机原价2000，现在卖2万，几乎所有的原材料和设备价格都上涨了约10倍，但这些溢价最终还是转嫁给了客户。</p><p>其实，并不是所有口罩厂都发财了，据我所知，很多大的口罩厂在疫情前期口罩销售被垄断，zf以“市场价”强制收购，而原材料疯涨，这些口罩厂即使不亏本也赚不了多少钱。更多发财的是那些小口罩厂和中间商，很多小口罩厂只有几台机器，产量有限，没有引起zf的关照，自产自销，供不应求，利润翻了很多倍，这几个月挣的钱抵得上未来10年。</p><h2 id="2-风险投资"><a href="#2-风险投资" class="headerlink" title="2.风险投资"></a>2.风险投资</h2><p>对于那些疫情前就在做口罩的企业来说，发财是必不可免的事情，但是也有很多人发现了商机，想要快速入行分一杯羹。但是这个发财的窗口期非常端，实际上现在回过头看，只有短短3个月，也就是1月底、2月、3月，实际上到了4个月的时候，国内口罩已经卖不动了，虽然说国际疫情爆发了，但是很多口罩小厂没有资质，更别说满足什么国际标准了，出口很难。</p><p>而且这个时候建厂，各种原材料和设备价格疯涨，不一定能赚钱，入场晚的基本上就是接盘侠，被割韭菜的命，我一个亲戚在4月份的时候准备花百万购置口罩机，后来据说没做了，转手把机器又卖出去了，挣了几万差价，这个结果已经非常好了，但是还有很多人没有看清形势。</p><h2 id="3-口罩质量问题"><a href="#3-口罩质量问题" class="headerlink" title="3.口罩质量问题"></a>3.口罩质量问题</h2><p>实际上，在疫情前期，中国有很多小的口罩厂，如果严格来说，生产的口罩质量不一定完全符合标准，但是这时候国内口罩完全不够用，所以没人去查质量问题，就像很多说的即使质量不合格，总比没有强。</p><p>但是到了4月份，国外疫情爆发，口罩外贸火爆，全世界都从中国买口罩，对于口罩生产商来说是赚钱的机会，但是不是所有口罩生产厂都有资质出口的，但是这都不是事。由于大厂有出口资质，但是生产能力有限，小厂虽然有产能，但是没法出口，2者一拍即合，小厂给大厂代工，把生产好的口罩卖给大厂，大厂贴牌后出口。</p><p>但是由于老外“死心眼”，口罩都没得戴还挑三拣四，说质量不合格，不符合标准，国内很多人叫嚣应该按我国标准算，不符合标准你就别买，我还不卖给你呢。。。</p><p>然而国际贸易并不是儿戏，必须遵循规则和标准，如果你想赚钱就必须按标准生产，同时对于国家来说，这种事情也影响了国家声誉，所以官方也开始打击这种行为。</p><img src = "/images/2020-05-16_1.png"/><p>湖北仙桃彭场镇是全国最大的口罩生产基地，在3月底，湖北解封，人员可以流动了，口罩家庭小作坊遍地都是，家家户户都在做口罩。其中就有很多人推销那个点焊机，2万一台（平时卖2000），他们宣称一天可以挣2000，10天回本，看上去确实非常诱人。</p><p>生产模式是这样，你买了点焊机之后，你需要自己买“片子”，所谓片子就是打片机生产的口罩主体部分，还有带子，然后你使用点焊机把片子和带子焊到一起就是成品，打包之后就可以卖出去了，卖给谁呢？卖给口罩贩子，收购价格由口罩贩子定，价格浮动。</p><p>总的来说，卖点焊机的人并不承诺你的利润，你需要自负盈亏，自己花钱买片子、带子，自己花钱请人做工（2班倒，24小时生产），做成成品之后自己再想办法卖出去，万一口罩贩子不收或者压价，你也没有任何办法，只能任人宰割。最后，你还得堤防地方政府的随机检查打击，万一运气不好被抽奖抽中了，机器原材料都会被没收，血本无归。</p><p>即使如此，还是人有很多人乐此不彼，花重金参与，到最后很多人发现自己被割了韭菜，点焊机从2万又跌回了2000，口罩贩子的收购价格从1块钱跌到9毛、8毛、7毛，利润空间越来越小，到最后发现1个月白干。</p><p>与此同时，这些口罩流入大厂，贴牌之后出口到国外，如果被发现质量问题甚至可能引发外交风波。。。</p><p>实际上最大的赢家是那些口罩贩子（经销商），他们无论如何都只挣一个差价，左手从这些家庭作坊收购口罩，右手倒卖给外贸大厂贴牌，还有那些做工的人，每天工资400-500，纯收入不纳税。</p><p>对于地方政府来说，这种作坊也解决了不少人就业问题，也带动了GDP增长，即使不怎么合法也不敢赶尽杀绝，实际上更多是一种震慑，胆小的就被吓跑了，胆大的最后发现自己还是被割了韭菜。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次疫情出人意料的持续时间长，口罩瞬间成为一种刚需和战略物资，虽然很多人可能不太愿意戴口罩，但是在中国如果你不戴口罩是没法出门的，这是一种强制措施。我国人多，对口罩的需求更大，在前期口罩基本上买不到，不仅需要抢，而且需要拖关系，甚至由于口罩闹出很多丑事，比如武汉红十字会。而且很多人喜欢囤积，假如你有找到了货源，你可能不会只买1个，你会买未来2个月的用量，那可能就是几百个。&lt;/p&gt;
&lt;p&gt;我2月初回北京的时候只戴了一个布口罩，主要是确实没有医用口罩可用，对于我来说，这种口罩完全是形式大于实际意义，但是你如果不戴口罩是没法出门、坐火车，确实很无赖，对于检查人员来说，他们不关心你戴的是什么口罩，只要把脸遮住，哪怕是自己拿布缝的也没问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Life" scheme="https://wangbjun.site/categories/Life/"/>
    
    
      <category term="Life" scheme="https://wangbjun.site/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>Golang第三方测试库GoConvey</title>
    <link href="https://wangbjun.site/2020/coding/golang/go-convey.html"/>
    <id>https://wangbjun.site/2020/coding/golang/go-convey.html</id>
    <published>2020-04-13T13:00:33.000Z</published>
    <updated>2020-04-13T13:53:03.997Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过一篇Go测试的文章，文章介绍的是Go自带的官方测试库，今天来介绍一下一个非常流行的Go第三方测试库GoConvey，其实官方的文档已经写的非常清楚了，有兴趣的可以查看其 <a href="https://github.com/smartystreets/goconvey" target="_blank" rel="noopener">Github主页</a> ,里面有非常详细的介绍，英文好的话可以看看。</p><a id="more"></a><h2 id="1-快速开始"><a href="#1-快速开始" class="headerlink" title="1.快速开始"></a>1.快速开始</h2><p>简而言之，GoConvey是一个完全兼容官方Go Test的测试框架，一般来说这种第三方库都比官方的功能要强大、更加易于使用、开发效率更高，闲话少说，先看一个example：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> utils</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    . <span class="string">"github.com/smartystreets/goconvey/convey"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSpec</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    Convey(<span class="string">"Given some integer with a starting value"</span>, t, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        x := <span class="number">1</span></span><br><span class="line">        Convey(<span class="string">"When the integer is incremented"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            x++</span><br><span class="line">            Convey(<span class="string">"The value should be greater by one"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                So(x, ShouldEqual, <span class="number">2</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看，这个写法有点奇怪，一层层的嵌套式，如果你使用IDE的话你可以点到源码里面看一下其方法注释，其实已经说的非常清楚了，这里摘取部分看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Convey is the method intended for use when declaring the scopes of</span><br><span class="line">&#x2F;&#x2F; a specification. Each scope has a description and a func() which may contain</span><br><span class="line">&#x2F;&#x2F; other calls to Convey(), Reset() or Should-style assertions. Convey calls can</span><br><span class="line">&#x2F;&#x2F; be nested as far as you see fit.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; IMPORTANT NOTE: The top-level Convey() within a Test method</span><br><span class="line">&#x2F;&#x2F; must conform to the following signature:</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;     Convey(description string, t *testing.T, action func())</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; All other calls should look like this (no need to pass in *testing.T):</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;     Convey(description string, action func())</span><br></pre></td></tr></table></figure><p>这个用法相对简单了，Convey定义了一个局部的作用域，在这个作用域里面我们可以定义变量，调用方法，然后重复继续这个操作，low-level的Convey会继承top-level的变量。</p><p>了解之后，我们来扩展一下这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSpec</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    Convey(<span class="string">"Given some integer with a starting value"</span>, t, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        x := <span class="number">1</span></span><br><span class="line">        y := <span class="number">10</span></span><br><span class="line">        Convey(<span class="string">"When the integer is incremented"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            x++</span><br><span class="line">            Convey(<span class="string">"The value should be greater by one"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                So(x, ShouldEqual, <span class="number">2</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        Convey(<span class="string">"When x &lt; y"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">                x = x + y</span><br><span class="line">                So(x, ShouldBeGreaterThan, y)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常简单，当然这里我们并没有测试任何函数或方法，下面咱们写一个函数真正测试一下，假设有下面的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Div</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">"can not div zero"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用GoConvey的话，测试代码可以这么写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDiv</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> X = <span class="number">10</span></span><br><span class="line">    Convey(<span class="string">"Normal Result"</span>, t, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        res, err := Div(X, <span class="number">2</span>)</span><br><span class="line">        So(res, ShouldEqual, <span class="number">5</span>)</span><br><span class="line">        So(err, ShouldBeNil)</span><br><span class="line">        Convey(<span class="string">"Extend Scope"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            res, err := Div(res, <span class="number">2</span>)</span><br><span class="line">            So(res, ShouldEqual, <span class="number">2</span>)</span><br><span class="line">            So(err, ShouldBeNil)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    Convey(<span class="string">"Error Result"</span>, t, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        res, err := Div(X, <span class="number">0</span>)</span><br><span class="line">        So(res, ShouldEqual, <span class="number">0</span>)</span><br><span class="line">        So(err, ShouldNotBeNil)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有人可能会觉得这和官方的没多大区别，相当于多加了一个注释，可以对每一个测试用例标识，但是不仅仅如此，这个库还提供了大量增强的Assertions，可以非常方便的对字符串、slice、map结果进行断言测试，具体的话可以查看一下文档或者点进去看看源码注释，这些源码注释基本上已经写的非常清楚了。</p><h2 id="2-Web-UI"><a href="#2-Web-UI" class="headerlink" title="2.Web UI"></a>2.Web UI</h2><p>此外，框架还提供了一个Web端的UI界面，可以非常方便的查看测试覆盖和运行情况，还可以自动运行测试，执行<code>goconvey</code>命令就可以启动服务，快试一试吧！（虽然说像Goland这样的IDE也提供了GUI工具查看测试覆盖率，但是这个更加方便）</p><p>另外，这个框架还提供了自定义Assertions的功能，使用起来也很方便，有一个通用的模板：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">should</span>&lt;<span class="title">do</span>-<span class="title">something</span>&gt;<span class="params">(actual <span class="keyword">interface</span>&#123;&#125;, expected ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> &lt;some-important-condition-is-met(actual, expected)&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>   <span class="comment">// empty string means the assertion passed</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&lt;some descriptive message detailing why the assertion failed...&gt;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子，这里定义一个试试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shouldNotGreatThan100</span><span class="params">(actual <span class="keyword">interface</span>&#123;&#125;, expected ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> actual.(<span class="keyword">int</span>) &gt; <span class="number">100</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"too big than 100"</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体使用起来和库里面其它的Assertions是完全一模一样的，没有任何区别，这里就不演示了。</p><h2 id="3-定义通用的逻辑"><a href="#3-定义通用的逻辑" class="headerlink" title="3.定义通用的逻辑"></a>3.定义通用的逻辑</h2><p>有时候测试会需要做一些准备工作，而且是重复的，比如说一些初始化操作，这时候就可以定义一个函数完成这件事，不必每次测试重复做，官方文档里面举了一个数据库测试的例子，每次测试前开启事务，测试结束后回滚事务，这里贴一下官方的example，大家看一下，很容易理解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"database/sql"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line">    _ <span class="string">"github.com/lib/pq"</span></span><br><span class="line">    . <span class="string">"github.com/smartystreets/goconvey/convey"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTransaction</span><span class="params">(db *sql.DB, f <span class="keyword">func</span>(tx *sql.Tx)</span>) <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        tx, err := db.Begin()</span><br><span class="line">        So(err, ShouldBeNil)</span><br><span class="line"></span><br><span class="line">        Reset(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">/* Verify that the transaction is alive by executing a command */</span></span><br><span class="line">            _, err := tx.Exec(<span class="string">"SELECT 1"</span>)</span><br><span class="line">            So(err, ShouldBeNil)</span><br><span class="line"></span><br><span class="line">            tx.Rollback()</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Here we invoke the actual test-closure and provide the transaction */</span></span><br><span class="line">        f(tx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUsers</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    db, err := sql.Open(<span class="string">"postgres"</span>, <span class="string">"postgres://localhost?sslmode=disable"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Convey(<span class="string">"Given a user in the database"</span>, t, WithTransaction(db, <span class="function"><span class="keyword">func</span><span class="params">(tx *sql.Tx)</span></span> &#123;</span><br><span class="line">        _, err := tx.Exec(<span class="string">`INSERT INTO "Users" ("id", "name") VALUES (1, 'Test User')`</span>)</span><br><span class="line">        So(err, ShouldBeNil)</span><br><span class="line"></span><br><span class="line">        Convey(<span class="string">"Attempting to retrieve the user should return the user"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">             <span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">             data := tx.QueryRow(<span class="string">`SELECT "name" FROM "Users" WHERE "id" = 1`</span>)</span><br><span class="line">             err = data.Scan(&amp;name)</span><br><span class="line"></span><br><span class="line">             So(err, ShouldBeNil)</span><br><span class="line">             So(name, ShouldEqual, <span class="string">"Test User"</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Required table to run the test:</span></span><br><span class="line"><span class="comment">CREATE TABLE "public"."Users" ( </span></span><br><span class="line"><span class="comment">    "id" INTEGER NOT NULL UNIQUE, </span></span><br><span class="line"><span class="comment">    "name" CHARACTER VARYING( 2044 ) NOT NULL</span></span><br><span class="line"><span class="comment">);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>基本上就是这些，强烈建议大家看一下官方文档，有很多细节这里并没有提到，毕竟咱也不能照抄，这个库完全可以代替官方的库，简单易用，效率高，推荐使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写过一篇Go测试的文章，文章介绍的是Go自带的官方测试库，今天来介绍一下一个非常流行的Go第三方测试库GoConvey，其实官方的文档已经写的非常清楚了，有兴趣的可以查看其 &lt;a href=&quot;https://github.com/smartystreets/goconvey&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github主页&lt;/a&gt; ,里面有非常详细的介绍，英文好的话可以看看。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="https://wangbjun.site/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.site/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Free ～ Will</title>
    <link href="https://wangbjun.site/2020/life/free-will.html"/>
    <id>https://wangbjun.site/2020/life/free-will.html</id>
    <published>2020-03-20T09:25:19.000Z</published>
    <updated>2020-03-20T10:12:41.596Z</updated>
    
    <content type="html"><![CDATA[<p>如果现在你说你要去做一款社交软件APP，我大概率会劝你不做，我可能会从市场、资金、成本等多个方面给你分析一通，然后告诉你成功率非常低，你或许认为我总是从最坏的情况考虑，并没有考虑其中的机遇和意外。也许会有人从其它方面分析一通，然后告诉你大有可为，成功率非常高。如果你仔细一想，你会发现两者都有道理，但是只有你真正做了你才能知道哪个是对的，这就像是薛定谔的猫，你只有打开那个盒子才能知道猫是活的还是死的。</p><a id="more"></a><p>很多人都看过马云创办阿里巴巴的创业史，觉得简直是个奇迹，但是媒体往往都是喜欢把聚光灯打在那些成功人的身上，至于那些死掉的、失败的案例，往往不会被记录，人们也不愿意看，因为成功的案例很少，失败的却有一大堆。</p><p>很多书籍往往把我这样的人称为悲观派，因为我们总是考虑最坏的情况，而乐观派往往总是从好的方面考虑。关于这方面，有一个非常经典的比喻：桌子上有半杯水，乐观的会说真好居然还有半杯水，而悲观的人会说唉只有半杯水了。然而这种比喻毫无上下文和事实依据，在当今数字时代，我们通常以数字说话，假如说现在统计表明90%的人都有10杯水，而你只有半杯水，你还乐观的起来吗？</p><p>这些文章举这个例子往往是想告诉大家要有一个好的心态，但是事实往往是不以你的心态而转移的，心态只有欺骗自己，却无法左右他人，一味的乐观，甚至会让人感觉有点阿Q。</p><p>我们每个人的思想都是受着周围环境的影响，从你出身到长大，你所经历的每一件事情，既是你的记忆，也在塑造了你的思想。</p><p>独立思想其实是个很难的事情，我们在生活中往往会发现很多人非常容易被“欺骗”，比如说有些人别人说什么Ta都相信，从不怀疑。这样的人人们你可以说是善良，也可以说是没有独立思想，很容易被洗脑。</p><p>洗脑这种事情每天都在发生，我们每天看到的新闻、视频都有可能在给你洗脑，有些是大张旗鼓的宣传，而有些可能是潜移默化的引导。在电影《盗梦空间》里面，有一段对话非常经典：“如果我现在对你说你不要去想大象，你会去想什么？大象”。人的思想是非常人员被操纵的，有人说最成功的的营销就是让你花钱买了东西还觉得自己赚了，实际上你可能并没有赚，甚至还花的更多，这样的事情很常见。</p><p>人类社会上千年来都是金字塔结构，这一点从来没有改变，大到国家，小到企业，世界上也没有真正公平和自由，虽然统治阶级几百年来一直在宣传这个概念，但是很多人都明白一个道理，公平和自由往往只存在于金字塔的同维度或者同阶级。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果现在你说你要去做一款社交软件APP，我大概率会劝你不做，我可能会从市场、资金、成本等多个方面给你分析一通，然后告诉你成功率非常低，你或许认为我总是从最坏的情况考虑，并没有考虑其中的机遇和意外。也许会有人从其它方面分析一通，然后告诉你大有可为，成功率非常高。如果你仔细一想，你会发现两者都有道理，但是只有你真正做了你才能知道哪个是对的，这就像是薛定谔的猫，你只有打开那个盒子才能知道猫是活的还是死的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Life" scheme="https://wangbjun.site/categories/Life/"/>
    
    
      <category term="Life" scheme="https://wangbjun.site/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu Nautilus隐藏文件(夹)</title>
    <link href="https://wangbjun.site/2020/linux/ubuntu-hidden-file.html"/>
    <id>https://wangbjun.site/2020/linux/ubuntu-hidden-file.html</id>
    <published>2020-03-15T10:57:06.000Z</published>
    <updated>2020-03-15T12:08:25.605Z</updated>
    
    <content type="html"><![CDATA[<p>如何在Ubuntu自带的文件夹管理器Nautilus里面隐藏文件或文件夹呢？</p><p>先说一下背景，之所以想到这个问题是因为我的电脑是 Win10+Ubuntu 双系统，有一块硬盘是共享的NTFS格式，在Windows下面分区会有2个文件夹，了解Windows的人应该知道，这是垃圾回收站和磁盘卷信息。</p><p>默认情况下在Windows里面这2个文件夹是隐藏的，但是当我切换到Ubuntu的时候，Ubuntu就会给显示出来了，这倒也正常，但是看起来很碍事，不爽，既然不爽我就要搞它。</p><a id="more"></a><img src = "/images/2020-03-15_18-58.png" /><p>Nautilus这个文件管理器在很多Linux发行版里面都会使用，我觉得还挺好用哈，默认情况下，它不显示隐藏文件（以.开头的文件），但使用 Ctrl+H 快捷键可以快速显示隐藏文件。</p><p>现在问题来了，这2个是文件夹，而且也不是以.开头命名，咋搞呢？</p><p>不卖关子了，经过我简单查询，有一种比较简单且行之有效的方式：那就是新建一个.hidden的文件，里面写入你想隐藏的文件或文件夹名字就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jwang@jun:/media/jwang/Data$ cat .hidden </span><br><span class="line"><span class="variable">$RECYCLE</span>.BIN</span><br><span class="line">System Volume Information</span><br></pre></td></tr></table></figure><p>最后，经过我调研总结，Ubuntu的Nautilus文件管理器不显示以下3种文件：</p><ul><li>隐藏文件，即文件名以 (.) 开头的文件。</li><li>备份文件，即文件名以 (~) 结尾的文件。</li><li>在指定文件夹中的 .hidden 文件里列出的文件。</li></ul><p>如果有遇到类似问题的小伙伴可以参考一下了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何在Ubuntu自带的文件夹管理器Nautilus里面隐藏文件或文件夹呢？&lt;/p&gt;
&lt;p&gt;先说一下背景，之所以想到这个问题是因为我的电脑是 Win10+Ubuntu 双系统，有一块硬盘是共享的NTFS格式，在Windows下面分区会有2个文件夹，了解Windows的人应该知道，这是垃圾回收站和磁盘卷信息。&lt;/p&gt;
&lt;p&gt;默认情况下在Windows里面这2个文件夹是隐藏的，但是当我切换到Ubuntu的时候，Ubuntu就会给显示出来了，这倒也正常，但是看起来很碍事，不爽，既然不爽我就要搞它。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://wangbjun.site/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://wangbjun.site/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="https://wangbjun.site/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Golang常见加密算法实现</title>
    <link href="https://wangbjun.site/2020/coding/golang/crypt.html"/>
    <id>https://wangbjun.site/2020/coding/golang/crypt.html</id>
    <published>2020-03-08T09:02:00.000Z</published>
    <updated>2020-03-09T01:56:24.579Z</updated>
    
    <content type="html"><![CDATA[<p>说完Go里面的md5的用法，这篇文章咱说说用的比较多的加密方式在Go里面如何实现。首先，科普一下，一般待加密的内容被叫作明文，加密使用的关键元素被称为秘钥，加密的结果被称为密文，当然其中还有一个非常关键的加密算法。</p><p>一般加密算法可分为对称加密和非对称加密这两个分类，这两者区别很明显，对称加密是指我们拿到秘钥和密文可以解密出明文，在加密和解密时使用的是同一个秘钥；而非对称加密算法需要两个密钥来进行加密和解密，这两个密钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。</p><a id="more"></a><p>本篇文章不是讲如何在Go里面实现这些加密算法，仔细看一下Go标准库里面<strong>crypto</strong>库，你会发现其实Go已经实现很多了加密算法，但是很多人不知道咋用，正如MD5算法一样，它没有提供一个非常简单易用的对外接口，需要你自己再封装一遍，这一点非常不好。。。</p><img src="/images/2020-03-08_17-00.png" /><p>今天我们主要说两种最常用的加密算法：AES对称加密、RSA非对称加密。</p><h2 id="AES对称加密"><a href="#AES对称加密" class="headerlink" title="AES对称加密"></a>AES对称加密</h2><p>AES（Advanced Encryption Standard）是最常见的对称加密算法，但是这个算法分很多模式，不同模式的实现方式又有很大差异，比如ECB、CBC、OFB、CFB，详细技术细节这里就不多说了。</p><p>有几点需要注意，AES对加密key的长度要求必须固定为16、24、32位，也就是128、192、256比特，所以又有一个AES-128、AES-192、AES-256这种叫法，位数越大安全性越高但加密速度越慢。最关键是对明文长度也有要求，必须是分组长度长度的倍数，AES加密数据块分组长度必须为128bit也就是16位，所以这块又涉及到一个填充问题，而这个填充方式可以分为PKCS7和PKCS5等方式，不得不说是真麻烦。</p><p>本文以CBC模式为例来介绍，CBC又有点特殊，它需要一个iv偏移量，iv不一样，结果也不一样所以更安全,这个偏移量必须和分组大小长度一样，也是16位，其实如何去生成iv和填充明文才是最麻烦的地方，但标准库里面并没有给出示例，我网上找了下，先看一个简单的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AesCBCEncrypt</span><span class="params">(plainText []<span class="keyword">byte</span>, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="comment">// 生成加密用的block</span></span><br><span class="line">    block, err := aes.NewCipher(key)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对IV有随机性要求，但没有保密性要求，所以常见的做法是将IV包含在加密文本当中</span></span><br><span class="line">    cipherText := <span class="built_in">make</span>([]<span class="keyword">byte</span>, aes.BlockSize+<span class="built_in">len</span>(plainText))</span><br><span class="line">    iv := cipherText[:aes.BlockSize]</span><br><span class="line">    <span class="keyword">if</span> _, err := io.ReadFull(rand.Reader, iv); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    mode := cipher.NewCBCEncrypter(block, iv)</span><br><span class="line">    mode.CryptBlocks(cipherText[aes.BlockSize:], plainText)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cipherText</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际应用中，秘钥我们可以指定为固定位数，但是需要加密的内容往往是不固定长度的，所以需要做填充，同时在解密的时候就需要去除填充，这里总结了2种填充方法，一个是PKCS7，网上也有些文章称之为PKCS5，另一个是0填充。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PKCS7Padding</span><span class="params">(src []<span class="keyword">byte</span>, blockSize <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    padding := blockSize - <span class="built_in">len</span>(src)%blockSize</span><br><span class="line">    padText := bytes.Repeat([]<span class="keyword">byte</span>&#123;<span class="keyword">byte</span>(padding)&#125;, padding)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(src, padText...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PKCS7UnPadding</span><span class="params">(origData []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(origData)</span><br><span class="line">    unpadding := <span class="keyword">int</span>(origData[length<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> origData[:(length - unpadding)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ZeroPadding</span><span class="params">(src []<span class="keyword">byte</span>, blockSize <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    padding := blockSize - <span class="built_in">len</span>(src)%blockSize</span><br><span class="line">    padText := bytes.Repeat([]<span class="keyword">byte</span>&#123;<span class="number">0</span>&#125;, padding)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(src, padText...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ZeroUnPadding</span><span class="params">(origData []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bytes.TrimFunc(origData,</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">            <span class="keyword">return</span> r == <span class="keyword">rune</span>(<span class="number">0</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解密的过程首先是要提取出iv，然后解密，最后去除填充得到明文，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AesCBCDecrypt</span><span class="params">(cipherText []<span class="keyword">byte</span>, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    block, err := aes.NewCipher(key)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(cipherText) &lt; aes.BlockSize &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"cipher text too short"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    iv := cipherText[:aes.BlockSize]</span><br><span class="line">    cipherText = cipherText[aes.BlockSize:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(cipherText)%aes.BlockSize != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"cipher text is not a multiple of the block size"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mode := cipher.NewCBCDecrypter(block, iv)</span><br><span class="line">    mode.CryptBlocks(cipherText, cipherText)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cipherText</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，咱们来看一个简单的使用示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 需要被加密的内容，需要填充</span></span><br><span class="line">    <span class="keyword">var</span> src = <span class="string">"Hello，我是一个测试加密内容你知道吗？？？"</span></span><br><span class="line">    <span class="comment">// key必须是16\24\32位</span></span><br><span class="line">    <span class="keyword">var</span> key = <span class="string">"1234567890123456"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用了PKCS7填充法</span></span><br><span class="line">    cipherText := AesCBCEncrypt(PKCS7Padding([]<span class="keyword">byte</span>(src), aes.BlockSize), []<span class="keyword">byte</span>(key))</span><br><span class="line">    <span class="comment">// 为方便展示，用base64编码</span></span><br><span class="line">    fmt.Printf(<span class="string">"cipherText text is %s\n"</span>, base64.StdEncoding.EncodeToString(cipherText))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密</span></span><br><span class="line">    plainText := AesCBCDecrypt(cipherText, []<span class="keyword">byte</span>(key))</span><br><span class="line">    fmt.Printf(<span class="string">"plain text is %s\n"</span>, PKCS7UnPadding(plainText))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 由于每次iv是随机的，所以结果都不一样，但是解密之后的明文都正确</span></span><br><span class="line"><span class="comment">// cipherText text is gFGf2lw9EQzQGxUtJGFQWDOaP3uU9CVWvLWCpSbeb9zrJqLUbSjS6d6GljtleGCFPFLWZZZ4a1RvKxR8wVT0d/U0cn8F4nwhEnun4Ba3t0M=</span></span><br><span class="line"><span class="comment">// plain text is Hello，我是一个测试加密内容你知道吗？？？</span></span><br></pre></td></tr></table></figure><h2 id="RSA非对称加密"><a href="#RSA非对称加密" class="headerlink" title="RSA非对称加密"></a>RSA非对称加密</h2><p>RSA非对称加密需要一对秘钥，一个公钥，一个私钥，公钥加密之后私钥才能解密，私钥加密之后公钥才能解密，其最广泛的应用莫过于https、ssh，安全性高，但是速度相对较慢。</p><p>首先，我们得生成一对秘钥，方法有很多种，我们可以用工具生成，比如在Linux下面可以使用openssl命令生成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成私钥</span></span><br><span class="line">openssl genrsa -out private.pem 2048</span><br><span class="line"><span class="comment"># 生成公钥</span></span><br><span class="line">openssl rsa -<span class="keyword">in</span> private.pem -outform PEM -pubout -out public.pem</span><br></pre></td></tr></table></figure><p>也可以使用一些工具生成，保存起来，值得一提的是这个秘钥的格式还有很多说法，这里暂不细说，如果遇到问题了，不妨留意一下。</p><p>Go的crypto库提供了一些方法来进行rsa的加密和解密操作，不过同样我们还得自己组装起来，先看一下加密：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RsaEncrypt</span><span class="params">(plainText []<span class="keyword">byte</span>, keyPath <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="comment">// 读取公钥</span></span><br><span class="line">    file, _ := os.Open(keyPath)</span><br><span class="line">    fileInfo, _ := file.Stat()</span><br><span class="line">    data := <span class="built_in">make</span>([]<span class="keyword">byte</span>, fileInfo.Size())</span><br><span class="line">    _, _ = file.Read(data)</span><br><span class="line">    <span class="comment">// pem解码</span></span><br><span class="line">    block, _ := pem.Decode(data)</span><br><span class="line">    publicKey, err := x509.ParsePKIXPublicKey(block.Bytes)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    cipherText, err := rsa.EncryptPKCS1v15(rand.Reader, publicKey.(*rsa.PublicKey), plainText)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cipherText</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是解密：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RsaDecrypt</span><span class="params">(cipherText []<span class="keyword">byte</span>, keyPath <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="comment">// 读取私钥</span></span><br><span class="line">    file, _ := os.Open(keyPath)</span><br><span class="line">    fileInfo, _ := file.Stat()</span><br><span class="line">    data := <span class="built_in">make</span>([]<span class="keyword">byte</span>, fileInfo.Size())</span><br><span class="line">    _, _ = file.Read(data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pem解码</span></span><br><span class="line">    block, _ := pem.Decode(data)</span><br><span class="line">    privateKey, err := x509.ParsePKCS1PrivateKey(block.Bytes)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    plainText, err := rsa.DecryptPKCS1v15(rand.Reader, privateKey, cipherText)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> plainText</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综合示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> src = <span class="string">"1234567890"</span></span><br><span class="line">    cipherText := RsaEncrypt([]<span class="keyword">byte</span>(src), <span class="string">"/path/to/public.pem"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base64编码输出</span></span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, base64.StdEncoding.EncodeToString(cipherText))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密</span></span><br><span class="line">    plainText := RsaDecrypt(cipherText, <span class="string">"/path/to/private.pem"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, plainText)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RSA加密每次的结果都不一样，安全性虽高，但是也有缺点，速度慢，而且加密的内容不能太大，最大不能超过秘钥的长度，比如说这个例子里面秘钥是2048位的，也就是256字节，如果超过了可能就需要你特殊处理了，比如分割成多段依次加密。</p><p>总之，在Go里面使用加密的话需要根据实际情况调整，不同加密方式的实现细节有很多不一样的地方，好在标准库大部分都实现了，只需要我们花点功夫研究一下咋去使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说完Go里面的md5的用法，这篇文章咱说说用的比较多的加密方式在Go里面如何实现。首先，科普一下，一般待加密的内容被叫作明文，加密使用的关键元素被称为秘钥，加密的结果被称为密文，当然其中还有一个非常关键的加密算法。&lt;/p&gt;
&lt;p&gt;一般加密算法可分为对称加密和非对称加密这两个分类，这两者区别很明显，对称加密是指我们拿到秘钥和密文可以解密出明文，在加密和解密时使用的是同一个秘钥；而非对称加密算法需要两个密钥来进行加密和解密，这两个密钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="https://wangbjun.site/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.site/tags/Golang/"/>
    
      <category term="RSA" scheme="https://wangbjun.site/tags/RSA/"/>
    
      <category term="AES" scheme="https://wangbjun.site/tags/AES/"/>
    
  </entry>
  
  <entry>
    <title>Golang计算文件MD5</title>
    <link href="https://wangbjun.site/2020/coding/golang/file-md5.html"/>
    <id>https://wangbjun.site/2020/coding/golang/file-md5.html</id>
    <published>2020-03-07T02:42:22.000Z</published>
    <updated>2020-03-09T01:56:24.583Z</updated>
    
    <content type="html"><![CDATA[<p>前面这篇文章<a href="https://wangbjun.site/2020/coding/golang/md5.html">&lt;Golang里面MD5的写法和性能&gt;</a>介绍了如何计算字符串的md5，下面我们来说说如何计算文件的md5。</p><a id="more"></a><h2 id="1-错误的方式"><a href="#1-错误的方式" class="headerlink" title="1.错误的方式"></a>1.错误的方式</h2><p>有人说，文件可以读取成字符串，然后再计算就可以了，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FileMD5</span><span class="params">(filePath <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    file, err := os.Open(filePath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    all, err := ioutil.ReadAll(file)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MD5(<span class="keyword">string</span>(all)), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法确实没问题，但是需要考虑一个问题，假如文件比较大呢？比如有好几个GB，如果按这个做法也得占用好几个GB内存，肯定存在问题。</p><p>经过我测试，在实际运行中，这种方式占用的内存是文件大小的好几倍，1个GB的文件需要大概4个GB的内存，太恐怖了。</p><h2 id="2-正确的方式"><a href="#2-正确的方式" class="headerlink" title="2.正确的方式"></a>2.正确的方式</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FileMD5</span><span class="params">(filePath <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    file, err := os.Open(filePath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    hash := md5.New()</span><br><span class="line">    _, _ = io.Copy(hash, file)</span><br><span class="line">    <span class="keyword">return</span> hex.EncodeToString(hash.Sum(<span class="literal">nil</span>)), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过实际测试发现占用内存几乎非常非常少，这里大家就会发现md5.New()的用途所在了，简单分析一下为什么这种方式占用内存少。</p><p>首先要了解<strong>io.Copy</strong>方法的含义，可以先看看注释：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy copies from src to dst until either EOF is reached</span></span><br><span class="line"><span class="comment">// on src or an error occurs. It returns the number of bytes</span></span><br><span class="line"><span class="comment">// copied and the first error encountered while copying, if any.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A successful Copy returns err == nil, not err == EOF.</span></span><br><span class="line"><span class="comment">// Because Copy is defined to read from src until EOF, it does</span></span><br><span class="line"><span class="comment">// not treat an EOF from Read as an error to be reported.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If src implements the WriterTo interface,</span></span><br><span class="line"><span class="comment">// the copy is implemented by calling src.WriteTo(dst).</span></span><br><span class="line"><span class="comment">// Otherwise, if dst implements the ReaderFrom interface,</span></span><br><span class="line"><span class="comment">// the copy is implemented by calling dst.ReadFrom(src).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(dst Writer, src Reader)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> copyBuffer(dst, src, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出来，它底层调用了一个copyBuffer，这个方法底层在copy的时候会临时分配一个buffer缓存区，默认大小32k，每次只会占用32k大小内存，如果想自定义缓存区大小可以使用<strong>CopyBuffer</strong>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CopyBuffer is identical to Copy except that it stages through the</span></span><br><span class="line"><span class="comment">// provided buffer (if one is required) rather than allocating a</span></span><br><span class="line"><span class="comment">// temporary one. If buf is nil, one is allocated; otherwise if it has</span></span><br><span class="line"><span class="comment">// zero length, CopyBuffer panics.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyBuffer</span><span class="params">(dst Writer, src Reader, buf []<span class="keyword">byte</span>)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> buf != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(buf) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"empty buffer in io.CopyBuffer"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copyBuffer(dst, src, buf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后配合Sum方法，每次计算32k，不断循环计算，直到算完，所以几乎不占用内存。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>如果计算的文件都是小文件，内存比较大的话，追求速度的话可以使用第一种方法，如果你计算的文件非常大，务必使用第二种方法，不然内存会爆掉。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面这篇文章&lt;a href=&quot;https://wangbjun.site/2020/coding/golang/md5.html&quot;&gt;&amp;lt;Golang里面MD5的写法和性能&amp;gt;&lt;/a&gt;介绍了如何计算字符串的md5，下面我们来说说如何计算文件的md5。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="https://wangbjun.site/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.site/tags/Golang/"/>
    
      <category term="MD5" scheme="https://wangbjun.site/tags/MD5/"/>
    
  </entry>
  
  <entry>
    <title>Golang计算MD5的写法和性能</title>
    <link href="https://wangbjun.site/2020/coding/golang/md5.html"/>
    <id>https://wangbjun.site/2020/coding/golang/md5.html</id>
    <published>2020-03-05T13:10:00.000Z</published>
    <updated>2020-03-09T01:56:24.571Z</updated>
    
    <content type="html"><![CDATA[<p>用过PHP的童鞋知道在PHP里面md5很简单，是一个内置函数，可以直接调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jwang@jun:~$ php -a</span><br><span class="line">Interactive mode enabled</span><br><span class="line"></span><br><span class="line">php &gt; <span class="built_in">echo</span> md5(<span class="string">"12345"</span>);</span><br><span class="line">827ccb0eea8a706c4c34a16891f84e7b</span><br></pre></td></tr></table></figure><p>纠正一个错误的说法，很多人一直把md5叫作加密算法，实际上md5并不是加密，它既不是对称加密，也不是非对称加密，它只是一个摘要函数，一般被用于签名或者校验数据完整性。</p><p>虽然现在有文章说不推荐使用md5了，因为碰撞几率比较大，实际上，这个几率非常非常非常低，大只是相对于其它摘要函数来说，纯自然的情况下基本不可能碰撞，虽然可以用工具构造出来，但非常复杂。如果实在不放心，可以用sha1或者sha256，或者两者集合起来用，速度会慢一点，但安全性高一点，总之，md5由于速度快，简单易用，现在用的还是蛮多的。</p><a id="more"></a><p>言归正传，在Go的标准库里面并没有md5这个函数，但是在<strong>crypto</strong>包里面确实有相关实现，需要自己动手组装拼凑一下，网上流传的写法有很多种：</p><h2 id="1-第一种"><a href="#1-第一种" class="headerlink" title="1.第一种"></a>1.第一种</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MD5</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    hash := md5.New()</span><br><span class="line">    _, err := hash.Write([]<span class="keyword">byte</span>(s))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    sum := hash.Sum(<span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%x\n"</span>, sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>平时用到可能只是copy过来，没仔细看，今天来仔细看一下，首先，这个 md5.New() 返回的是一个结构体 digest：</p><img src = "/images/2020-03-06_21-34.png" /><p>这个结构体成员啥意思呢？其实细说起来，这和md5的算法有关了，咱也不知道，咱也不敢问！</p><p>但是仔细看一下这个结构体的方法，你会发现有一个叫Write，还有一个叫Sum，如果你英语不错，你可以看懂，Write就是把数据写到刚才这个结构体里面，先甭管它咋写，肯定是有算法规则，感兴趣可以研究研究。Sum稍微有点不一样，但是有一个参数，和一个返回值，这个方法的意思是把参数追加到进去并且返回摘要，由于我们之前已经写进去了，所以参数为nil即可。</p><img src = "/images/2020-03-06_21-39.png" /> <p>可见，一个md5方法Go就整了6行代码，老板看你代码写这么多，又可以加薪了，Go确实是好语言。</p><h2 id="2-第二种"><a href="#2-第二种" class="headerlink" title="2.第二种"></a>2.第二种</h2><p>如果你仔细看了这个包里面的 md5.go 文件，你会发现最下面有一个公开的方法Sum，仔细一看，这就是刚才我写的那个简化版：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sum returns the MD5 checksum of the data.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(data []<span class="keyword">byte</span>)</span> [<span class="title">Size</span>]<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> d digest</span><br><span class="line">    d.Reset()</span><br><span class="line">    d.Write(data)</span><br><span class="line">    <span class="keyword">return</span> d.checkSum()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们的方法可以简化为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MD5</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    sum := md5.Sum([]<span class="keyword">byte</span>(s))</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%x\n"</span>, sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然sum变量在这２个方法里面都是多余的，可以简化为一行代码即可。</p><h2 id="3-第三种"><a href="#3-第三种" class="headerlink" title="3.第三种"></a>3.第三种</h2><p>还有一种方式是使用io库的方法往里面写，主要是因为degest实现了<strong>io.Writer</strong>接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MD5</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    hash := md5.New()</span><br><span class="line">    _, _ = io.WriteString(hash, s)</span><br><span class="line">    <span class="keyword">return</span> hex.EncodeToString(hash.Sum(<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最后Sprintf方法是为了把结果转化成小写十六进制，也可以用<strong>hex.EncodeToString</strong>方法替代。</p><h2 id="4-性能对比"><a href="#4-性能对比" class="headerlink" title="4.性能对比"></a>4.性能对比</h2><p>这几种方式大同小异，理论上讲应该没有什么性能差距，不过既然Go自带Benchmark，我们就测一下吧：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMD5</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        MD5(<span class="string">"12345678901234567890"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jwang@jun:~/Documents/Work/learnGo/Std/md5$ go <span class="built_in">test</span> -bench=.</span><br><span class="line">goos: linux</span><br><span class="line">goarch: amd64</span><br><span class="line">BenchmarkMD5_1-12       10000000               359 ns/op</span><br><span class="line">BenchmarkMD5_2-12       10000000               356 ns/op</span><br><span class="line">BenchmarkMD5_3-12       10000000               163 ns/op</span><br><span class="line">BenchmarkMD5_4-12       10000000               296 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      _/home/jwang/Documents/Work/learnGo/Std/md5     11.757s</span><br></pre></td></tr></table></figure><p>不测不知道，一测吓一跳，其实前2个方法差不多很正常，但是第三个方法性能很好，其主要原因是因为Sprintf的性能比较差导致，不过<strong>md5.New()</strong>这种写法也比较慢。</p><h2 id="5-最佳写法"><a href="#5-最佳写法" class="headerlink" title="5.最佳写法"></a>5.最佳写法</h2><p>最终得出结论，性能最高的md5写法是这种，推荐大家使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MD5</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span>  &#123;</span><br><span class="line">    sum := md5.Sum([]<span class="keyword">byte</span>(s))</span><br><span class="line">    <span class="keyword">return</span> hex.EncodeToString(sum[:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-Sha1"><a href="#6-Sha1" class="headerlink" title="6.Sha1"></a>6.Sha1</h2><p>最后说个题外话，Go里面Sha1的写法和Md5几乎一致，只需要要把md5改成sha1即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sha1</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span>  &#123;</span><br><span class="line">    sum := sha1.Sum([]<span class="keyword">byte</span>(s))</span><br><span class="line">    <span class="keyword">return</span> hex.EncodeToString(sum[:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我也测了一下性能，它们之间的差距很小，md5是163ns/op，sha1是206ns/op，毕竟sha1比md5长一点。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用过PHP的童鞋知道在PHP里面md5很简单，是一个内置函数，可以直接调用：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;jwang@jun:~$ php -a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Interactive mode enabled&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;php &amp;gt; &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; md5(&lt;span class=&quot;string&quot;&gt;&quot;12345&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;827ccb0eea8a706c4c34a16891f84e7b&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;纠正一个错误的说法，很多人一直把md5叫作加密算法，实际上md5并不是加密，它既不是对称加密，也不是非对称加密，它只是一个摘要函数，一般被用于签名或者校验数据完整性。&lt;/p&gt;
&lt;p&gt;虽然现在有文章说不推荐使用md5了，因为碰撞几率比较大，实际上，这个几率非常非常非常低，大只是相对于其它摘要函数来说，纯自然的情况下基本不可能碰撞，虽然可以用工具构造出来，但非常复杂。如果实在不放心，可以用sha1或者sha256，或者两者集合起来用，速度会慢一点，但安全性高一点，总之，md5由于速度快，简单易用，现在用的还是蛮多的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="https://wangbjun.site/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.site/tags/Golang/"/>
    
      <category term="MD5" scheme="https://wangbjun.site/tags/MD5/"/>
    
  </entry>
  
  <entry>
    <title>如何高效的学习编程？</title>
    <link href="https://wangbjun.site/2020/life/how-to-learn.html"/>
    <id>https://wangbjun.site/2020/life/how-to-learn.html</id>
    <published>2020-03-03T04:48:37.000Z</published>
    <updated>2020-03-09T02:01:50.180Z</updated>
    
    <content type="html"><![CDATA[<p>今天想聊一聊学习这个话题，理想情况下，每个人都应该有适合自己的一套学习方法和节奏，主要因为不同人对知识的理解和吸收速度不一样，举个非常简单的例子，在网上看视频或者电影，有些人觉得2倍速播放刚刚好，而有些人甚至还要降速才能看明白，才能Get到点。即便如此，我觉得有些学习的经验和方法是可以共享的，虽然它不一定适合所有人。</p><p>人一生都在学习，学习不一定是在课堂上，特别是在互联网时代，我们可以随时随地打开手机观看各种课程，尤其是在编程行业，更需要不断持续的学习才能保持竞争力。我也是自学入行编程，期间也看过很多网上的视频教程，平时学习的时候也经常看一些博客教程，可以说现在也基本上是靠自学成长，颇有感触。</p><a id="more"></a><p>在学生时代，我也算是班级里面名列前茅的选手，在别人眼里我很厉害，每次考试都能考一个非常高的分数，但是我自己却感觉很轻松，我每天和其它同学一样，一起上课学习、按时完成老师安排的作业，没有什么额外的事情。而我周围的也有些同学非常努力，早起晚睡，周末还会上家教，但成绩却一般般。举一个不太恰当的例子，10万块钱在你眼里可能是巨款，但是在有钱人的眼里那只是零花钱。所以在一些牛人的眼里有些问题太简单了，他们可以分分钟钟给你手写一个翻转二叉树算法，这真的不是他们很努力，有些只不过是天分而已，而你刷了几百遍leetcode依然达不到人家的水平。</p><p>正视智商上的差距并不意味着努力没用，因为在大部分时候，我们远远没有达到需要拼智商的地步，努力能够弥补很多差距，即使智商很高的人也需要努力，不然也就是当代“伤仲永”而已。</p><h1 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h1><p>在我很早学习Java的时候，我在网上看过一个叫韩顺平的人的视频教程，他在开课之前有一小节专门讲了如何高效的学习编程这个话题，他总结了几个点，我觉得非常有道理，后来得知，他不仅仅教Java，也教PHP、Linux、Go，但是每次开课的时候都会讲一下这几点学习方法，个人感觉这几点讲的非常好，这里和大家分享一下：</p><img src="/images/2020-03-03-1.png" /> <ul><li><p>高效而愉快的学习</p></li><li><p>先建立一个整体的框架，然后细节</p></li><li><p>在实际工作中，要培养用到什么，能够快速学习的能力</p></li><li><p>先know how，再know why</p></li><li><p>软件编程是一门“做中学”的学科，不是会了再做，而是做了才会</p></li><li><p>适当的囫囵吞枣</p></li><li><p>学习软件编程是在琢磨别人怎么做，而不是我认为应该怎么做的过程</p></li></ul><blockquote><p>韩顺平是清华大学毕业，之前一直在某智任教，后来听说自己开设了一个培训班，但是经营不善倒闭了，现在又重返课堂了。</p></blockquote><p>仔细想一下，这些点讲的非常有道理，很多人在学习的时候往往忽视了整体，盯着一个点在那死磕，有点盲人摸象的感觉，比如你要学习使用一门语言，你首先应该知道这门语言适合干啥，然后再去了解大体有哪些特点，再去写一个最简单的例子，学习基本语法，具体的细节等以后渐渐熟悉了再去学习。</p><p>我们不能要求自己一上来就把所有的功能都学会了再做事情，编程行业发展到现在每一个细分领域只要你想去研究学习都有一大堆东西，需要大量时间，很多东西都是发展了很多年不断迭代的结果。你不能要求自己一上来就写一个没有bug、面面俱到的代码，但是你可以去不停改进优化你的代码。</p><p>What？Why？How？是什么？为什么？怎么用？这一条几乎可以适用于各行各业,我见过很多人，一上来就对着教程照葫芦画瓢，完全没有理解，效率自然不高。</p><h1 id="类比"><a href="#类比" class="headerlink" title="类比"></a>类比</h1><p>学习最快的方法就是用一个已知的东西去理解一个未知的东西，这个方法大部分情况下都是可用的，比如说你学习完了PHP再去学习Java或者Go，你会发现基本语法差不多，所以上手很快。</p><p>在编程行业，很多经验都是相互借鉴的，比如说PHP的composer和Node的npm它们都是一个包管理工具，是用来解决包依赖问题，一样功能的还有Linux操作系统里面apt和yum。编程里面常常提到的设计模式就是一种共同性的思想，虽然不同语言的具体实现可能有所差异。</p><p>即使不是同一个行业，也有些思想可以借鉴，比如，有人在讲述buffer和cache的区别的时候举了一个这样的例子，cache就相当于京东在每个城市周边的仓库，它可以快速的把你买的东西寄到你手上而不用从厂家发货。</p><p>但IT行业是一个非常喜欢吹牛逼的行业，经常会发明一些新鲜的词汇来唬人，比如云计算、云原生、5G云、大数据、人工智能等等。可能这个和风投资本有关，创业的人需要拿出一些看起来很厉害的东西唬住投资人，如果你仔细了解过这些“高大上”的词汇背后，你会发现其实还是熟悉的东西。</p><h1 id="网课"><a href="#网课" class="headerlink" title="网课"></a>网课</h1><p>现在知识付费非常火，卖课的广告到处都是，很多技术公众号天天也在贩卖焦虑，然后卖课。卖网课几乎是一个一本万利的生意，你只要录制一次就可以卖给N人，相对于书本来说，连印刷的成本都省了。</p><p>在早期我也看过很多视频教程，很多确实非常有用。但我现在看来，视频这种形式比较适合入门初学者，它可以快速的帮助你了解学习一门知识，特别是你啥也不会的时候，跟着视频学会快很多。</p><p>但是当你进入一个行业几年之后，视频课程基本上不是一个很好的选择了，大部分课程讲的东西都比较宽泛和全面，实际上你不一定用得到，很多人就听了一些公众号的忽悠，买了很多课，有些根本没时间看，有些看完时间一久就忘了。所以我建议还是得结合实际应用有针对性的去学习，很多优秀的开源项目的官方文档已经写的非常清楚了，有些怕你不会用连demo都给你写好了。</p><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p>记笔记是个好习惯，我记得以前上学的时候很多同学记笔记记的非常认真，老师在黑板上写，同学都在下面抄，一字不漏。老师经常说让大家不要照抄，不要把时间浪费在抄笔记上面，要多注意老师讲的东西。毕竟那会教育条件很差，现在估计学校里面应该都是直接投影仪放PPT了，学生也不用抄笔记了，直接拷贝就行了。</p><p>不过我还是建议大家有时间可以写点总结性的笔记，也可以叫作博客，不一定要写出多么有深度，你只需要记录自己学到一些东西或者自己的一些想法即可，因为有时候很多东西你感觉你自己学到了，但是让你写出来就会不一样了，写作的过程通常也是一个思考的过程，有助于查漏补缺。</p><p>所以如果有时间，建议抽出时间不妨就某一个技术点写出你自己的理解，写得好还是可以帮助别人，何乐不为呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天想聊一聊学习这个话题，理想情况下，每个人都应该有适合自己的一套学习方法和节奏，主要因为不同人对知识的理解和吸收速度不一样，举个非常简单的例子，在网上看视频或者电影，有些人觉得2倍速播放刚刚好，而有些人甚至还要降速才能看明白，才能Get到点。即便如此，我觉得有些学习的经验和方法是可以共享的，虽然它不一定适合所有人。&lt;/p&gt;
&lt;p&gt;人一生都在学习，学习不一定是在课堂上，特别是在互联网时代，我们可以随时随地打开手机观看各种课程，尤其是在编程行业，更需要不断持续的学习才能保持竞争力。我也是自学入行编程，期间也看过很多网上的视频教程，平时学习的时候也经常看一些博客教程，可以说现在也基本上是靠自学成长，颇有感触。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Life" scheme="https://wangbjun.site/categories/Life/"/>
    
    
      <category term="学习" scheme="https://wangbjun.site/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>谈一谈阿里外包工作</title>
    <link href="https://wangbjun.site/2020/life/2019-4.html"/>
    <id>https://wangbjun.site/2020/life/2019-4.html</id>
    <published>2020-03-01T02:00:00.000Z</published>
    <updated>2020-03-09T02:01:50.180Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过几篇文章名字叫<a href="https://wangbjun.site/2020/life/2019-1.html">《一个野生程序员的北漂之路》</a>，这篇文章应该算是后续吧，聊聊我如何进阿里外包，主要是结合我的经历和我所了解的一些事实谈谈我的感受和看法，仅供其他朋友参考。</p><h2 id="上家公司残局"><a href="#上家公司残局" class="headerlink" title="上家公司残局"></a>上家公司残局</h2><p>看过前面文章的人应该知道我上一家公司因为是P2P行业受到打击，目前已经处于立案阶段，整个公司几百员工都失业了，我也不例外。刚开始我对公司还抱有希望，在家休息等待了2周之后我才明白公司是真的没了，自己找工作吧，当时公司为了不仅欠了我们半月工资，而且连社保也没钱缴纳（财务账户被冻结），甚至都无法给员工办理离职（公章被扣押），没人有操心这几百号员工怎么办，但是社保断了对很多人有很大影响，很多人都在问怎么办，最后公司的HR出来告诉我们可以自己找人代缴，但是由考虑到风险，需要员工签一个离职声明，然后公司才可以把社保做减员处理，于是大家争相签离职声明。</p><a id="more"></a><p>签了这个声明之后，基本上就和公司没关系了，但是公司无法开离职证明，所以找工作的时候得自己解决。其实从法律上说离职证明不是必须的，不过从公司的角度说，如果你同时在2家公司任职会对公司不利，有些公司会让你签一个免责声明，但不同公司的要求不一样，有些公司比较看重。</p><h2 id="面试经历"><a href="#面试经历" class="headerlink" title="面试经历"></a>面试经历</h2><p>后来，我出去面试了一周，面了10来家公司，有些是小公司，但是也有一些相对大一点的公司，比如百度、360等，面试的岗位有PHP和GO，不过最终结果都一样。一开始我就不抱太大期望，因为这会距离过年只有20天左右，年终招人的公司并不多，很明显有些公司就是走过场或者传说中的刷KPI。</p><p>前面说过，我自己的硬件条件很差：非科班、非重点、转行，而且之前的工作履历也一般，很多面试官拿到简历问我是什么专业，一听是非计算机专业就立马不一样了，其中有一个面试官比较实诚，直接和我说你这个专业让我觉得不踏实。另外就是，我自己准备的也不够充分，实力有限，打扰了，可能他们想招的都是高端人才，我要求工资上限才达到他们的下限。</p><p>但也有比较Nice的面试官，比如百度的，当时是去面的百度文库，PHP在百度有大规模应用招人还是挺多的（后续和面试官聊的时候发现也在转Go），聊的时候期间我问了一个有意思的问题，我说：“听说大厂用PHP和一般公司都不是一个用法，你们都是用的扩展，是真的吗？”他说也并不是，只有极少数对性能要求非常高的模块会用扩展写，大部分都是普通PHP代码，但是我们用的是自己写的框架。二面的应该是一个leader，一开始就问了一些非技术内容，然后问了一些技术内容，还让在纸上写一些东西，不过一个快排算法没写出来，那天刚好是元旦前一天，面试官说：“今天是2019年最后一天，非常有意义，马上下班去跨年了，如果你刚才那个算法写好了我就让你过了，不过也不一定，我待会和一面沟通一下，有消息再通知你”。虽然凉了，但是百度这2个面试官给我感觉比较尊重人，面试过程比较轻松，不像是有些公司的面试官盛世凌人，比如在问到我不会的问题时，我通常会说这块我确实没了解过，您能不能大概给我介绍下？很多面试官会说自己回去百度、自己回去再看看吧，极少数会给你解答。</p><h2 id="技术水平"><a href="#技术水平" class="headerlink" title="技术水平"></a>技术水平</h2><p>有一个问题特别有意思，在和百度一面聊的时候，他问我你觉得自己技术大概在什么水平，这个问题也有很多面试官问过，我一般会说中级，他说我觉得你差不多能达到高级、中高级，我说高级那不得熟知源码，他说熟知源码那得资深了。我并不太了解这个等级划分，我一般理解会有3个档次，初、中、高级，比如很多招聘会写高级开发工程师，但是不同公司的标准好像不一样，百度会有自身的T级别，而阿里则有P级别，比如在阿里，p5一般是高级，p6资深，p7技术专家，我猜那个面试官说的应该是按百度级别划分，但百度的我没了解。我记得有一次一个面试官问过我如果我要到资深的水平需要多久，我说大概要10年，但是我这时候理解的资深是相当于最高级的技术水平。不过有一点大家需要了解，国内很多大厂的技术定级，并不是完全是看技术，越往上往往靠的是管理，纯技术基本上没有活路。</p><h2 id="为什么要进外包？"><a href="#为什么要进外包？" class="headerlink" title="为什么要进外包？"></a>为什么要进外包？</h2><p>说到外包，其实一开始我是拒绝的，直到我有一个朋友在阿里外包（Web前端），她们是和阿里正式员工一起办公，外包公司是南京的一家公司，社保也不是最低缴纳，工作还挺轻松，一般晚上准时6点半下班，周末双休，极少加班，加班可以调休，看上去并不是很差。我知道，网上一直对IT外包评价非常差，99%的人不建议去外包岗位，除非无路可去，否则不要考虑外包，所以以前找工作的时候只要是外包的我一概不考虑，但是这次我想试一试。</p><p>抱着试试看的态度，我答应了一家武汉的外包公司的面试，面试岗位是阿里某部门Go语言的项目，其中主要原因是我对Go比较感兴趣，也想写Go。面试是电话面试，前后来了2个，电话都是来自杭州阿里巴巴的，如果说我找工作面其它公司的难度是10，那么外包可能只有3，结果很顺利的就到了谈薪的阶段，果不其然，工资确实压的很低，而且其它待遇基本为0。外包好像都会有一个套路，那就是开始给你压到很低，如果你不同意他们就会说我帮你申请特批，但是即使明面上的薪资达到了我的要求，但是其它福利基本为0，本质上还是降薪了。这里其它福利就是5险一金最低缴纳、没有任何补助、只有12薪、没有年终奖和奖金。</p><p>我在面外包之前也做了一些功课，比如和你聊的人，也就是外包的人事专员他们只负责招聘，招聘入职之后就和她没有什么关系了，他们一般会和你说一些“空大假”话，最常见的就是进大厂外包表现的好有可能转正，但是据我了解，这个概率很低，而且基本上是副作用，如果你想正式进大厂，反而不能去外包，其实并不是技术原因。有网友说，如果一个外包员工辞职之后再入职变成正式员工，你觉得外包公司会怎么想？这相当于大厂在和外包公司抢人，但是这些大厂和这些外包公司都是合作关系，就算明面上不说，估计私底下也签了协议。我觉得说的没毛病，不敢说绝对，但是现在通过外包进大厂其实很难，现在竞争激烈，大厂从来不缺人，其实还有另外一个原因，那就是大部分外包员工水平都很差。不过我确实有了解到一个通过外包进小米最后转正的人，PHP岗位。</p><h2 id="外包可能的坑"><a href="#外包可能的坑" class="headerlink" title="外包可能的坑"></a>外包可能的坑</h2><p>总之，在薪资问题上和这个人事专员以及她的上级领导几轮较量之后，她说可以给到我的薪资要求，但是我却说了No，因为我发现这家武汉的外包公司劣迹斑斑，在知乎上有很多“黑稿”，而且有理有据。最后我和这个人事专员摊牌了，她说她知道，她给我的辩解是如果真如网上说的这么差，那为什么还有这么多员工呢？为什么阿里依然和他们合作呢？</p><p>我无言以对，但是这些纠纷里面提到的问题大多集中在几个方面，我认为基本可信，比如说加班工资，很多大厂加班都很严重，外包也不例外，但是正式员工毕竟福利好，加班也是自愿加班，外包工资本身都很低，再996有点说不过去吧？于是有些外包公司就会承诺有加班费（一般都是调休），但是这笔加班费你想拿到有点难，要经过层层审批，很久很久，久到最后离职了还没拿到。还有一些控诉内容是调岗问题，大家要知道一个公司之所以招外包就是为了省钱，而且更加灵活，项目需要人的时候就招外包，项目不要人就可以“开除”外包，虽然我不知道外包公司和这些大厂签的什么协议，但是可以确定的是如果你外包的项目结束了，不需要人了，公司会让你去面试其它公司，假如很不幸没有公司招人（外包岗位都是一个萝卜一个坑）或者你没面试上，外包公司就会让你待岗，只会给你发一个基本工资，大概只有几千块，如果你仔细看一下外包合同，你会发现这个薪资构成就是这么写的，所以很多纠纷都在这里。</p><p>但是招聘你的时候，外包的人事专员都会告诉你这个项目是长期项目，他们和公司的合作是长期合作，其实话虽这么说，事实大家都清楚，没有什么是长期固定不变的，我相信这些纠纷可能不全是外包公司的问题，但是看判决书大部分都是员工胜诉，你们说公司有没有问题呢？</p><h2 id="再面外包"><a href="#再面外包" class="headerlink" title="再面外包"></a>再面外包</h2><p>这会距离过年还有2周时间，我承认我是有私心的，觉得当时工作反正不好找，也不想那么早回家，就先进外包干着，还有免费过年假期，万一太坑就明年再找，这家外包公司名字叫xx国际，在外包行业知名度比较高，巧的是面试的岗位和上次是同一个项目，但是好像不是一个部门，因为给我打电话面试不是同一个人。2轮电话面试轻松拿下，根据人事专员反馈阿里那边定级是高级，但是给的薪资我就呵呵了，脉脉应届生水平都不如，我懒的浪费时间应对他们的套路了，就直接说了最低数，低于这个数就别谈了。不知道是他们真缺人还是年底也不好招人，最后答应了，但是人事专员给我反馈说这个薪资属于他们的资深水平，需要特批，走一个流程，我说你们怕不是对资深有什么误解，她说他们和阿里签的什么框架协议就是这么规定的。最后她上级还打电话和我做个君子协议，意思说他们提申请，批下来我一定得去，不能放鸽子，这又是什么套路？</p><p>但是这个流程批了差不多一个星期，最后离过年还有一周的时候才正式入职，这中间有什么套路我就不清楚了，大公司OA流程确麻烦，那个人事专员确实没骗我，一直说在催，说什么领导出差、开年会，打电话也没人接，就算套路也是他们公司上层的旨意，但是都答应了我也不好意思再反悔了，就这么等了一周。</p><p>这里普及一下，干外包你需要面对2个公司，一个是你的外包公司也就是和你签合同给你发工资的公司，一个是你工作的公司也就是你真正上班的地方，比如阿里、百度，这种外包形式也叫人力外包、人力派遣。外包公司基本上都是听大厂安排，比如说此次疫情放假、健康打卡都是阿里安排的，外包公司基本上就是传话筒，虽然是传话筒，但是依然无法无视他们。</p><p>简单来说，你需要面对具体2个人，一个是你在大厂的主管，他负责给你安排工作、决定你的业绩考核，另一个是外包公司的接头人，他一般是给你传达一些公司的通知安排。我的主管在面试过程中还特意强调，他说：“阿里的正式员工招聘流程非常复杂、非常长，我们也想通过外包来做一些筛选，如果表现的好有机会转正，但是我不保证，只是说有这个可能”</p><h2 id="外包加班吗？"><a href="#外包加班吗？" class="headerlink" title="外包加班吗？"></a>外包加班吗？</h2><p>目前我还没加过班，原因很简单，我年前只工作了几天，那时候很多人都请假提前回家了，所以也没安排什么工作，而年后这段时间一直在家远程办公，工作量也很少，但是这不代表以后不加班，但是我之前问过我主管，他说没事可以早点走，但是他们一般都是9点以后走，阿里正式员工996毫无毛病。</p><p>但是我那几天刚好认识了几个从国门大厦过来在一起办公的不同部门的外包同事，他们刚好是我之前说的第一家武汉外包公司的员工，他们说他们主管要求必须待到9点之后，而且10点之后才算1个小时加班，可以调休。所以，这个问题没有固定答案，很多大公司内部不同部门也不一样，有些部门加班，有些不加班，如果非得说根据什么决定，那只能说是看主管，有些主管天天盯着你，而有些主管只要你把工作按时完成就行。</p><h2 id="外包工作地点"><a href="#外包工作地点" class="headerlink" title="外包工作地点"></a>外包工作地点</h2><p>这点只针对阿里外包有点用，一般来说，阿里外包都在国门大厦办公，那个地方是所有外包集中办公的地方，平时沟通的话主要通过远程视频，而阿里正式员工都在望京上班，望京有金辉大厦、阿里中心A、B座，但是也有部分的外包员工固定在望京上班，而且是和正式员工一起办公。</p><p>但是也不是绝对的，如果你在国门大厦，有时候主管会要求你来望京办公，这时候只能给你办一个访客证，阿里的管理特别严格，保安也很敬业，访客必须由正式员工带进访客专用电梯。而且这时候由于你没有固定工位，你只能去会议室办公，所以在国门大厦办公的外包基本上是来回于国门大厦和望京之间。为什么要这么做呢？其实是需求比较多的事情主管找机会盯着你，在国门大厦办公基本上没人管，考勤只看打卡记录，你没事干下去放放风，溜达一圈都可以。</p><h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><p>总得算起来，我目前也才上班一个多月，说起来也不算有什么发言权，但是还是想说一点，我不知道是阿里对信息安全要求非常高还是只针对外包，比如说电脑必须安装一个监控软件、不能安装微信、QQ，不能干工作之外的事情，还有一些比如说不能透露组织架构、透露工作内容等等，虽然说这些措施有点严格，但基本上还算合情合理。</p><p>所以这里面我只谈感受，首先，我的主管人比较随缘，很好说话，也很客气，其次，关于网传歧视外包员工这件事，目前没有感受到，主要是不在一起办公，目前只和他们一起吃过一次饭，确实没啥聊的，毕竟不熟，平时主要靠钉钉沟通，工作是工作，对事不对人。</p><p>不知是我的错觉还是阿里的文化如此，他们都喜欢给人点赞，每次解决一个问题或者完成一个工作，他们都会给你点赞，就是大拇指那个表情，我承认赞扬人是个美德，但是我平时很少赞扬人，所以注意到了这一点。</p><p>阿里是一个业务驱动的公司，当然这也没什么可说的，国内的公司都是业务驱动，以前在网上还看过一些《阿里巴巴的开发手册》，进去发现这和手册上说的不太一样，没见到规范在哪。。。一切以KPI为导向，但好像对外包没有KPI要求，为了完成KPI，996又有何怨言呢？</p><p>网上有些东西没说错，比如外包主要是在干一些边边角角的不是很核心的事情，比如说前端页面、一些增删改查的接口或重复性的工作。</p><p>至于我会在这里干多久，我也不知道，受现在疫情影响，经济环境差，或许我还会继续干下去，有时候一件事刚开始干起来可能很不爽，但是时间干的越久你会发现渐渐适应了，变成你的新舒适区了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写过几篇文章名字叫&lt;a href=&quot;https://wangbjun.site/2020/life/2019-1.html&quot;&gt;《一个野生程序员的北漂之路》&lt;/a&gt;，这篇文章应该算是后续吧，聊聊我如何进阿里外包，主要是结合我的经历和我所了解的一些事实谈谈我的感受和看法，仅供其他朋友参考。&lt;/p&gt;
&lt;h2 id=&quot;上家公司残局&quot;&gt;&lt;a href=&quot;#上家公司残局&quot; class=&quot;headerlink&quot; title=&quot;上家公司残局&quot;&gt;&lt;/a&gt;上家公司残局&lt;/h2&gt;&lt;p&gt;看过前面文章的人应该知道我上一家公司因为是P2P行业受到打击，目前已经处于立案阶段，整个公司几百员工都失业了，我也不例外。刚开始我对公司还抱有希望，在家休息等待了2周之后我才明白公司是真的没了，自己找工作吧，当时公司为了不仅欠了我们半月工资，而且连社保也没钱缴纳（财务账户被冻结），甚至都无法给员工办理离职（公章被扣押），没人有操心这几百号员工怎么办，但是社保断了对很多人有很大影响，很多人都在问怎么办，最后公司的HR出来告诉我们可以自己找人代缴，但是由考虑到风险，需要员工签一个离职声明，然后公司才可以把社保做减员处理，于是大家争相签离职声明。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Life" scheme="https://wangbjun.site/categories/Life/"/>
    
    
      <category term="Life" scheme="https://wangbjun.site/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>那些年，318徒步搭车之旅（二）</title>
    <link href="https://wangbjun.site/2020/life/walk-on-the-318-road-1.html"/>
    <id>https://wangbjun.site/2020/life/walk-on-the-318-road-1.html</id>
    <published>2020-02-25T15:50:08.000Z</published>
    <updated>2020-03-09T02:01:50.188Z</updated>
    
    <content type="html"><![CDATA[<p>每个人对旅行都有自己想法或出于各种目的，对于我当时来说，我并不完全是在旅行，只是把工作和对自由的追求结合在一起。但在这几年的旅行中，我都是独自一人踏遍大江南北，期间也遇到很多和我一样一个人出来旅行的人，我虽不善于交际，但是也在途中结识不少，大多萍水相逢，随后结伴而行度过一段时光，最后各奔东西，相忘于江湖。。。</p><a id="more"></a><p>在Ta们中，有人是纯粹出来旅游散心，有人是挑战自我，有人是对自然的热爱，有人是为了结交更多的朋友，也有人是在躲避生活。记得有一次在丽江一家青旅认识一位小姑凉，她说她在读高三，看长相似乎与我年龄相仿，曾一起骑车游逛古镇，后来听说她被她爸“抓”回去了，原来她父母离异，她这次是私自离校出来玩，她爸报警之后通过公安局查到青旅，做飞机从千里之外上门把人带走了。一个人出去旅行的人往往都有自己的故事，Ta们也许是习惯一个人，也许是追求流浪的状态，或许是想找个人倾诉，或借机摆脱烦恼，无论如何，这都是Ta们的旅行。</p><p>时间回到林芝，咱们继续说318的故事，林芝算是西藏地区非常大的一个城市，四面环山，云雾缭绕，旁边一条河流流过，自然环境非常好，本地也没什么工业，空气质量非常好，但是湿度也大，林芝这属于亚热带气候，夏天的时候下雨，雨蒸发变成云雾，然后又变成雨，一天可以下好几次雨。</p><img src="/images/2020-02-26-1.jpeg" /> <img src="/images/2020-02-26-2.jpeg" /> <p>我在林芝总共待了2天，随处逛了下，整个城市是一个严重依赖外部资源输入的地方，只有往西可以去西藏，往东就是2000多公里的318国道。期间去了一个国家森林公园，站在山上俯视了下整个城市，可以看见整个城市在一片河滩冲积平原上面，有很多在建的工程。</p><img src="/images/2020-02-26-3.jpeg" /> <img src="/images/2020-02-26-4.jpeg" /> <p>这座山名字叫作“比日神山”，可能是当地藏族人民的神山，所以在山上的栈道两边全部挂满了经文，这在西藏非常常见！</p><img src="/images/2020-02-26-5.jpeg" /> <img src="/images/2020-02-26-7.jpeg" /><p>这条桥叫作八一大桥，其实最早林芝市也叫八一镇，只不过发展的比较大就改成市了。</p><img src="/images/2020-02-26-6.jpeg" /> <p>刚刚去Google卫星地图上面看了下，发现虽然5年过去了，似乎变化并不大，从卫星地图上也可以看出来整个城市围绕着河道而建，这条河最终流向印度洋。</p><img src="/images/2020-02-26-9.jpeg" /> <img src="/images/2020-02-26-8.jpeg" /> <p>这样的城市看起来很好，但是似乎不是太适合现代人，除了空气比较好之外，周围被大山包围，阳光并不多。另外这地方太过偏远，离拉萨还有几百公里，网上买东西太慢，上网的话网速也慢，如果要去别的地方不坐飞机就更远了，虽然有机场，但是票价不便宜，另外各种生活物资，比如蔬菜、水果、海鲜水产基本上全靠外部输入，种类少价格高，可能适合有钱人买套房在这偶尔坐飞机过来度假，待上一段时间，感受一下慢生活。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每个人对旅行都有自己想法或出于各种目的，对于我当时来说，我并不完全是在旅行，只是把工作和对自由的追求结合在一起。但在这几年的旅行中，我都是独自一人踏遍大江南北，期间也遇到很多和我一样一个人出来旅行的人，我虽不善于交际，但是也在途中结识不少，大多萍水相逢，随后结伴而行度过一段时光，最后各奔东西，相忘于江湖。。。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Life" scheme="https://wangbjun.site/categories/Life/"/>
    
    
      <category term="Life" scheme="https://wangbjun.site/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>那些年，318徒步搭车之旅（一）</title>
    <link href="https://wangbjun.site/2020/life/walk-on-the-318-road.html"/>
    <id>https://wangbjun.site/2020/life/walk-on-the-318-road.html</id>
    <published>2020-02-12T07:40:07.000Z</published>
    <updated>2020-03-09T02:01:50.192Z</updated>
    
    <content type="html"><![CDATA[<p>那是2015年8月，我在拉萨停留几日，期间逛了下<code>大昭寺、布达拉宫门口</code>等打卡地点，作为一个非宗教人士，我对拉萨的这些宗教文化并无太多感触，也并不觉得灵魂有什么升华。大街上的商店大部分也都是卖着义乌批发制品，他们的售卖对象其实不是游客，而且来自西藏各地的牧民，但我花了100多买了一双山地运动鞋，扔掉了我脚上穿的特步运动鞋，这双运动鞋我在外穿了几个月，虽然也很便宜但是非常轻便，但是过于轻薄，因为我在策划一场没有安排和计划的318之旅，从拉萨坐火车往回走太远，不如走国道再去云南大理转转。</p><blockquote><p>后记，那双鞋质量很差，差的突破预期。。。</p></blockquote><a id="more"></a><img src="/images/2020-02-12-1.jpeg" /> <div align="center">    <audio controls autoplay loop>      <source src="/audios/fzw.mp3" type="audio/mpeg" >    </audio></div><p>说走就走，第一站是<code>林芝市</code>，早上我告别青旅，坐车前往距离拉萨几十公里外的一个县（墨竹工卡县），等等，不是说好的徒步搭车吗？其实我在外一般能坐车的地方肯定是自己坐车，极少去坐“黑车”或者搭车。但是西藏这个地方客运车辆很少，有些地方根本不通车，或者车次非常少（有些地区1-2天才发一趟车）。在国道上跑的车一类是大货车，大多都是从云南四川过来的货运车辆，珍惜生命远离大货车；另一类是私家车，以川字牌居多，其中大部分都是自驾游或者租的车，也有不少是藏族人当地车，还有部分以盈利为目的的“黑车”。</p><img src="/images/2020-02-12-2.jpeg" /> <p>大约中午的时候才到达了这个县，说是县城，但规模比我国中东部地区的一个镇都还小，基本上就是沿着国道2边有一些房子，路边商店买了一瓶水，望了望这街道，再看了下地图我离林芝还有300多公里。。。我决定开始搭车了。第一次搭车没什么经验，站路边招手半天没人停，也记不清大概过了多久，有一辆车停了，直接招呼我上车，车上有很多藏族人，车主的普通话很糟糕，我觉得大概是在问我去哪里，我说去林芝，也不知道他听懂了没，后面就一直没交流过，车上这些人说话我也听不懂，也没和我搭话，我自顾自刷着手机，中间路过<code>米拉山口</code>下来拍了张照，第一次在海拔这么高的地方，感觉脑袋有点懵，腿有点软，也不知道是不是因为坐的太久了。。。</p><blockquote><p>米拉山口是318国道海拔最高点，5000多米，当时下面已经在修隧道了，现在估计早已经修好了。其实318国道那几年到处都在架桥修隧道，路况好很多，现在估计随便一个车也能开过去。</p></blockquote><img src="/images/2020-02-12-3.jpeg" /> <p>大概5点多的时候，车子到了国道旁一个像是镇的地方，那块有一个岔路口，往前走是318，拐进去不知道是什么地方，看地图里面也没什么县或镇，估计这些藏族人家在深山。车上人都下来休息，这时候车主和我说，他们不往前面走了，要拐进去，离林芝也不远了，让我自己在路边再拦个车，最后让我让把<code>路费</code>付一下。其实付路费这事我觉得没啥问题，毕竟上车那会也没说不要钱，现在回忆起来也记不清楚是他到底开口要了多少钱，反正我记得我那会还还价了，最后给了100块外加一些零钱，可能不合他意，但是他也没做出什么出格的举动，因为那会我兜里也就踹了几百块钱，自己总得留点，再多要我确实也没有。</p><p>然而这里距离这个林芝还有100多公里，路边已经基本上没有什么车了，再过1个多小时天也快黑了。我进镇看了下，这个镇也很小，不过好在还有旅店和饭店，于是背着包在镇里面过了一遍，然后又回到了318国道，最后决定还是继续往前，先往前走着一边再搭车，如果实在搭不到车那就再往回走晚上住这里。</p><img src="/images/2020-02-12-4.jpeg" /> <p>这次运气比较好，很快就有一辆川字牌的车停下来了，车主是不是藏族人，上车后发现车子非常新，连后座的膜都还在，简单聊了几句，他说他是去云南送车的，让我不要动车上的东西，具体我也没多问。不过这大哥的车技确实了得，318上面弯道非常多，很多地方道路也不宽敞，但是这大哥每次转弯、会车的时候甚至都不用减速。虽然这次语言不是障碍，但是2个大老爷们也没什么太多可聊的，最后晚上9点多的时候到了林芝，我说了声谢谢后就下了车，这大哥什么也没说啥，一脚油门就走了，颇有几分干练和爽快。</p><p>虽然有点折腾，但是最终还是到达林芝市，迈出了318国道的第一步，万事开头难，谁知道接下来又会发生什么呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;那是2015年8月，我在拉萨停留几日，期间逛了下&lt;code&gt;大昭寺、布达拉宫门口&lt;/code&gt;等打卡地点，作为一个非宗教人士，我对拉萨的这些宗教文化并无太多感触，也并不觉得灵魂有什么升华。大街上的商店大部分也都是卖着义乌批发制品，他们的售卖对象其实不是游客，而且来自西藏各地的牧民，但我花了100多买了一双山地运动鞋，扔掉了我脚上穿的特步运动鞋，这双运动鞋我在外穿了几个月，虽然也很便宜但是非常轻便，但是过于轻薄，因为我在策划一场没有安排和计划的318之旅，从拉萨坐火车往回走太远，不如走国道再去云南大理转转。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;后记，那双鞋质量很差，差的突破预期。。。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Life" scheme="https://wangbjun.site/categories/Life/"/>
    
    
      <category term="Life" scheme="https://wangbjun.site/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>Golang测试用例编写</title>
    <link href="https://wangbjun.site/2020/coding/golang/unit-and-functional-test.html"/>
    <id>https://wangbjun.site/2020/coding/golang/unit-and-functional-test.html</id>
    <published>2020-02-10T10:15:00.000Z</published>
    <updated>2020-03-09T01:56:24.547Z</updated>
    
    <content type="html"><![CDATA[<p>如果你看过很多开源库的源码，你会发现大部分项目都有很多详细的测试代码，一般来说测试覆盖率越高说明这个项目的质量越高，所以好的项目测试是少不了的。很多公司对代码测试覆盖率也有要求，不为别的，只为更好的代码质量。</p><h2 id="1-分类"><a href="#1-分类" class="headerlink" title="1.分类"></a>1.分类</h2><p>虽然业界有一直开发模式叫做测试驱动开发（TDD），但是了解的人都知道<code>TDD</code>对开发要求太高了，它要求你先写测试用例然后再写代码，需要你写代码之前思考很多，需要大量时间，我实际开发中并没有采用过这种模式，估计国内都应该很少。</p><p>我们可以粗略的把测试用例简单划分为2种类型，一种是<code>单元测试</code>，它是针对某个模块、函数、方法的测试，另一种是<code>功能测试（集成测试）</code>，它是针对整个项目功能是否可用的测试。举个例子，你写个了Web服务接口，单元测试可能是针对这个接口里面调用的一个函数测试，而功能测试就是测试这个接口是否可用，因为一个接口可能调用了多个函数。</p><h2 id="2-单元测试"><a href="#2-单元测试" class="headerlink" title="2.单元测试"></a>2.单元测试</h2><p>Golang里面的测试和其它大部分语言的测试不多，只不过表示形式略有不同，比如Go的单元测试通常情况下是和被测试的代码放在一起的，以<code>xxx_test.go</code>命名并且测试的函数名必须以<code>Test</code>开头。</p><a id="more"></a><p>例如：<br>math.go 有以下2个函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"errors"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Div</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">"division by zero"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想测试这个文件，那么测试文件名字就应该叫 math_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDiv</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    i, err := Div(<span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        t.Fail()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> i != <span class="number">2</span> &#123;</span><br><span class="line">        t.Fail()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切换到工作目录下执行 <code>go test</code>即可，这个命令有很多附加参数，比如说<code>-v</code>可以查看详细情况，<code>-coverprofile</code>可以看测试覆盖率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jwang@jun:~&#x2F;Documents&#x2F;Work&#x2F;test$ go test -v -coverprofile&#x3D;c.out</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestDiv</span><br><span class="line">--- PASS: TestDiv (0.00s)</span><br><span class="line">PASS</span><br><span class="line">coverage: 66.7% of statements</span><br><span class="line">ok      _&#x2F;home&#x2F;jwang&#x2F;Documents&#x2F;Work&#x2F;test       0.001s</span><br></pre></td></tr></table></figure><p>根据测试函数参数类型的不同，Go里面把测试又细分为<code>*testing.T和*testing.B</code>，其实B是性能基准测试，通常用来测试算法性能，这里就不多说了。</p><p>单元测试的目的就是尽可能的覆盖到所有情况，说白了，就是枚举各种情况，根据输入的参数人工推导正确的结果，然后和实际得出的结果做比对，如果失败则说明程序有bug，比如上面的例子明显没有覆盖到所有情况，只达到了66.7%。</p><p>上面这段测试代码主要是没有覆盖到被除数为0的情况，下面完善一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDiv</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    i, err := Div(<span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        t.Fail()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> i != <span class="number">2</span> &#123;</span><br><span class="line">        t.Fail()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i, err = Div(<span class="number">4</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        t.Fail()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新执行<code>go test</code>会发现覆盖率达到了100%，也就是所有语句都覆盖到。</p><blockquote><p>请注意，覆盖率达到100%并不意味着代码没有问题。</p></blockquote><h2 id="3-表格测试"><a href="#3-表格测试" class="headerlink" title="3.表格测试"></a>3.表格测试</h2><p>表格测试严格来说并不是一种测试类型，只是一种测试方式，就是一种套路，上面的例子里面，我们需要手动构造每一个测试的入参和出参后执行、断言结果，有很多重复代码，我们可以使用表格测试优化一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDiv</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tests = []<span class="keyword">struct</span> &#123;</span><br><span class="line">        a        <span class="keyword">int</span></span><br><span class="line">        b        <span class="keyword">int</span></span><br><span class="line">        expected <span class="keyword">int</span></span><br><span class="line">        err      error</span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="literal">nil</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="literal">nil</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="literal">nil</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, DivisionByZeroError&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        i, err := Div(v.a, v.b)</span><br><span class="line">        <span class="keyword">if</span> i != v.expected || err != v.err &#123;</span><br><span class="line">            t.Errorf(<span class="string">"input %d, %d, expected %d, got %d"</span>, v.a, v.b, v.expected, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式比较简洁，参数一目了然，而且方便扩展添加新的用例，这里需要注意一下那个error，可以先定义一个自定义的error方便判断，同时使用了<code>t.Errorf</code>格式化入参和出参方便排查错误。</p><blockquote><p>为了更方便的断言结果，我们可以使用第三方的assert库，Github上面也有很多开源的测试库，可以简化你的操作，更快速的编写测试用例。</p></blockquote><h2 id="4-功能测试"><a href="#4-功能测试" class="headerlink" title="4.功能测试"></a>4.功能测试</h2><p>功能测试就和你用Postman去测试一样，我们需要把这个服务启动起来，然后模拟用户的操作，去测试结果是否符合预期。测试本身是个非常广泛的话题，有很多种方式，这里我只说说平时用的比较多的Http服务的接口测试。</p><p>首先，我们需要了解一下Go里面Http服务的创建方式，最简单的方式莫过于下面这种：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/div"</span>, DivHandler)</span><br><span class="line">    _ = http.ListenAndServe(<span class="string">":8888"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DivHandler</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span>  &#123;</span><br><span class="line">    a := request.PostFormValue(<span class="string">"a"</span>)</span><br><span class="line">    b := request.PostFormValue(<span class="string">"b"</span>)</span><br><span class="line"></span><br><span class="line">    paramA, _ := strconv.Atoi(a)</span><br><span class="line">    paramB, _ := strconv.Atoi(b)</span><br><span class="line"></span><br><span class="line">    i, err := Div(paramA, paramB)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        _, _ = writer.Write([]<span class="keyword">byte</span>(<span class="string">"error"</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    _, _ = writer.Write([]<span class="keyword">byte</span>(strconv.Itoa(i)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码就是使用了Go自带的http库创建了一个Web服务，它提供了一个接口，功能和之前的函数一样，如果出错的话就返回error。</p><p>我们可以使用Go的一个http recorder对这个http服务进行测试，方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"net/http/httptest"</span></span><br><span class="line">    <span class="string">"net/url"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDivHandler</span><span class="params">(t *testing.T)</span></span>  &#123;</span><br><span class="line">    recorder := httptest.NewRecorder()</span><br><span class="line"></span><br><span class="line">    params := url.Values&#123;&#125;</span><br><span class="line">    params.Add(<span class="string">"a"</span>, <span class="string">"42"</span>)</span><br><span class="line">    params.Add(<span class="string">"b"</span>, <span class="string">"2"</span>)</span><br><span class="line"></span><br><span class="line">    request, _ := http.NewRequest(<span class="string">"POST"</span>, <span class="string">"/div"</span>, strings.NewReader(params.Encode()))</span><br><span class="line">    request.Header.Add(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>)</span><br><span class="line"></span><br><span class="line">    DivHandler(recorder, request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> recorder.Result().StatusCode != <span class="number">200</span> &#123;</span><br><span class="line">        t.Error(<span class="string">"Test failed"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    body, _ := ioutil.ReadAll(recorder.Result().Body)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">string</span>(body) != <span class="string">"21"</span> &#123;</span><br><span class="line">        t.Error(<span class="string">"Test failed"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个测试用例里面，我主要测试了2点，一个是返回码是不是200，另外测试了一下正常的返回结果。不过很明显，我这里并没有覆盖到异常情况。</p><p>很多Go的Web框架，比如Beego和Gin，框架本身会多一层路由，但是测试方式大同小异，主要还是使用http recorder来实现，这里就不多说了。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>这里介绍的只是最简单测试方式，实际开发中想要完全做好测试还有很多问题，比如有些系统有很多外部依赖，在测试的时候可能还要借助于mock。再比如有很多Web服务还涉及到数据库层，想要完整测试还要做好数据回滚。</p><p>国内很多公司对测试要求并不严格，很多公司都不要求写测试，有些虽然有测试覆盖率要求，但是也是为了应付（代码都写完了，后面再加测试也就图个心理安慰），测试用例并无法保证代码质量，我觉得真正想提高代码质量还是得靠<code>code review</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你看过很多开源库的源码，你会发现大部分项目都有很多详细的测试代码，一般来说测试覆盖率越高说明这个项目的质量越高，所以好的项目测试是少不了的。很多公司对代码测试覆盖率也有要求，不为别的，只为更好的代码质量。&lt;/p&gt;
&lt;h2 id=&quot;1-分类&quot;&gt;&lt;a href=&quot;#1-分类&quot; class=&quot;headerlink&quot; title=&quot;1.分类&quot;&gt;&lt;/a&gt;1.分类&lt;/h2&gt;&lt;p&gt;虽然业界有一直开发模式叫做测试驱动开发（TDD），但是了解的人都知道&lt;code&gt;TDD&lt;/code&gt;对开发要求太高了，它要求你先写测试用例然后再写代码，需要你写代码之前思考很多，需要大量时间，我实际开发中并没有采用过这种模式，估计国内都应该很少。&lt;/p&gt;
&lt;p&gt;我们可以粗略的把测试用例简单划分为2种类型，一种是&lt;code&gt;单元测试&lt;/code&gt;，它是针对某个模块、函数、方法的测试，另一种是&lt;code&gt;功能测试（集成测试）&lt;/code&gt;，它是针对整个项目功能是否可用的测试。举个例子，你写个了Web服务接口，单元测试可能是针对这个接口里面调用的一个函数测试，而功能测试就是测试这个接口是否可用，因为一个接口可能调用了多个函数。&lt;/p&gt;
&lt;h2 id=&quot;2-单元测试&quot;&gt;&lt;a href=&quot;#2-单元测试&quot; class=&quot;headerlink&quot; title=&quot;2.单元测试&quot;&gt;&lt;/a&gt;2.单元测试&lt;/h2&gt;&lt;p&gt;Golang里面的测试和其它大部分语言的测试不多，只不过表示形式略有不同，比如Go的单元测试通常情况下是和被测试的代码放在一起的，以&lt;code&gt;xxx_test.go&lt;/code&gt;命名并且测试的函数名必须以&lt;code&gt;Test&lt;/code&gt;开头。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="https://wangbjun.site/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.site/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>你是否真的需要使用Linux？</title>
    <link href="https://wangbjun.site/2020/linux/do-you-need-linux.html"/>
    <id>https://wangbjun.site/2020/linux/do-you-need-linux.html</id>
    <published>2020-02-10T01:52:44.000Z</published>
    <updated>2020-03-08T12:54:47.928Z</updated>
    
    <content type="html"><![CDATA[<p>自从跨入IT编程行业一直都在使用Linux桌面系统办公（尝试过挺多发行版，最终选择Ubuntu），平时生活也在用，不知不觉已经4年多了，也安利了身边很多人使用Linux，从最早的疯狂折腾到现在追求稳定，其实也颇有感触，闲来无事聊一聊。</p><p>我和很多人一样，最早接触的都是<code>Windows</code>系统的电脑，我也一度是Windows的爱好者，记得当年还对XP、IE情有独钟，装系统、优化系统这些事情当年也没少做，也没少折腾，基本上到了打开任务管理器，对里面每一个进程的作用以及关闭某个进程会导致什么问题都了解的地步。而当时我对Linux的印象也停留在黑框框上面，觉得很神秘，对技术要求很高，只在很多电影里面看见黑客会用到，毕竟那会我对OS需求只是到用的地步，并没有接触编程开发。</p><img src="/images/2020-02-10-1.jpeg" /> <a id="more"></a><p>实际上，踏入编程行业之后，我发现很多教学教程用的还是Windows居多，或者是Mac OS，使用Linux的人还真不多，那会我无意间了解到一个叫<code>Kali</code>的系统，了解这个系统的都知道，Kali这个系统是专门用于<code>安全渗透测试</code>，它开箱自带了很多非常有用的工具，比如说可以用于制作木马、中间人攻击、钓鱼、抓包破解WiFi等等，我最初也是因为对黑客比较感兴趣才会去使用这个系统。具体的话我在另一篇文章说到，我拿Kali做了很多有意思的事情，不过后来渐渐就不用了，毕竟我从事的不是IT网络安全行业。</p><p>我最早使用Ubuntu的时候，那会的版本使用的还是unity桌面，我个人非常喜欢这个桌面，但是Ubuntu 18.04之后的版本换成gnome了。目前我依然坚持使用unity的一个原因就是unity桌面的沉浸式状态栏非常好看，其次unity桌面的颜值很高，另外就是习惯了，毕竟用了好几年了，可惜被官方抛弃了。</p><img src="/images/2020-02-10-2.png" /> <p>大约2年前，我建了一个Ubuntu桌面的交流QQ群(<code>群号: 541114553</code>)，那会只有几个人，后来一直也没打理，没想到最近半年陆续有很多人申请加入，现在已经有100多人了。</p><img src="/images/2020-02-10-3.png" /> <p>但是我发现加群的人大部分都是小白，都是来问问题的，问的最多的问题都是关于安装的问题。诚然，Linux系统的安装确实是个头疼的事情，特别是在有独显的机器上面，可能还涉及到硬件驱动兼容性问题。有时候并不是我不想回答问题，只是有些问题完全是可以搜索解决的，只是很多伸手党懒的去研究，我在不同机器上面安装Linux的次数没有上百次也有几十次了，也安装过双系统，包括黑苹果双系统，折腾系统很多年，什么样的问题都遇到过，所以我这里总结一下解决问题的思路：</p><ul><li><p>首先，准确的描述报错问题。很多人在遇到问题之后搜索都不会，主要是因为不知道如何表达。有些人说自己英文太差，看不懂报错。。。也有人说报错太多，不知道哪地方是重点。</p></li><li><p>其次，先<code>百度|Google</code>一下，99%的问题网上都有答案，就看你会不会搜索。英文确实很主要，Google搜出来的很多都是英文的，如果你看不懂那确实有点难，毕竟翻译有时候并不准确。</p></li></ul><img src="/images/2020-02-10-4.png" /> <ul><li><p>然后，提问的艺术。提问要准确描述你要干什么？、你遇到的问题？、然后最好附上截图或者视频。</p></li><li><p>最后，既然选择使用Linux，就一定要有耐心和动手能力，我最早折腾Linux，不知道重复安装了多次，每次折腾挂了就重新安装。如果不想折腾，可以出门右转Windows或者Mac。</p></li></ul><p>针对大家遇到的Linux安装问题，我这里说一下常见的问题点：</p><ul><li><p>BIOS，建议关闭安全启动和快速启动，有些电脑<code>BIOS</code>里面有很多是为Windows优化的。如果你连BIOS是什么都不清楚，回去补功课吧。</p></li><li><p>显卡驱动，N卡对Linux的支持比较烂，但是英特尔家的集显还是比较好。如果安装有问题，可以尝试屏蔽独显，笔记本可能需要在BIOS里面调，台式机可以在<code>grub</code>加启动安装参数，具体的百度，在安装完成进系统之后再单独安装驱动。</p></li><li><p>硬件驱动，某些比较新的笔记本有些硬件，比如无线网卡，蓝牙可能没驱动，Linux的驱动都在内核里面，如果不支持你有2种选择，一种是查一查最新的内核有没有带驱动，如果有那可以升级内核。另一种是查看该硬件官网是否有单独的Linux驱动提供下载，如果有可以自己编译安装。</p></li><li><p>双系统，建议先安装Windows然后再安装Linux，很多发行版可以检测到你安装了Windows，所以在你安装Linux的时候可以保留Windows，自动变成双系统。而Windows安装则不会管你Linux，它会覆盖掉，虽然后面也可以通过修复引导等方式解决，不过很麻烦。</p></li></ul><p>最后，我想说一个比较重要的话题，那就是你为什么要使用Linux？</p><p>首先，我不建议非IT行业从事者使用Linux，操作系统本质上只是一个工具，大部分非IT技术行业者可能只是好奇，但他们没有相关技术能力解决一些问题，他们可以选择更好用的面向消费者的Windows或Mac，少折腾多花点时间放在工作上会更好。</p><img src="/images/2020-02-10-5.png" /><p>本人使用Ubuntu原因主要有下面几点：</p><ul><li><p>编程开发方便，无论是工具还是环境，Linux对编程都非常友好，这一点不用质疑。有人说使用Linux的人到最后都会转向Mac，我旁边确实有人是这样，但是我觉得我不会。Mac的操作习惯是反人类的，我曾经在黑苹果上面尝试过一段时间，最终还是没有坚持下去。</p></li><li><p>渲染效果，特别是高DPI下，Linux的渲染效果和Mac是同一个级别的，毕竟都是类Unix系统。建议有条件的童鞋可以换个4k屏幕，效果非常出众。</p></li><li><p>流氓软件少，Linux下很多国产软件也安分很多，比如搜狗输入法、WPS、网易云音乐都没有弹窗广告，也不会开机自启。另外，各种木马病毒也少很多，我用了这么多年从来没遇到过。</p></li></ul><p>如果非得说缺点，就是打不了游戏，虽然steam也有Linux版本，但是支持的游戏少，也就Dota2比较出名。我是安装的双系统，只有玩游戏会切换到Windows。</p><p>从国内Linux生态圈来说，最近几年确实好很多，主要是政策原因，很多软件纷纷推出Linux版本，比如百度网盘、QQ，但是诚意不足，很多都是拿Web端套个壳，要不然就是功能简陋。虽然总体上说Linux依然是少数人使用的系统，但是这并不妨碍Linux的发展，毕竟Linux不仅仅是工具，更是一种<code>自由</code>软件的信仰！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从跨入IT编程行业一直都在使用Linux桌面系统办公（尝试过挺多发行版，最终选择Ubuntu），平时生活也在用，不知不觉已经4年多了，也安利了身边很多人使用Linux，从最早的疯狂折腾到现在追求稳定，其实也颇有感触，闲来无事聊一聊。&lt;/p&gt;
&lt;p&gt;我和很多人一样，最早接触的都是&lt;code&gt;Windows&lt;/code&gt;系统的电脑，我也一度是Windows的爱好者，记得当年还对XP、IE情有独钟，装系统、优化系统这些事情当年也没少做，也没少折腾，基本上到了打开任务管理器，对里面每一个进程的作用以及关闭某个进程会导致什么问题都了解的地步。而当时我对Linux的印象也停留在黑框框上面，觉得很神秘，对技术要求很高，只在很多电影里面看见黑客会用到，毕竟那会我对OS需求只是到用的地步，并没有接触编程开发。&lt;/p&gt;
&lt;img src=&quot;/images/2020-02-10-1.jpeg&quot; /&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://wangbjun.site/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://wangbjun.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>谈谈城市化和农村现状</title>
    <link href="https://wangbjun.site/2020/life/city-and-county.html"/>
    <id>https://wangbjun.site/2020/life/city-and-county.html</id>
    <published>2020-02-07T04:57:19.000Z</published>
    <updated>2020-03-09T02:01:50.172Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此次疫情爆发，有人说现在农村最安全，因为农村一般都是自建房，分布零散，而城市里面都在小区里面，住在火柴盒一样的格子楼里面，进出同一个楼道，同一个电梯，被感染的几率大很多。</p></blockquote><p>我从小在农村长大，自始至今，依然是个农村人（户口还在农村），大学之后，基本上都在城里面上班工作，但是过年还是在老家。有时候早上还在车水马龙、遍布高楼大厦的城里面，晚上就来到了农村蛙声一片的田野边，一个是现代化的城市，另一个是传统的农村，感触十分之深。</p><p>今天我就聊聊我一些关于农村和城市的事和想法，可能比较零散，纯属回忆！</p><a id="more"></a><div align="center">    <audio controls autoplay loop>      <source src="/audios/ahq.mp3" type="audio/mpeg" >    </audio></div><h2 id="一样的经历"><a href="#一样的经历" class="headerlink" title="一样的经历"></a>一样的经历</h2><p>我在农村长大这些年的时光几乎和很多农村人一样，曾经也住过土房子，经常下河抓鱼摸虾，插过秧也种过地。。。很多和我年龄一样大但是在城里长大的孩子肯定没有经历过，但是或许他们父母（也可能是爷爷奶奶）经历过。</p><p>有趣的是，相对于和我同龄的人，我们虽然年龄相同但是经历不同，但我和他们父母虽然不在一个年龄段却可能拥有相同的经历。我相信，即使在2020年的今天，中国依然有很多孩子留守在农村，过着和我20年前差不多一样的农村生活。</p><h2 id="房地产市场化"><a href="#房地产市场化" class="headerlink" title="房地产市场化"></a>房地产市场化</h2><p>从农村到城市，这样的过程依然在很多地方进行着，只不过不同人可能处于不同的阶段，有些人可能在30年前就完成了这个过程。</p><p>有人说现在很多的城里人以前也是农村人，确实是这样，中国的城市化的快步发展很大程度上得益于国家政策的变化，也就是房地产市场化，开放城市落户，差不多是最近20年才完成的事情。我们盖了大概可以容纳30亿人的房子，全民都在买房、炒房，房子成为每个人最值钱的财产。</p><h2 id="落寞的小洋楼"><a href="#落寞的小洋楼" class="headerlink" title="落寞的小洋楼"></a>落寞的小洋楼</h2><p>我记得我上小学初中的时候那会，大约在03年左右，农村都在盖自建房以代替之前的土瓦房，那会很流行盖“小洋楼”，一般多为2-3层的楼房，现在你去农村看看还有很多，大部分都荒废了，因为农村根本没人了，即使现在农村几乎家家都有水泥路，有些地方甚至都通了自来水，光纤网络，虽然基础设施建设并不差，但是没人愿意住农村。</p><p>我在想，那会为什么没有人去城里买房呢？那会估计房子几百块一平方米就可以吧？</p><img src="/images/2020-02-07.jpeg" /> <p>其实并不是他们不想买，是因为根本买不到，我不知道中国房地产正式市场化具体时间点是什么时候，但是我肯定那会你在城里面买不到房子，也落不了户口，孩子更上不了学。</p><h2 id="割裂的家族"><a href="#割裂的家族" class="headerlink" title="割裂的家族"></a>割裂的家族</h2><p>农村有很多小村庄，一个村里面的基本上都是亲戚，毕竟那会兄弟姐妹很多，我有一个大伯，早年当兵，部队退伍之后给安排在省会，之后他们那一岔全部都在城里面发展了，他的子女就是原生的城里人了。早些年，村里老一辈在世的时候有时候还会回农村过年，清明节也会回家祭祖，小时候他们经常回来带着胶卷相机给我们拍照。</p><p>在农村，传统的血缘关系家族早已分崩离析，有钱的亲戚基本上都进了城，更有钱的甚至出了国，没钱的还在农村，久而久之就不联系了。即便现在网络通信发达，动动手指就能聊天视频，也懒的去问候寒暄。</p><p>传统的大家族时代一去不复返，现在很多人只生1个子女，慢慢在一个城市生根发芽，会逐渐演变成小家族（家庭）时代，我觉得这个重组的过程大约需要2代人吧。</p><blockquote><p>城里人亲戚基本上都在一个城市，而很多农村人的亲戚基本上遍布全国，这大概就是相濡以沫，不如相忘于江湖。</p></blockquote><h2 id="无处安放的土地"><a href="#无处安放的土地" class="headerlink" title="无处安放的土地"></a>无处安放的土地</h2><p>有些人可能不知道种地一年能挣多少钱，更不知道农业税有多重。我家以前大概分了10亩地，我记得忙活一年收的稻谷大概能卖5000块钱，其中农业税大概需要2000块钱。事实上，农业税只是统称，那会农村的税目不比现在企业的少，其中包括修路修桥、水利等很多类目。</p><p>在我上小学的时候，那些年农业税征收是政府的大事，每年秋收之后，田野间经常能看到浩浩荡荡的村干部一行十几人，挨家挨户催收。有些村民远远看见村干部来了，会关门出去躲开，但也有硬碰硬的，经常发生打架事件，村干部被打伤打死的事情时有发生。</p><p>那时候官民关系非常紧张，我亲眼所见，我叔的稻谷被村干部找来收粮人“强行”卖掉拿来交税（一般稻谷春季价格高一点，所以很多人会留着不卖），你不卖村干部帮你忙，卖了还帮你数钱，多的还你，比劫匪好一点。</p><blockquote><p>那时候中国工业刚刚起步，政府用农业补贴工业，对农民的压榨太狠了，后来工业差不多发展起来了，最终取消了农业税。</p></blockquote><p>为什么没人愿意种地？原因其实很简单，水稻小麦的价格是由政府定的（传说中的指导价），这个定价基本上是不让你饿死就行了，现在你随便去城里打工，一年收入也有好几万，你会为了几千块在家种地吗？</p><h2 id="农场主制度"><a href="#农场主制度" class="headerlink" title="农场主制度"></a>农场主制度</h2><p>现在农村的土地大部分都是承包给个人种植了，也就是说传说中的农场主制，不过这和美国的农场主差远了。土地大规模承包确实有利于机械化种植，发挥规模效益，但是其实很有限。很多地方连农场主都不想干了，土地就荒废了，原因很简单，也挣不了多少钱，一方面粮食价格国家控制，另一方面农药化肥价格是市场控制，作为种地的人，你什么都控制不了，连收成还得看天。</p><h2 id="消失的村镇"><a href="#消失的村镇" class="headerlink" title="消失的村镇"></a>消失的村镇</h2><p>这几年在农村过年晚上放烟花的人越来越少，农村基本上已经没人了，城里还不给放，印象中农村过年烟花放的最多的时候大约在05年左右，那会晚上农村还很热闹。</p><p>在农村有很多村和镇，有些地方逐渐发展壮大，有些地方逐渐消失，发展一个县城可能要吸引下面几十个乡镇的人口迁移，如果不这样做，那么多房子卖给谁呢？</p><p>但是光把房子盖起来，没有配套的工作，买了房又有什么用？这是很多三四线城市面临的问题</p><h2 id="房子还是公寓？"><a href="#房子还是公寓？" class="headerlink" title="房子还是公寓？"></a>房子还是公寓？</h2><p>在美国，一般说房子（house），是指那种带院子的独栋建筑，而中国所说的房子其实在美国一般被称为公寓（department），也就是格子房。在中国也有房子，不过一般都是别墅，很多大城市郊区都遍布了大规模的别墅群，但是和美国比还是差远了，而中国农村的自建房其实也可以算是别墅的一种。</p><p>如果你用过Google的卫星地图，你可以看看美国的城市，你会发现美国的城市规模非常之大，全部都是独栋建筑，很少有类似中国的高层小区。所以很多人戏称美国是大农村，没毛病，和中国农村差不多。</p><img src="/images/2020-02-07-2.jpeg" /> <p>中国这种密集的高层小区便于管理，可以很好利用公共基础设施，同时方便了快递、外卖、共享单车等行业发展，但是其弊端已经在慢慢展现。</p><p>如果能解决交通问题，我相信很多人还是愿意住在郊区、住在农村，每天开车去城里上班，而不用住在城中心拥挤的出租房或者监狱一样的格子楼。</p><h2 id="人口红利在消失"><a href="#人口红利在消失" class="headerlink" title="人口红利在消失"></a>人口红利在消失</h2><p>这基本上已经是公认的事实，很多年轻人受过教育，再加上中国不是一个尊重蓝领的社会，所以很多都不太想从事体力劳动，宁愿去拍段子玩抖音也不会去送快递。</p><p>在北上广这样的一些城市，只要你肯吃苦，无论是送快递还是送外卖，这些体力活一个月上万收入不是问题。即使在很多工厂的流水线上面，现在一个月拿5-6000块钱也不是什么难事。</p><p>我们父母这一代现在很多已经50多岁，基本快干不动，90后已经快30岁了，这群人马上就要成为社会主力。在未来，只要是涉及人力的活以后的成本会越来越高，这一点我们可以参考美国等发达社会，蓝领的工资很多时候比在办公室的白领还高，这种趋势势不可挡。</p><h2 id="李子柒式农村生活"><a href="#李子柒式农村生活" class="headerlink" title="李子柒式农村生活"></a>李子柒式农村生活</h2><p>中国的农村在很多人的印象里面只有一个字：穷，农村人几乎已经成了穷人的代言词，现在除了个别风景优美的地区被开发成了风景区，大部分农村和美也沾不上边。</p><p>李子柒给大家营造了一个梦想中的田园生活，而现实中的农村生活往往充满了破败荒芜，每个人都在努力工作努力赚钱，憧憬着买房买车，亦或是为子女忙碌。大部分农村人背井离乡，只为在城里面买房定居，过上更好的生活。</p><img src="/images/2020-02-07-1.jpeg" /> <p>或许当我们无欲无求的时候，才可以像李子柒视频那样潇洒，日出而作，日落而息，双手去耕作，用汗水收获果实。</p><p>农村的田园生活已经离我们太遥远了，在工业化时代，规模经济是趋势，社会分工日益明确，你不用亲手去种植蔬菜，你只需要选择一个可以挣钱的工作就行，你可以是流水线工人，也可以是办公室白领。</p><h2 id="如果"><a href="#如果" class="headerlink" title="如果"></a>如果</h2><p>如果我可以选择，我选择与自然为舞，不被高房价绑架，也不必终日为工作劳累，花更多的时间陪陪家人！你会怎么选？</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;此次疫情爆发，有人说现在农村最安全，因为农村一般都是自建房，分布零散，而城市里面都在小区里面，住在火柴盒一样的格子楼里面，进出同一个楼道，同一个电梯，被感染的几率大很多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我从小在农村长大，自始至今，依然是个农村人（户口还在农村），大学之后，基本上都在城里面上班工作，但是过年还是在老家。有时候早上还在车水马龙、遍布高楼大厦的城里面，晚上就来到了农村蛙声一片的田野边，一个是现代化的城市，另一个是传统的农村，感触十分之深。&lt;/p&gt;
&lt;p&gt;今天我就聊聊我一些关于农村和城市的事和想法，可能比较零散，纯属回忆！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Life" scheme="https://wangbjun.site/categories/Life/"/>
    
    
      <category term="Life" scheme="https://wangbjun.site/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>“武汉肺炎”小记</title>
    <link href="https://wangbjun.site/2020/life/wuhan-ncp.html"/>
    <id>https://wangbjun.site/2020/life/wuhan-ncp.html</id>
    <published>2020-02-06T01:51:06.000Z</published>
    <updated>2020-03-09T02:01:50.176Z</updated>
    
    <content type="html"><![CDATA[<p>截止我写这篇文章的时候，这次肺炎病毒已经感染了数万人，而且还在持续增长！</p><img src="/images/2020-02-06.jpg" /> <p>每天醒来第一件事情就是打开手机，刷新一下数据，从最开始的几百人、到几千人、再到现在的几万人。。。在这里我想说说自己看到或者了解到的一些社会现象，谈谈自己的感受。</p><p>在我的记忆力，2003年还非常遥远，那时候我应该还在上初中，记得那时候学校被封闭，外人不得进出，教室每天早上都会有一股浓厚的消毒水味。</p><a id="more"></a><p>由于我平时也会逛逛油管，在油管上面有很多“时政”自媒体，这也就是一些墙外消息的来源，人所以很早之前也听过一些“谣言”，说说武汉出现SARS病毒了。这种非官方新闻我一般都是半信半疑，在没有确凿证据的情况下也不敢全信，更不敢传播，不然被定个罪就麻烦了。</p><p>2020年1月19日，新闻说北京大兴有2例确诊，当天上班的时候也有很多讨论这件事，这时候很多人开始慌张了，公司前台给大家发口罩，不过我并没有要。</p><p>我当时觉得这事并没有多大，毕竟连政府都没什么行动，北京才2例，觉得很多人有点大惊小怪，有些朋友开始跑医院买口罩，很多医院的口罩卖空，一下子口罩成了稀缺品。晚上坐地铁的时候发现大约有50%的人都戴了口罩。那会我还没有把这事放在心上，因为买不到口罩所以上班也没戴口罩，甚至感觉某些人反应过度，开始拼命的要买口罩。</p><p>我是2020年1月22日的火车，从北京南站出发，那时候我发现候车厅大约80%的人都戴了口罩，感觉事态有点严峻，由于我自己没口罩，所以刻意和其他人保持了距离。</p><img src="/images/2020-01-22.jpeg" /> <p>2020年1月22日晚，坊间传言武汉要封城，我一个朋友这时候正在回家的火车上，她刚好要从武汉转车，听她说车上人都慌了，有人怕封城出不去直接在中途郑州站下车了。后来正式新闻出来了，1月23日10点，武汉正式封城。</p><p>实际上，这会官方数据确诊只有几百人，但是这种封城动作让人胆战心惊，网上各种“谣言”四起，其实很多“谣言”都是来自墙外新闻，我一直也在油管上关注，有人说凡是官方辟谣的都是真的，不管你们信不信，我反正是信了。</p><p>过年这段时间，非常糟糕，在家里哪里都不能去，走亲访友的计划全部取消。。。然后接连不断的新闻爆出: 出门不戴口罩违法、封城、封村、挖坑断路、假期延长、武汉人被举报排挤，只见疫情事态逐步升级！</p><img src="/images/2020-01-27.jpeg" /><p>由于我所在公司宣布2月3日起在家办公，但是我回家的时候并没有电脑，所以我决定2月2日返京。我们那高铁依然正常运行，入站的时候需要测体温，听说我走后第二天村就被封路了。</p><img src="/images/2020-02-02.jpeg" /><p>火车站人确实很少，不过我那车刚好是晚上，本身人就不多，火车上卧铺上我那间6个床位只有我一个人，我走了一圈看了下，大部分床位都没人，看来返京的人确实不多。</p><p>到了北京，我进地铁的时候看见几个安检员在那嬉笑，居然没有给我测体温。网上新闻报道北京很多小区不允许租房的人进小区，我并没有遇到这种情况，只是在门口登记了一下，虽然配备了测温枪，但是那保安并没有给我测量体温。</p><p>有一件意料之外的事情，大家都知道这次疫情对工业、餐饮、娱乐、旅游、交通等很多行业是个致命的打击，可以说整个国家经济都受到影响，损失非常惨重。但是很多小的口罩厂却发财了，这些口罩厂原来多是生产一些工业口罩、一次性普通口罩或者布口罩，原来卖几毛钱一个，利润率非常低，甚至可以说濒临倒闭，现在可以卖几块钱一个，虽然从单价上看并不贵，但是价格缺翻了很多倍。大家知道现在口罩太难买了，我至今出门只戴了一个布口罩，心理安慰是其一，主要是不戴口罩出不了门。短期内很多工厂都开不了工，口罩的缺口依然很大，毕竟中国有14亿人口，平时戴口罩的人很少，市场需求不大，现在人人都要戴口罩，即使所有口罩厂全力生产也无法满足需求，现在连一次性的普通口罩都买不到，更别说什么N95口罩。</p><p>这次病毒什么时候是个头？很多公司原定10号正式返岗上班的计划又遍了，有人说15号或许是个拐点，也有人得到2月底，很多地方的管控越来越严。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;截止我写这篇文章的时候，这次肺炎病毒已经感染了数万人，而且还在持续增长！&lt;/p&gt;
&lt;img src=&quot;/images/2020-02-06.jpg&quot; /&gt; 

&lt;p&gt;每天醒来第一件事情就是打开手机，刷新一下数据，从最开始的几百人、到几千人、再到现在的几万人。。。在这里我想说说自己看到或者了解到的一些社会现象，谈谈自己的感受。&lt;/p&gt;
&lt;p&gt;在我的记忆力，2003年还非常遥远，那时候我应该还在上初中，记得那时候学校被封闭，外人不得进出，教室每天早上都会有一股浓厚的消毒水味。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Life" scheme="https://wangbjun.site/categories/Life/"/>
    
    
      <category term="Life" scheme="https://wangbjun.site/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>一个野生程序员的北漂之路（三）</title>
    <link href="https://wangbjun.site/2020/life/2019-3.html"/>
    <id>https://wangbjun.site/2020/life/2019-3.html</id>
    <published>2020-01-22T06:43:14.000Z</published>
    <updated>2020-03-09T02:01:50.168Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章说到我二家公司由于经营不善，濒临倒闭，拖欠工资，最终我选择自离找工作。</p><p>2018年03月，这次找工作非常顺序，我请假面了大概5个公司拿到2个offer，最后选择了一家我觉得还可以的公司，xx网，工资15k。</p><blockquote><p>xx网实际上是某大型教育公司下面一个部门的网站，专门面向程序员，并不是公司名字，很多学习编程的同学应该看过他们网站的课程。</p></blockquote><p>之前也看过他们网站的课程，觉得很不错，这个部门有100多人，其中技术40多人，在这家公司的上班体验总体还不错，除了每天早上无聊的站会以及每周周会，公司属于业务驱动型，大多做的一些业务开发。</p><p>直到2018年底春节放假那天，技术老大拉我进屋，悄悄告诉我，经过公司决定，你今年没有年终奖，我当时一脸懵逼，问他为什么？</p><a id="more"></a><p>他吞吞吐吐说因为什么线上bug，但是也说不清楚，说只是通知我一声，怕我不了解情况以为是漏发了。</p><p>后来得知不止我一个人，总共有好几个人都没有年终奖，据老员工透露一般没有年终奖的过完年会给n+1，意思就是过完年裁员会给n+1赔偿，公司也不是第一次这样干。</p><img src="/images/20200202152512.jpg" /> <p>其实裁员我可以理解，为什么都是我们年初刚入职的员工呢？了解才得知原来整个公司去年早就换血了，只剩下几个小组leader是老员工，其它都是新来的。</p><p>我更不理解，虽然这一年我表现不算突出，但也算是兢兢业业，努力工作，为什么选择我呢？我想过很多原因，直到离职后来听一个同事说，公司给他们涨薪了，但是名额有限，老大给他自己河南老乡全部涨了…</p><p>我平时大多数都是埋头写代码，不擅长在领导面前表现，一年下来基本上没有和老大聊过什么，他也只在周会的时候会询问项目进度，更别说其它的事情了，如果说bug的话，写代码谁没有bug。</p><p>这时候我突然想起来公司年初的骚操作，年初公司入职的人非常多，正常是3个月试用期，然而就在试用期快结束的时候，有几个同事被告知试用期不合格，被辞退，我在办的入职他们在办离职。如果不合适就不要招人进来，招人之后干了3个月最后一天辞退，这种行为实在恶心。</p><p>过完年回来之后，我在忙完手头的工作，拿了2个月补偿就走了，对这种公司我没有什么留恋，也不想多待一天。</p><img src="/images/20200202152503.jpg" /> <p>公司有一个同事和我比较熟，后来聊天的时候他说他工资比较低，只有12k，老大过年前和他说年后给他涨工资，但是一直到次年6月份都没有兑现，最后他也走了。</p><blockquote><p>后来才得知，这家公司，负责这个项目的老大是销售出身，集团公司给我们部门定了销售KPI，由于远远没有达到预期目标，所以就拿技术开刀，不是第一次这样了，每年都会裁人招人，公司的文化就是这样，谁遇到谁倒霉。</p></blockquote><p>本以为这是一个拥有2000多人的公司，应该会稳定点，没想到我又栽了，又得重新找工作了。</p><hr><p>2019年03月，我重新整理了简历，开始了面试，这时候招聘市场早一年不如一年了，非常艰难，我的直属领导其实还挺好，找关系给我内推了，也给了offer，虽然最后我没去那家公司。</p><p>面了半月，拿到几个offer，有些薪资太低就没去了，有些是因为公司太小，不想去创业公司了。最终去了一家互联网金融集团下面的子公司，这家公司技术团队有200多人，我们部门有15个人，从技术团队建设上说，这家公司其实非常不错，比我去过的所有公司都要好。</p><blockquote><p>刚入职那会我对p2p还没什么概念，虽然也看了新闻，知道国家一直在管理规范p2p，清退一些不合格企业，但是这个公司借贷规模上百亿，也是上市公司，论体量也属于头部公司了，应该没问题。</p></blockquote><img src="/images/20200202154032.jpg" /> <p>2019年07月，董事长突然来公司给大家开了一个临时会议，给大家透露了一些情况，主要就是说政策又变了，公司非常难，他在努力解决困难，公司平台遭到挤兑，暂停提现了，如果大家有人要走，他也不拦着。这时候我才知道事情的严峻性，国家可能不会给p2p活路了。</p><p>一直在公司被抓之前，公司陆续有人离职，也在陆续招人，我们部门走了2个，我心里知道其实早就会有这一天，只是时间问题，但是我没有选择走，一方面是我们部门领导对我还行，中间还给我提了一次涨薪，虽然不多，还有就考虑到我刚来公司不久离职工作也不好找工作，决定再坚持一段时间，心想至少等过完年再看吧。</p><p>那会公司依然正常运行，工资不仅没有拖欠，经常还提前发，公司还给所有人都买了商业医疗补充保险，一切正常，谁也不知道哪一天什么时候到来。</p><p>2019年12月，早上，我还在地铁上，有人在公司群里说公司下面有好几辆警车，还有大巴，让我们先不要进公司，出事了。有些早上到公司的同事电话也打不通，谁也不知道是什么情况，直到下午5点某地公安局在网上发了一个蓝色通告，坐实被抓了。</p><blockquote><p>后来得知，那些同事都被警察安排坐在工位上，没收手机电脑，上厕所有人跟着，中午吃的盒饭，最终下午6点多的时候才放出来，公司所有电脑无论个人还是公司的，全部被查封带走调查了。</p></blockquote><p>领导让我们在家等消息，其实大家心里都清楚，基本上是完了，接连不断的新闻告诉我们，即使公司没有问题，p2p也是完了。。。</p><p>其实公司有没有问题我真不知道，有人担心作为公司员工会被追缴工资，这一点暂时还不确定，目前案件还在审理中，我也是受害者，我还在里面投资了1万多，也一样没有拿出来。</p><p>就这样，我又失业了…</p><hr><p>这几年，不知道是不是该说运气不好，之前的创业公司倒闭很正常，最近2年的公司规模也算比较大，但结局却一样悲惨，正如很多人说的垃圾公司毁一生，选择很重要，你不知道你进的公司是什么公司，特别是很多不出名的中小型公司，你也不知道你会遇到什么样的领导。</p><p>我知道以我现在的简历，很多公司都过不了，很多HR一看就认为跳槽频繁，工作不稳定，再加上非科班出身，出路很少！</p><p>我对自己的评价是工作态度认真负责、学习理解能力强，但是我并不是大牛，也不是那种可以手撸各种算法、精通各种源码和底层原理的技术大佬。</p><p>虽然这些年很多叫我大佬，但我知道那也只是客气话，技术这行了解的越多会发现你不会的更多，而且对于互联网技术现在基本上大家已经形成共识：淘汰快。</p><p>以前觉得技术很厉害，可以改变世界，现在觉得改变世界的其实是商业、是资本，技术只不过是商业工具，有时候也充当打手。</p><p>这几年一直很焦虑，实际上大部分技术人都是这样，总感觉有太多东西要去学，这个算法那个数据结构、xx架构、xx源码解读，卖课的公众号数不胜数，每天都在贩卖焦虑，看不完的技术视频和文章。。。</p><p>我现在甚至不太想去写代码了，这是一份相当枯燥和无聊的工作，你需要去解读产品的X逼需求，应付领导的傻X检查，去做很多和技术无关的工作！而且大部分公司并不重视你的代码质量，他们只关心项目进度，能不能按时上线，能不能为他带来利益。</p><p>最后，就这样吧，谢谢阅读！希望新的一年有新的变化！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章说到我二家公司由于经营不善，濒临倒闭，拖欠工资，最终我选择自离找工作。&lt;/p&gt;
&lt;p&gt;2018年03月，这次找工作非常顺序，我请假面了大概5个公司拿到2个offer，最后选择了一家我觉得还可以的公司，xx网，工资15k。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;xx网实际上是某大型教育公司下面一个部门的网站，专门面向程序员，并不是公司名字，很多学习编程的同学应该看过他们网站的课程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前也看过他们网站的课程，觉得很不错，这个部门有100多人，其中技术40多人，在这家公司的上班体验总体还不错，除了每天早上无聊的站会以及每周周会，公司属于业务驱动型，大多做的一些业务开发。&lt;/p&gt;
&lt;p&gt;直到2018年底春节放假那天，技术老大拉我进屋，悄悄告诉我，经过公司决定，你今年没有年终奖，我当时一脸懵逼，问他为什么？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Life" scheme="https://wangbjun.site/categories/Life/"/>
    
    
      <category term="Life" scheme="https://wangbjun.site/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>一个野生程序员的北漂之路（二）</title>
    <link href="https://wangbjun.site/2020/life/2019-2.html"/>
    <id>https://wangbjun.site/2020/life/2019-2.html</id>
    <published>2020-01-22T01:17:16.000Z</published>
    <updated>2020-03-09T02:01:50.184Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章说到我第一家公司因为融资断裂，发不起工资，解散了。这时候我们开发里面一位大佬，这里我称他为Q哥，他也刚进公司不久，如果按职级分，他应该属于高级开发工程师，平时带我们做项目，也会参与开发，毕竟当时公司开发人员不多。</p><p>当时他说他有个朋友给他介绍了一个公司，这公司非常缺人，可以直接带我们过去，不用技术面试，他和老板聊好了，我们过去见一下老板就行了。</p><a id="more"></a><p>第二天，我们几个人和老板在一个大酒店的套房里面见了面，老板看上去比较老，大概50多岁，叼着雪茄和我们聊了一些他的往事人生以及一些商业战略，最后还请我们吃了一顿简餐。</p><p>搞定了老板基本上就没问题了，老板想让我们直接入职，但公司的HR不答应，最后还给我们安排了一个HR面试，聊了聊人生以及薪资待遇，我没有要求涨薪，其中有一个小伙伴因为薪资没谈拢最后没去，最终Q哥带着我们上家公司总共不到10人空降了该公司。</p><blockquote><p>后来得知，其实这个公司也不完全是缺人，他们之前有一个不到10人的开发团队，但是项目开发进度缓慢，处于失败的边缘。听说老板花了上百万开了一个盛大的发布会，但是APP还没上线，延期很久，老板非常生气，想把技术团队都开除。</p></blockquote><p>我们空降之后，就立马开始了1个多月的封闭开发，加班加点，Q哥也一直盯着开发进度，最终顺利完成了预期目标。作为奖励，年底整个技术团队获得了一次海南三亚游，次年6月，公司搬入望京SOHO，换了一个非常大的办公室。</p><img src="/images/2020-01-03-1.jpg" /> <blockquote><p>后来了解，这老板花钱请了很多大公司的顾问，有几个BAT的技术顾问，也许是出于融资对外宣传需求，给人感觉很强大，而且技术团队之前一直是有这个百度的大佬兼职带队，就是不知道为什么进度缓慢，也没做出什么东西，据说他们之前已经做了一年多了。</p></blockquote><p>APP顺利上线后，看上去公司蒸蒸日上，但运营了几个月后发现并没有什么效果，此时Q哥主要心思不在技术上，甚至说他几乎不管技术，突然搞起运营了，亲自带队搞运营，这也最终导致了他的出走。</p><p>公司失败的原因有很多种，可能是这个老头子最终发现很多人都在围着他转，看上的是他的钱并没有用心做事，再加上他本身喜欢对产品指指点点，喜欢按着自己的想法做，比如说根据自己的想法给APP加一个功能，也从不考虑用户，整个公司说是面向老板开发也不过分。</p><p>2017年10月，由于业务基本上无增长，而且据说一年花了2000万，老板不想再投钱了，公司开始裁员，裁了几个人，办公室也从望京SOHO搬到望京西很偏的一个小商住两用办公楼，各种福利缩减，刚开始工资还能正常发放，后来每月都要拖欠工资，很多人开始离职。</p><img src="/images/2020-01-04-1.jpg" /> <blockquote><p>老板其实挺有钱，早年发家，经常去美国，那边也有业务，家人都在国外，拔过他的背景，也有些黑料，但人并不傻。这次创业应该在我来之前大约2年前就开始了，只不过不是这个公司，这个公司是后来重新注册，应该属于第二波尝试，这样几番折腾，几年下来基本上算是创业失败了。</p></blockquote><p>当时有的人劳动合同到期，公司也表示不再续期，让自己走人，没有什么工作可干，但是公司后面也不再裁员了，但是工资经常拖欠，不能按时发放，等到2018年春节之后，公司很多人都在找工作，我也趁机走了。</p><blockquote><p>不过还有同事没走继续在那边干，听他说后来没走的人每个月工资只发了一半，到最后人基本上都跑光了，可以说结果很悲催。</p></blockquote><p>我上一家公司虽然也是创业公司，但是最后起码好聚好散，但这家公司了老板最终选择故意拖欠工资逼你自己离职，当时很多人说要一起去告公司，不最终还是不了了之。</p><p>说到Q哥，我对他非常感激，他人很不错，但是说实话缺少领导力，感激是因为他带我进入这家公司，虽然最后发现是个火坑，但是这也不能怪他，谁也无法预料后来的事情。还有一点不信任是因为他后来的行为，他在这家公司大部分时间并没有管理技术，没有当好CTO，却去插上并扛下运营和产品，最终由于他的运营方案失败，自己出走，留下我们几个人不知所措。</p><p>他出走之后却又带着一位同事进入另一家类似公司，而这家公司一直是用比较传统的方法运营，但是其互联网这块是从零开始，老板据说是从华为出来，印象挺深的是我们第一次Q哥带我们和他见面的时候，刚下班还没吃晚饭，他说请我们吃饭，最后带着我们几个人在路边找了家面馆一人吃了一碗面，场面甚是尴尬！</p><p>Q哥说他技术入股，先带一个人过去，又拉了一个他以前的同事，等这边搞起来后期我们一起再过去。</p><p>可是好景不长，这家公司只持续了几个月，他们第一版东西做完之后，这个华为出来的老板居然打了退堂鼓，不想干了，不仅没有和他们签合同，连工资都一直拖着不发，最后沟通很久说可以搬电脑抵工资。。。结局就是就这么狗血！</p><p>这时候Q哥说又有朋友介绍一家新公司，说这家公司就是为了上市，资金实力雄厚，他以顾问的身份进去，可以推荐我们进去。。。说实话，经过这么多，我有点怕了，怕了创业公司。。。另外对Q哥的信任度也大大降低!</p><img src="/images/2020-01-17.jpg" /> <blockquote><p>Q哥是第一代北漂，比我们大不了多少岁，也是农村出来，但是来的早，赶上了IT行业发展的黄金时代，而且那会北京房价也不高，现在在北京有房有车，老婆孩子都很好，在我看来，算上成功人士了。但他自己好像并不是这么觉得，他觉得自己还没财务自由，总想做点事情出来，30多岁也算年轻，不想写代码，创业是个不错的选择。</p></blockquote><p>但是我其实并不想把所有宝都压在创业上面，我其实想找一个相对稳定的公司，所以后来他让我去他那边公司的时候我犹豫了，我最后决定自己投简历…</p><blockquote><p>虽然很久没有和Q哥聊了，但是知道他一直在创业，现在在做一个教育相关的小程序，希望他早日创业成功！</p></blockquote><p>这1年多，看尽了创业公司的各种结局，很多小创业公司九死一生，但是结局却各不相同。很多创业公司倒闭并不是因为技术，大部分都是因为商业模式，或者说是运营不起来，没有市场等各种原因，总之，创业难，想创业成功更难。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章说到我第一家公司因为融资断裂，发不起工资，解散了。这时候我们开发里面一位大佬，这里我称他为Q哥，他也刚进公司不久，如果按职级分，他应该属于高级开发工程师，平时带我们做项目，也会参与开发，毕竟当时公司开发人员不多。&lt;/p&gt;
&lt;p&gt;当时他说他有个朋友给他介绍了一个公司，这公司非常缺人，可以直接带我们过去，不用技术面试，他和老板聊好了，我们过去见一下老板就行了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Life" scheme="https://wangbjun.site/categories/Life/"/>
    
    
      <category term="Life" scheme="https://wangbjun.site/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>一个野生程序员的北漂之路（一）</title>
    <link href="https://wangbjun.site/2020/life/2019-1.html"/>
    <id>https://wangbjun.site/2020/life/2019-1.html</id>
    <published>2020-01-21T15:32:27.000Z</published>
    <updated>2020-03-09T02:01:50.148Z</updated>
    
    <content type="html"><![CDATA[<p>虽然2020年已经到来，但是真正象征着新的一年的农历新年才刚刚开始，北漂4年多，IT这条路越走越窄，突然萌生出回家的念头，毕竟年龄也不小，算是90后最早一批奔三的人，还未成家，也谈不上立业。</p><p>在此回顾一下这些年在北京这几年的职业生涯，作为一种记录，也算是总结吧！</p><p>这些年在北京，工作换了很多个，几乎每年面试一次，微信里面同事倒是加了不少，除了聊的好的几个，大部分再也不联系。住的地方也是一年换一次，住过上下铺、地下室、天通苑、自如、一居室。。。</p><ul><li>2016年06月 第一家公司 –&gt; 融资失败、解散</li><li>2016年11月 第二家公司 –&gt; 濒临倒闭、欠薪</li><li>2018年03月 第三家公司 –&gt; 经营不善、裁员</li><li>2019年03月 第四家公司 –&gt; 涉及p2p、查封</li></ul><a id="more"></a><p>2015年10月，也许是在外漂泊够了（在此之前我一直在从事一份非常自由的工作），腰里揣着几万块钱，我决定来北京，去报名某智的培训班，学习Java。</p><p>为什么我要这么做？主要是因为从大学时代开始，我对编程就非常感兴趣，写过一点C，经常喜欢看一些关于计算机和网络的书籍，但是当时没有想过深入的学习，更没有想过毕业后会从事该行业，那时候纯粹是一些兴趣爱好。后在2013年的时候，在网上看到一些自学成才的例子，开始有这个想法，在家里自学过半年Java，买了几本书，也看了不少视频，但是最终因为各种原因并没有实际去找相关工作，曾经考虑过进培训班，但是当时也没钱就打消了这个念头，后来误打误撞去干别的事情了。</p><blockquote><p>现在回想起来，当时犯了一些错：单打独斗、学习效率不高、缺乏自信。主要是缺乏有经验的人指导，如果坚持下去或许是另一种结果，毕竟2013年那会IT的工作很好找，不像现在年年寒冬，各种裁员。</p></blockquote><p>时间回到2015年10月，这时候我已经有一定的经济能力，但是工作依然不稳定和明朗，也不知道该干啥去，但是觉得不能一直这么干下去，最终选择来北京培训，这个培训班的学费也从当年的几千块涨到1万多，不过尚可以接受。</p><p>不过最终报名的时候我选择了PHP，并没有学习Java，我当时主要是因为有人说PHP适合个人等中小型开发，而Java主要适合大型企业公司，其实现在这个说法也没错，但是当时我并不了解其实国内大厂都是Java的天下，PHP最终走向穷途末路。</p><img src="/images/2020-01-02.jpg" />  <p>由于我几年前学过C和Java，相当于有基础，所以在培训班非常轻松，很多知识似曾相识，甚至觉得老师讲的太无聊，基本上就是照本宣书，填鸭式教学。同时也发现培训班就像高中一样，有很多学习能力超级差的同学，也有学习能力强的人，我旁边有一些让我感觉属于那种怎么教都教不会的人，非常可惜他们听了培训机构的忽悠，花了很多钱，最终可能无法找到工作。</p><blockquote><p>那会我开始研究Linux，天天折腾Ubuntu，还有Kali，最有意思的是我用Kali的木马工具生成一些木马，然后利用PHP一句话木马攻破讲师的电脑，远程控制其电脑，还在其电脑上找到了我们班所有人的信息。<br>还有，比如说控制某些女生的电脑，打开其摄像头。。。不过纯属搞笑娱乐，并没有做一些过分的事情。</p></blockquote><p>在培训的这几个月里面，我真正学到东西不是很多，培训班大部分讲的东西都很基础，而且枯燥，老师每一个知识点写一个demo，缺乏编程思想层次的指导。对我来说最大的意义在于这段培训经历帮我建立了自信，因为我发现在所有的同学中我即使不是能力最强的，也是属于前排，心里对自己的能力有了一个定位。</p><p>时间过的很快，半年后，2016年5月，我们开始找工作了，出于无耐，我编了一个1年经验的简历，也有一些同学编了2-3年，还有更过分的则是造假学历、假毕业证，虽然这些都是培训机构默认的常规操作。</p><p>我这个人本身就不属于那种会说的人，以前撒谎都会脸红那种，虽然进入社会好几年但是依然无法做到游刃有余，在找了差不多半个月，面试了10几家公司之后终于拿到一个offer，虽然公司不大也是创业公司有10来个开发，但是毕竟是一个开始，工资是12k，社保最低缴纳，对我来说已经很好了，据说在所有的同学中算高的了，可能是因为我有一个本科学历吧，那时候大部分培训的同学都是专科。</p><blockquote><p>那会2016年正是创业潮，初创企业层出不穷，所以市场对开发人员有很大需求，所以像我这种半路出家的非科班选手依然有市场。</p></blockquote><p>第一次正式参加公司的编程开发工作，心里还有点紧张，很努力，不过也基本上都hold住了，然而这段工作并没有维持多久。。。</p><img src="/images/2020-01-03.jpg" /> <p>2016年11月，公司突然撑不住了。我之前一直没有关注这方面的消息，直到某一天老板说公司融资断了，发不起工资了，如果大家继续留下来也没有工资发，晚上一起吃个散伙饭吧！</p><p>那天是当月的20号，公司最后给每个人发了3000块钱，剩下的说先欠着，等哪天融到钱会第一时间给大家发工资，也可以继续回来工作，公司40多号人没有一个人提赔偿的事情，大家吃完饭喝完酒默默走人了，毕竟老板平时为人不错，不摆架子，好聚好散。</p><blockquote><p>这几年一直和其中一个同事有联系，听他说公司并没有倒闭，留了几个老员工做一些维护和少量开发工作，他就是其一。老板也在一直拉投资，客户也一直在增长，那年与其说倒闭，不如说是壮士断臂。在2018年底的时候，他和我说公司拉到了一笔投资，也不多，大概有几百万，公司正在招人扩大规模。我一直相信老板的话，觉得公司融到钱后把欠我们的半个月工资还给我们，事实上，至今老板从未和我们谈过这件事，我也未去询问过。不过我还是非常佩服这位老板的耐心和毅力，祝他早日能创业成功。</p></blockquote><p>在工作了还不到半年的时候，突然间我又失业了，又得重新找工作，但是事情却另有转机。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然2020年已经到来，但是真正象征着新的一年的农历新年才刚刚开始，北漂4年多，IT这条路越走越窄，突然萌生出回家的念头，毕竟年龄也不小，算是90后最早一批奔三的人，还未成家，也谈不上立业。&lt;/p&gt;
&lt;p&gt;在此回顾一下这些年在北京这几年的职业生涯，作为一种记录，也算是总结吧！&lt;/p&gt;
&lt;p&gt;这些年在北京，工作换了很多个，几乎每年面试一次，微信里面同事倒是加了不少，除了聊的好的几个，大部分再也不联系。住的地方也是一年换一次，住过上下铺、地下室、天通苑、自如、一居室。。。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2016年06月 第一家公司 –&amp;gt; 融资失败、解散&lt;/li&gt;
&lt;li&gt;2016年11月 第二家公司 –&amp;gt; 濒临倒闭、欠薪&lt;/li&gt;
&lt;li&gt;2018年03月 第三家公司 –&amp;gt; 经营不善、裁员&lt;/li&gt;
&lt;li&gt;2019年03月 第四家公司 –&amp;gt; 涉及p2p、查封&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Life" scheme="https://wangbjun.site/categories/Life/"/>
    
    
      <category term="Life" scheme="https://wangbjun.site/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github搭建免费技术博客</title>
    <link href="https://wangbjun.site/2020/linux/hexo-github-blog.html"/>
    <id>https://wangbjun.site/2020/linux/hexo-github-blog.html</id>
    <published>2020-01-08T04:05:45.000Z</published>
    <updated>2020-03-03T02:51:12.386Z</updated>
    
    <content type="html"><![CDATA[<p>最近想搭建了一个自己的博客网站，经过调研，最终决定使用Hexo+Github的形式搭建，大概花了3个小时的时间，这里简单记录一下过程，备用。</p><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>Github提供了一个免费的GIthub Pages功能，简单说就是可以让你存放静态的资源文件，比如css、js、html、image，同时会给你分配一个免费域名，格式：<a href="https://xxx.github.io" target="_blank" rel="noopener">https://xxx.github.io</a></p><p>所以你只需要注册一个Github账号，然后新建一个repository就行了，一毛线都不用花。</p><p>由于Github Pages只能托管静态资源，所以像WordPress这类博客肯定是无法运行的，这时候你有2种选择：</p><ol><li>手写静态页面，如果是前端大牛可以尝试这样</li><li>第三方博客工具生成，如Hexo、jekyll</li></ol><a id="more"></a><p>简单说，Hexo就是一个工具，它可以根据markdown文档自动生成博客的静态HTML页面，同时呢，你还可以一键换主题，网上有很多开源的主题。</p><p>Hexo 和 Github这2个完全可以单独使用，但是把2个结合起来就完美了，一个用来生成博客的静态文件，一个用户托管静态资源，服务器和域名都省了。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol><li><p>我不会告诉你如何注册Github账号、以及安装使用Git，作为一名编程开发人员应该都会</p></li><li><p>我其实也不想告诉你如何安装npm和node，但是我还是放个下载地址：<a href="https://nodejs.org/zh-cn" target="_blank" rel="noopener">https://nodejs.org/zh-cn</a></p></li></ol><h2 id="Hexo应用"><a href="#Hexo应用" class="headerlink" title="Hexo应用"></a>Hexo应用</h2><h3 id="安装运行环境"><a href="#安装运行环境" class="headerlink" title="安装运行环境"></a>安装运行环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装完成后，在命令行下执行hexo，应该可以看到以下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">jwang@jun:~$ hexo</span><br><span class="line">Usage: hexo &lt;command&gt;</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  help     Get help on a command.</span><br><span class="line">  init     Create a new Hexo folder.</span><br><span class="line">  version  Display version information.</span><br><span class="line"></span><br><span class="line">Global Options:</span><br><span class="line">  --config  Specify config file instead of using _config.yml</span><br><span class="line">  --cwd     Specify the CWD</span><br><span class="line">  --debug   Display all verbose messages in the terminal</span><br><span class="line">  --draft   Display draft posts</span><br><span class="line">  --safe    Disable all plugins and scripts</span><br><span class="line">  --silent  Hide output on console</span><br><span class="line"></span><br><span class="line">For more help, you can use &#39;hexo help [command]&#39; for the detailed information</span><br><span class="line">or you can check the docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;</span><br></pre></td></tr></table></figure><p>这里只是列出一部分命令，比较重要的就是init，它是用来创建一个新项目</p><h3 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p>文件夹名字自己起一个，它自动生成一个目录，里面文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── _config.yml</span><br><span class="line">├── db.json</span><br><span class="line">├── package.json</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><blockquote><p>简单说明一下，比较重要是有_config.yml文件,这是博客的配置，另外themes下是存放主题的目录，还有source下面的 _posts 目录，是博客文章markdown的源文件。</p></blockquote><p>然后我们进入该目录，生成静态文件并启动服务预览一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd blog</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>默认启动在本地4000端口，可以通过 -p 指定端口</p><h3 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &lt;article-name&gt;</span><br></pre></td></tr></table></figure><p>其实有2种方式写文章，一种是使用上述命令 new 一个，它会自动在source目录的_posts里面创建一个markdown文件。另一种就是你自己手动创建。</p><p>但是注意，文章头部会有一些注解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: Hexo+Github搭建免费技术博客</span><br><span class="line">date: 2020-01-08 12:05:45</span><br><span class="line">tags: Hexo</span><br><span class="line">category: 其它</span><br></pre></td></tr></table></figure><p>Hexo在生成静态页面的时候会解析这些注解，然后做一些处理，比如tags是标签、category是文章分类，都会用到。</p><p>不要忘记，每次更新文章之后，都需要执行<code>hexo g</code>重新生成静态页面。</p><h2 id="部署到GitPages"><a href="#部署到GitPages" class="headerlink" title="部署到GitPages"></a>部署到GitPages</h2><p>上面介绍如何使用Hexo生成博客，但是这时候只能在本地玩，如果你有自己的服务器的话，也可以不用GitPages，你把生成的静态文件，也就是public目录下的文件部署到你自己的服务器就行了。</p><p>如果你想部署到GitPages，那么继续接着看</p><blockquote><p>有一点需要注意，在创建GitPage仓库的时候，仓库名字最好是: 你的用户名.github.io 这种格式，如果不这样其实也行，就是分配的域名有点丑，比如说你仓库名字叫blog，那么域名就会变成 xxx.github.io/blog</p></blockquote><p>打开Hexo的配置文件_config.yml，修改repo为刚创建的仓库地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;YourgithubName&#x2F;YourgithubName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>为了更好的提交代码，我们需要安装一个插件 <code>npm install hexo-deployer-git --save</code></p><p>然后，我们使用<code>hexo d</code>就可以把代码提交到Github仓库了。</p><blockquote><p>等等。。。有人说网上很多文章还说要配置什么ssh秘钥，其实这块我觉得不是必须的，只是为了更方便的提交代码而已，具体步骤这里不再赘述。</p></blockquote><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>Hexo更换主题特别简单，只需要把主题文件夹clone到themes文件里面，然后修改_config.yml里面的 theme 配置项。</p><p>详细的步骤我这里就不解释了，你可以在Github使用 “hexo themes”关键字搜索，然后按照其readme文档说明安装即可，非常简单。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>如果你配置了ssh秘钥，则必须把deploy配置里的repo配置 https 地址改成 ssh 地址。</li><li>很多主题都有一个自己的_config.yml配置文件，里面有一些详细配置，比如是Next这个主题默认没有打开分类和标签项，需自己配置。</li><li>如果想实现“阅读全文”这种效果，有2种方式，第一种是需自己在markdown里合适的位置作注解，默认是 <code>&lt;!--more--&gt;</code>，还有一种在主题的配置里面，可以自动根据字数折叠，但是默认不推荐这种方式。</li><li>每个主题都有很多自定义的配置项，比如样式、字体、评论、浏览数，很多默认都没开启，可以好好看一下，都有注释。</li><li>最重要的一点，所有的东西都是开源的，如果你觉得很多样式或者细节不合适完全可以打开模板修改定制。</li></ol><p>最后，如果你闲麻烦，觉得我的博客还可以，想参考一下可以访问我的<a href="https://github.com/wangbjun/blog_hexo" target="_blank" rel="noopener">Github</a>，所有的文件和配置都在里面，欢迎采用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近想搭建了一个自己的博客网站，经过调研，最终决定使用Hexo+Github的形式搭建，大概花了3个小时的时间，这里简单记录一下过程，备用。&lt;/p&gt;
&lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;Github提供了一个免费的GIthub Pages功能，简单说就是可以让你存放静态的资源文件，比如css、js、html、image，同时会给你分配一个免费域名，格式：&lt;a href=&quot;https://xxx.github.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://xxx.github.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以你只需要注册一个Github账号，然后新建一个repository就行了，一毛线都不用花。&lt;/p&gt;
&lt;p&gt;由于Github Pages只能托管静态资源，所以像WordPress这类博客肯定是无法运行的，这时候你有2种选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;手写静态页面，如果是前端大牛可以尝试这样&lt;/li&gt;
&lt;li&gt;第三方博客工具生成，如Hexo、jekyll&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://wangbjun.site/categories/Linux/"/>
    
    
      <category term="Hexo" scheme="https://wangbjun.site/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>解决Golang测试配置文件加载问题</title>
    <link href="https://wangbjun.site/2019/coding/golang/golang-gin-config.html"/>
    <id>https://wangbjun.site/2019/coding/golang/golang-gin-config.html</id>
    <published>2019-11-19T03:49:25.000Z</published>
    <updated>2020-03-09T01:56:24.567Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写Go的项目，使用的框架是Gin，众所周知，Gin是一个比较简单的框架，只提供了核心功能，并没有配置文件模块，所以这块得自己搞了，Go的第三方解析配置的库非常多，无论是ini、yaml、json文件支持都非常好，而且Go的项目一般都是常驻进程的，所以只需要在项目启动的时候解析一次就行可以了。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>最简单的办法通常就是定义一个全局的配置变量供其它包使用，在init函数里面初始化加载配置文件，示例如下：</p><a id="more"></a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> config</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"gopkg.in/ini.v1"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Conf Config</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    App      App</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> App <span class="keyword">struct</span> &#123;</span><br><span class="line">    Port    <span class="keyword">string</span></span><br><span class="line">    Debug   <span class="keyword">string</span></span><br><span class="line">    Url     <span class="keyword">string</span></span><br><span class="line">    LogFile <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    envFile := <span class="string">"app.ini"</span></span><br><span class="line">    conf, err := ini.Load(envFile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Panicf(<span class="string">"parse conf file [%s] failed, err: %s"</span>, envFile, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    sectionApp := conf.Section(<span class="string">"APP"</span>)</span><br><span class="line">    Conf.App = App&#123;</span><br><span class="line">        Port:    sectionApp.Key(<span class="string">"PORT"</span>).String(),</span><br><span class="line">        Debug:   sectionApp.Key(<span class="string">"DEBUG"</span>).String(),</span><br><span class="line">        Url:     sectionApp.Key(<span class="string">"URL"</span>).String(),</span><br><span class="line">        LogFile: sectionApp.Key(<span class="string">"LOG_FILE"</span>).String(),</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">"init config file success"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，入口文件main.go文件都是位于项目根目录下面，和app.ini文件同级，所以这种写法完全没问题。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>但是当你跑测试用例的时候，而且当这个测试用例并不在项目根目录的时候就会产生问题: 找不到配置文件。</p><p>原因很简单，Go的测试用例最佳实践是和被测试的文件放在一起，所以测试文件可能在二级、三级甚至多级目录里面，如下图：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">├── app.ini</span><br><span class="line">├── config</span><br><span class="line">│   ├── Config.go</span><br><span class="line">│   └── DataBase.go</span><br><span class="line">├── controller</span><br><span class="line">│   ├── BaseController.go</span><br><span class="line">├── lib</span><br><span class="line">│   ├── <span class="keyword">function</span></span><br><span class="line">│   │   ├── Aes.go</span><br><span class="line">│   │   ├── Rsa.go</span><br><span class="line">│   │   ├── Rsa_test.go</span><br><span class="line">│   │   └── Uuid.go</span><br><span class="line">│   ├── httpLogger</span><br><span class="line">│   │   └── HttpLogger.go</span><br><span class="line">│   └── zlog</span><br><span class="line">│       ├── SqlLog.go</span><br><span class="line">│       └── ZapLogger.go</span><br><span class="line">├── main.go</span><br></pre></td></tr></table></figure><p>所以在测试文件的目录下肯定是找不到app.ini的，咋办呢？解决方法有很多</p><ul><li><p>copy一个配置到测试文件。这种方法最简单粗暴，但是太不灵活，测试用例可能在任何目录里面，这样搞有点难受</p></li><li><p>配置文件路径写成绝对路径。这种方法也不灵活，毕竟每个人的项目目录位置不一样，以后线上部署也麻烦</p></li><li><p>采用依赖注入的高级写法，测试的时候使用mock的方式注入配置。这种方法可以，也是比较好的方式，但是需要引入依赖注入组件，整个项目的架构需要更改，不推荐使用依赖注入把简单的问题复杂化。</p></li><li><p>跑测试的时候传入外部参数，依然不够灵活，而且麻烦</p></li></ul><p>这个问题，我思考了很久，最终想了一个足够简单灵活的方式，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">envFile := <span class="string">"app.ini"</span></span><br><span class="line"><span class="comment">// 读取配置文件, 解决跑测试的时候找不到配置文件的问题，最多往上找5层目录</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err := os.Stat(envFile); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        envFile = <span class="string">"../"</span> + envFile</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">conf, err := ini.Load(envFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Panicf(<span class="string">"parse conf file [%s] failed, err: %s"</span>, envFile, err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一个for循环解决了这个问题，如果怕不够保险，可以改成10，大多数项目目录应该不会这么深，虽然不够优雅，但是还是相对比较简单的。</p><p>各位有什么更好的方法吗？有的话请留言指教</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在写Go的项目，使用的框架是Gin，众所周知，Gin是一个比较简单的框架，只提供了核心功能，并没有配置文件模块，所以这块得自己搞了，Go的第三方解析配置的库非常多，无论是ini、yaml、json文件支持都非常好，而且Go的项目一般都是常驻进程的，所以只需要在项目启动的时候解析一次就行可以了。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h2&gt;&lt;p&gt;最简单的办法通常就是定义一个全局的配置变量供其它包使用，在init函数里面初始化加载配置文件，示例如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="https://wangbjun.site/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.site/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Golang的recover异常处理机制</title>
    <link href="https://wangbjun.site/2019/coding/golang/golang-recover.html"/>
    <id>https://wangbjun.site/2019/coding/golang/golang-recover.html</id>
    <published>2019-11-10T12:22:04.000Z</published>
    <updated>2020-03-09T01:56:24.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-error"><a href="#1-error" class="headerlink" title="1.error"></a>1.error</h2><p>Golang被诟病非常多的一点就是缺少强大方便的异常处理机制，大部分高级编程语言，比如Java、PHP、Python等都拥有一种try catch机制，这种异常捕获机制可以非常方便的处理程序运行中可能出现的各种意外情况。</p><p>严格来说，在Go里面，错误和异常是2种不同的类型，错误一般是指程序产生的逻辑错误，或者意料之中的意外情况，而且异常一般就是panic，比如角标越界、段错误。</p><a id="more"></a><p>对于错误，Golang采用了一种非常原始的手段，我们必须手动处理可能产生的每一个错误，一般会把错误返回给调用方，下面这种写法在Go里面十分常见：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s, err := say()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%s\n"</span>, err.Error())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%s\n"</span>, s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"something error"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法最大的问题就是每一个error都需要判断处理，非常繁琐，如果使用try catch机制，我们就可以统一针对多个函数调用可能产生的错误做处理，节省一点代码和时间。不过咱们今天不是来讨论Go的异常错误处理机制的，这里只是简单说一下。</p><h2 id="2-panic"><a href="#2-panic" class="headerlink" title="2.panic"></a>2.panic</h2><p>一般错误都是显示的，程序明确返回的，而异常往往是隐示的，不可预测的，比如下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, cal(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, cal(<span class="number">5</span>,<span class="number">2</span>))</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, cal(<span class="number">5</span>,<span class="number">0</span>)) <span class="comment">//panic: runtime error: integer divide by zero </span></span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, cal(<span class="number">9</span>,<span class="number">5</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行第三个计算的时候会发生一个panic，这种错误会导致程序退出，下面的代码的就无法执行了。当然你可以说这种错误理论上是可以预测的，我们只要在cal函数内部做好处理就行了。</p><p>然而实际开发中，会发生panic的地方可能特别多，而且不是这种一眼就能看出来的，在Web服务中，这样的panic会导致整个Web服务挂掉，特别危险。</p><h2 id="3-recover"><a href="#3-recover" class="headerlink" title="3.recover"></a>3.recover</h2><p>虽然没有try catch机制，Go其实有一种类似的recover机制，功能弱了点，用法很简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, cal(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, cal(<span class="number">5</span>, <span class="number">2</span>))</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, cal(<span class="number">5</span>, <span class="number">0</span>))</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, cal(<span class="number">9</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%s\n"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，大家得理解defer的作用，简单说defer就类似于面向对象里面的析构函数，在这个函数终止的时候会执行，即使是panic导致的终止。</p><p>所以，在cal函数里面每次终止的时候都会检查有没有异常产生，如果产生了我们可以处理，比如说记录日志，这样程序还可以继续执行下去。</p><h2 id="4-注意的坑"><a href="#4-注意的坑" class="headerlink" title="4.注意的坑"></a>4.注意的坑</h2><p>一般defer recover这种机制经常用在常驻进程的应用，比如Web服务，在Go里面，每一个Web请求都会分配一个goroutine去处理，在没有做任何处理的情况下，假如某一个请求发生了panic，就会导致整个服务挂掉，这是不可接受的，所以在Web应用里面必须使用recover保证即使某一个请求发生错误也不影响其它请求。</p><p>这里我使用一小段代码模拟一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    requests := []<span class="keyword">int</span>&#123;<span class="number">12</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">41</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">31</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> n := <span class="keyword">range</span> requests &#123;</span><br><span class="line">        <span class="keyword">go</span> run(n) <span class="comment">//开启多个协程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//模拟请求错误</span></span><br><span class="line">    <span class="keyword">if</span> num%<span class="number">5</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"请求出错"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码无法完整执行下去，因为其中某一个协程必然会发生panic，从而导致整个应用挂掉，其它协程也停止执行。</p><p>解决方法和上面一样，我们只需要在run函数里面加入defer recover，整个程序就会非常健壮，即使发生panic，也会完整的执行下去。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>();err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%s\n"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">if</span> num%<span class="number">5</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"请求出错"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码只是演示，真正的坑是：如果你在run函数里面又启动了其它协程，这个协程发生的panic是无法被recover的，还是会导致整个进程挂掉,我们改造了一下上面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%s\n"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">if</span> num%<span class="number">5</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"请求出错"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> myPrint(num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myPrint</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> num%<span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"请求又出错了"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在run函数里面又通过协程的方式调用了另一个函数，而这个函数也会发生panic，你会发现整个程序也挂了，即使run函数有recover也没有任何作用，这意味着我们还需要在myPrint函数里面加入recover。但是如果你不使用协程的方式调用myPrint函数，直接调用的话还是可以捕获recover的。</p><p>总结一下就是defer recover这种机制只是针对当前函数和以及直接调用的函数可能产生的panic，它无法处理其调用产生的其它协程的panic，这一点和try catch机制不一样。</p><p>理论上讲，所有使用协程的地方都必须做defer recover处理，这样才能保证你的应用万无一失，不过开发中可以根据实际情况而定，对于一些不可能出错的函数加了还影响性能。</p><p>Go的Web服务也是一样，默认的recover机制只能捕获一层，如果你在这个请求的处理中又使用了其它协程，那么必须非常慎重，毕竟只要发生一个panic，整个Web服务就会挂掉。</p><p>最后，总结一下，Go的异常处理机制虽然没有很多其它语言高效，但是基本上还是能满足需求，目前官方已经在着完善这一点，Go2可能会见到。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-error&quot;&gt;&lt;a href=&quot;#1-error&quot; class=&quot;headerlink&quot; title=&quot;1.error&quot;&gt;&lt;/a&gt;1.error&lt;/h2&gt;&lt;p&gt;Golang被诟病非常多的一点就是缺少强大方便的异常处理机制，大部分高级编程语言，比如Java、PHP、Python等都拥有一种try catch机制，这种异常捕获机制可以非常方便的处理程序运行中可能出现的各种意外情况。&lt;/p&gt;
&lt;p&gt;严格来说，在Go里面，错误和异常是2种不同的类型，错误一般是指程序产生的逻辑错误，或者意料之中的意外情况，而且异常一般就是panic，比如角标越界、段错误。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="https://wangbjun.site/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.site/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Protobuf入门和实战</title>
    <link href="https://wangbjun.site/2019/coding/golang/golang-protobuf.html"/>
    <id>https://wangbjun.site/2019/coding/golang/golang-protobuf.html</id>
    <published>2019-10-22T09:15:43.000Z</published>
    <updated>2020-03-09T01:56:24.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>Protobuf（Google Protocol Buffer）是 Google公司内部的混合语言数据标准，目前已经开源，支持多种语言（C++、C#、Go、JS、Java、Python、PHP），它是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。</p><p>说简单点，Protobuf就是类似JSON、XML这样的数据交换格式，当今互联网JSON是最流行的格式了，XML用的也挺多，最初接触到Protobuf是因为gRPC默认使用它作为数据编码，相比于JSON和XML，它更小，更快！</p><a id="more"></a><p>举个例子：如果我们想表达一个人名字叫John，年龄是28岁，邮箱是<a href="mailto:jdoe@gmail.com">jdoe@gmail.com</a>这样的结构化数据，并且需要在互联网上传输</p><ul><li><p>使用XML表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;person&gt;</span><br><span class="line">   &lt;name&gt;John&lt;&#x2F;name&gt;</span><br><span class="line">   &lt;age&gt;28&lt;&#x2F;age&gt;</span><br><span class="line">   &lt;email&gt;jdoe@example.com&lt;&#x2F;email&gt;</span><br><span class="line"> &lt;&#x2F;person&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用JSON表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: John,</span><br><span class="line">    age: 28,</span><br><span class="line">    email: jdoe@example.com</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用Protobuf表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message Person &#123;</span><br><span class="line">    string name &#x3D; 1;</span><br><span class="line">    int32 age &#x3D; 2;</span><br><span class="line">    string email &#x3D; 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>从可读性和表达能力上看，XML最好，JSON其次，而Protobuf这个其实只是一个DSL，用来定义数据结构和类型，实际生成的数据是二进制的，不可读，但Protobuf追求的是性能和速度，关于它们之间的对比，后面再说，咱们先说用法。</p><h2 id="2-安装环境"><a href="#2-安装环境" class="headerlink" title="2.安装环境"></a>2.安装环境</h2><p>Protobuf的使用比较麻烦，首先需要安装Protobuf的编译工具(Protocol Buffers compiler)，Ubuntu环境下自带编译环境，其它平台可自行安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jwang@jwang:~$ protoc --version</span><br><span class="line">libprotoc 3.8.0</span><br></pre></td></tr></table></figure><p>然后还需要安装不同语言的运行环境，具体可以参考<a href="https://github.com/protocolbuffers/Protobuf" target="_blank" rel="noopener">github.com/protocolbuffers/Protobuf</a></p><h2 id="3-编写proto文件"><a href="#3-编写proto文件" class="headerlink" title="3.编写proto文件"></a>3.编写proto文件</h2><p>proto其实是一种DSL语法，这个proto文件最终会使用protoc编译成不同语言的文件，然后在程序里面调用，这也是Protobuf跨平台的关键。关于proto文件的语法这里不详细介绍，建议大家参考<a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="noopener">官方文档</a>，东西很多，也很详细。</p><p>我这里拿一个简单实际的例子（person.proto）来说明一下，建议大家使用Goland安装一个插件，这样有颜色还可以检查语法：</p><ul><li>第一行syntax是声明proto语法版本，如果不声明默认是2，建议使用3版本</li><li>然后是package也就包，这个影响到最后生成的go文件的包</li><li>后面message是用来声明一个数据对象，我觉得可以理解为结构体struct，这个数据对象有自己的数据成员，每个字段有类型和默认值。</li><li>proto的数据类型有标量类型和枚举类型，由于不同语言的数据类型不太一样，所以这里的类型和实际语言的类型有一个对应转换关系，具体可以参考官方文档</li><li>repeated 相当于声明一个数组，比如在上面的例子，意思就是car是一个string类型的数组</li><li>message可以嵌套声明，也可以引用一个类型</li><li>最迷惑的东西估计就是后面那个1,2,3,4…了，据官方文档的说法是为了在二进制格式里面标记数据，在每一个message里面必须是唯一的，从最小的1开始，一直可以到2的29次方-1，也就是536870911，但是19000到19999是保留的数字。</li></ul><p>基本语法还是挺简单的，不过有些深入的用法这里没有介绍到，想要了解的话务必查看官方文档，不过定义数据结构和类型只是第一步，接下来我们还要使用protoc把这个文件编译成对应语言的文件。</p><h2 id="4-编译proto文件"><a href="#4-编译proto文件" class="headerlink" title="4.编译proto文件"></a>4.编译proto文件</h2><p>以Go语言为例，建议切换到proto文件目录执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out&#x3D;. person.proto</span><br></pre></td></tr></table></figure><p>其中–go_out表示输出go版本的，其它语言把go替换就行了，比如–php_out、–java_out,=后面是需要输出的目录，我选择.表示当前目录，当然你也可以指定输入和输出目录，最后面则是需要编译的文件，可以指定单个文件，也可以使用通配符同时编译多个文件。</p><p>执行完命令之后，你会发现当前目录多了一个person.pb.go文件，这是一个标准的go语法文件，里面主要是一个结构体和一些getter函数，其它的我也不太懂是什么意思就不说了，但是并不影响我们使用。</p><h2 id="5-使用"><a href="#5-使用" class="headerlink" title="5.使用"></a>5.使用</h2><p>以Go为例，我们需要安装一个<a href="github.com/golang/Protobuf/proto">运行库</a>，其它语言也差不多，官方针对每一个语言都有一个单独的介绍文档，务必查阅一下。</p><p>下面是一个完整的案例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/golang/Protobuf/proto"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//实例化模型对象，填充数据</span></span><br><span class="line">    p := &amp;Person&#123;</span><br><span class="line">        Id:    <span class="number">1</span>,</span><br><span class="line">        Name:  <span class="string">"jun"</span>,</span><br><span class="line">        Age:   <span class="number">25</span>,</span><br><span class="line">        Money: <span class="number">24.5</span>,</span><br><span class="line">        Car:   []<span class="keyword">string</span>&#123;<span class="string">"car1"</span>, <span class="string">"car2"</span>&#125;,</span><br><span class="line">        Phone: &amp;Person_Phone&#123;Number: <span class="string">"0551-12323232"</span>, Type: <span class="string">"1"</span>&#125;,</span><br><span class="line">        Sex:   Person_female,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Marshal序列化</span></span><br><span class="line">    out, err := proto.Marshal(p)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//序列化得到结果是二进制的，是不可读的，所以这里保存到文件</span></span><br><span class="line">    file, _ := os.OpenFile(<span class="string">"out"</span>, os.O_CREATE|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">    _, _ = file.Write(out)</span><br><span class="line">    _ = file.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//unMarshal还原数据，从文件里面读取</span></span><br><span class="line">    in, _ := os.Open(<span class="string">"out"</span>)</span><br><span class="line">    bytes, err := ioutil.ReadAll(in)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    p1 := &amp;Person&#123;&#125;</span><br><span class="line">    err = proto.Unmarshal(bytes, p1)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//调用string()方法打印，也可以使用其生成的getter函数</span></span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, p1.String())</span><br><span class="line">        fmt.Printf(<span class="string">"%d\n"</span>, p1.GetId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-与JSON对比"><a href="#6-与JSON对比" class="headerlink" title="6.与JSON对比"></a>6.与JSON对比</h2><p>由于XML目前很少使用在Web API接口上，所以这里就不对比了，主要看一下和JSON的对比，包含2个方面：速度和大小。</p><p>为了测试，我在proto文件里面又加了一个数据对象，表示一个组里面有多个person对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message Group &#123;</span><br><span class="line">    repeated Person person &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别测试有1,10,100个对象的时候对比情况，测试代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkProto</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    g := &amp;Group&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        p := &amp;Person&#123;</span><br><span class="line">            Id:    <span class="keyword">int32</span>(i),</span><br><span class="line">            Name:  <span class="string">"测试名称"</span>,</span><br><span class="line">            Age:   <span class="keyword">int32</span>(<span class="number">25</span> * i),</span><br><span class="line">            Money: <span class="number">240000.5</span>,</span><br><span class="line">            Car:   []<span class="keyword">string</span>&#123;<span class="string">"car1"</span>, <span class="string">"car2"</span>, <span class="string">"car3"</span>, <span class="string">"car4"</span>, <span class="string">"car5"</span>, <span class="string">"car7"</span>, <span class="string">"car6"</span>, <span class="string">"car21"</span>, <span class="string">"car22"</span>,&#125;,</span><br><span class="line">            Phone: &amp;Person_Phone&#123;Number: <span class="string">"0551-12323232"</span>, Type: <span class="string">"1"</span>&#125;,</span><br><span class="line">            Sex:   Person_female,</span><br><span class="line">        &#125;</span><br><span class="line">        g.Person = <span class="built_in">append</span>(g.Person, p)</span><br><span class="line">    &#125;</span><br><span class="line">    b.ResetTimer()</span><br><span class="line">        b.N = <span class="number">1000</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        out, err := proto.Marshal(g)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g1 := &amp;Group&#123;&#125;</span><br><span class="line">        err = proto.Unmarshal(out, g1)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkJson</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    g := &amp;Group&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        p := &amp;Person&#123;</span><br><span class="line">            Id:    <span class="keyword">int32</span>(i),</span><br><span class="line">            Name:  <span class="string">"测试名称"</span>,</span><br><span class="line">            Age:   <span class="keyword">int32</span>(<span class="number">25</span> * i),</span><br><span class="line">            Money: <span class="number">240000.5</span>,</span><br><span class="line">            Car:   []<span class="keyword">string</span>&#123;<span class="string">"car1"</span>, <span class="string">"car2"</span>, <span class="string">"car3"</span>, <span class="string">"car4"</span>, <span class="string">"car5"</span>, <span class="string">"car7"</span>, <span class="string">"car6"</span>, <span class="string">"car21"</span>, <span class="string">"car22"</span>,&#125;,</span><br><span class="line">            Phone: &amp;Person_Phone&#123;Number: <span class="string">"0551-12323232"</span>, Type: <span class="string">"1"</span>&#125;,</span><br><span class="line">            Sex:   Person_female,</span><br><span class="line">        &#125;</span><br><span class="line">        g.Person = <span class="built_in">append</span>(g.Person, p)</span><br><span class="line">    &#125;</span><br><span class="line">    b.ResetTimer()</span><br><span class="line">        b.N = <span class="number">1000</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        out, err := json.Marshal(g)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g1 := &amp;Group&#123;&#125;</span><br><span class="line">        err = json.Unmarshal(out, g1)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便对比，指定了测试次数为1000次，测试结果如下：</p><p>在1个person的级别：</p><p>可以看出，理论上proto明显比json要快不少，每次操作大概是4-5倍差距。后面在10，100个person的级别的测试中，基本上都是保持在4-5倍性能的差距，这个结果也和网上大部分测试结果一致。</p><p>关于生成的数据大小，这里也简单测试了一遍，还是上面的例子，我使用了10个person，Protobuf生成的文件大小是1030个byte,json生成的文件大小是1842个byte。</p><p>需要注意一点，虽然在大小上Protobuf也领先很多，但是据网上文章介绍，在经过nginx的gzip压缩之后，这2者大小基本上差不多。</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><p>Protobuf作为一种新的数据交换编码方式，虽然使用起来麻烦点，但是在性能和大小上面领先很多，可以用来替换json，使用在一些对性能要求高的场景，比如移动端设备通信。除此之外，目前Protobuf主要用在gRPC用作默认数据编码格式。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.简介&quot;&gt;&lt;/a&gt;1.简介&lt;/h2&gt;&lt;p&gt;Protobuf（Google Protocol Buffer）是 Google公司内部的混合语言数据标准，目前已经开源，支持多种语言（C++、C#、Go、JS、Java、Python、PHP），它是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。&lt;/p&gt;
&lt;p&gt;说简单点，Protobuf就是类似JSON、XML这样的数据交换格式，当今互联网JSON是最流行的格式了，XML用的也挺多，最初接触到Protobuf是因为gRPC默认使用它作为数据编码，相比于JSON和XML，它更小，更快！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="https://wangbjun.site/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.site/tags/Golang/"/>
    
  </entry>
  
</feed>
