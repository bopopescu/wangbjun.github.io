<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JWang的博客</title>
  
  <subtitle>一点记录，一点想法，一点思考</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wangbjun.site/"/>
  <updated>2020-03-08T12:59:20.990Z</updated>
  <id>https://wangbjun.site/</id>
  
  <author>
    <name>Ben Jun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Golang常见加密算法实现</title>
    <link href="https://wangbjun.site/2020/coding/golang/crypt.html"/>
    <id>https://wangbjun.site/2020/coding/golang/crypt.html</id>
    <published>2020-03-08T09:02:00.000Z</published>
    <updated>2020-03-08T12:59:20.990Z</updated>
    
    <content type="html"><![CDATA[<p>说完Go里面的md5的用法，这篇文章咱说说用的比较多的加密方式在Go里面如何实现。首先，科普一下，一般待加密的内容被叫作明文，加密使用的关键元素被称为秘钥，加密的结果被称为密文，当然其中还有一个非常关键的加密算法。</p><p>一般加密算法可分为对称加密和非对称加密这两个分类，这两者区别很明显，对称加密是指我们拿到秘钥和密文可以解密出明文，在加密和解密时使用的是同一个秘钥；而非对称加密算法需要两个密钥来进行加密和解密，这两个密钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。</p><a id="more"></a><p>本篇文章不是讲如何在Go里面实现这些加密算法，仔细看一下Go标准库里面<strong>crypto</strong>库，你会发现其实Go已经实现很多了加密算法，但是很多人不知道咋用，正如MD5算法一样，它没有提供一个非常简单易用的对外接口，需要你自己再封装一遍，如果你急着用，我建议你去Github上面找一下封装好的库，文章最后我会推荐一个。</p><img src="/images/2020-03-08_17-00.png" /><p>今天我们主要说两种最常用的加密算法：AES对称加密、ESA非对称加密。</p><h2 id="AES对称加密"><a href="#AES对称加密" class="headerlink" title="AES对称加密"></a>AES对称加密</h2><p>AES（Advanced Encryption Standard）是最常见的对称加密算法，但是这个算法分很多模式，不同模式的实现方式又有很大差异，比如ECB、CBC、OFB、CFB，详细技术细节这里就不多说了。</p><p>有几点需要注意，AES对加密key的长度要求必须固定为16、24、32位，也就是128、192、256比特，所以又有一个AES-128、AES-192、AES-256这种叫法，位数越大安全性越高但加密速度越慢。最关键是对明文长度也有要求，必须是分组长度长度的倍数，AES加密数据块分组长度必须为128bit也就是16位，所以这块又涉及到一个填充问题，而这个填充方式可以分为PKCS7和PKCS5等方式，不得不说是真麻烦。</p><p>本文以CBC模式为例来介绍，CBC又有点特殊，它需要一个iv偏移量，iv不一样，结果也不一样所以更安全,这个偏移量必须和分组大小长度一样，也是16位，其实如何去生成iv和填充明文才是最麻烦的地方，但标准库里面并没有给出示例，我网上找了下，先看一个简单的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AesCBCEncrypt</span><span class="params">(plainText []<span class="keyword">byte</span>, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="comment">// 生成加密用的block</span></span><br><span class="line">    block, err := aes.NewCipher(key)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对IV有随机性要求，但没有保密性要求，所以常见的做法是将IV包含在加密文本当中</span></span><br><span class="line">    cipherText := <span class="built_in">make</span>([]<span class="keyword">byte</span>, aes.BlockSize+<span class="built_in">len</span>(plainText))</span><br><span class="line">    iv := cipherText[:aes.BlockSize]</span><br><span class="line">    <span class="keyword">if</span> _, err := io.ReadFull(rand.Reader, iv); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    mode := cipher.NewCBCEncrypter(block, iv)</span><br><span class="line">    mode.CryptBlocks(cipherText[aes.BlockSize:], plainText)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cipherText</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际应用中，秘钥我们可以指定为固定位数，但是需要加密的内容往往是不固定长度的，所以需要做填充，同时在解密的时候就需要去除填充，这里总结了2种填充方法，一个是PKCS7，网上也有些文章称之为PKCS5，另一个是0填充。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PKCS7Padding</span><span class="params">(src []<span class="keyword">byte</span>, blockSize <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    padding := blockSize - <span class="built_in">len</span>(src)%blockSize</span><br><span class="line">    padText := bytes.Repeat([]<span class="keyword">byte</span>&#123;<span class="keyword">byte</span>(padding)&#125;, padding)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(src, padText...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PKCS7UnPadding</span><span class="params">(origData []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(origData)</span><br><span class="line">    unpadding := <span class="keyword">int</span>(origData[length<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> origData[:(length - unpadding)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ZeroPadding</span><span class="params">(src []<span class="keyword">byte</span>, blockSize <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    padding := blockSize - <span class="built_in">len</span>(src)%blockSize</span><br><span class="line">    padText := bytes.Repeat([]<span class="keyword">byte</span>&#123;<span class="number">0</span>&#125;, padding)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(src, padText...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ZeroUnPadding</span><span class="params">(origData []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bytes.TrimFunc(origData,</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">            <span class="keyword">return</span> r == <span class="keyword">rune</span>(<span class="number">0</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解密的过程首先是要提取出iv，然后解密，最后去除填充得到明文，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AesCBCDecrypt</span><span class="params">(cipherText []<span class="keyword">byte</span>, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    block, err := aes.NewCipher(key)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(cipherText) &lt; aes.BlockSize &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"cipher text too short"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    iv := cipherText[:aes.BlockSize]</span><br><span class="line">    cipherText = cipherText[aes.BlockSize:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(cipherText)%aes.BlockSize != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"cipher text is not a multiple of the block size"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mode := cipher.NewCBCDecrypter(block, iv)</span><br><span class="line">    mode.CryptBlocks(cipherText, cipherText)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cipherText</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，咱们来看一个简单的使用示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 需要被加密的内容，需要填充</span></span><br><span class="line">    <span class="keyword">var</span> src = <span class="string">"Hello，我是一个测试加密内容你知道吗？？？"</span></span><br><span class="line">    <span class="comment">// key必须是16\24\32位</span></span><br><span class="line">    <span class="keyword">var</span> key = <span class="string">"1234567890123456"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用了PKCS7填充法</span></span><br><span class="line">    cipherText := AesCBCEncrypt(PKCS7Padding([]<span class="keyword">byte</span>(src), aes.BlockSize), []<span class="keyword">byte</span>(key))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为方便展示，用base64编码</span></span><br><span class="line">    fmt.Printf(<span class="string">"cipherText text is %s\n"</span>, base64.StdEncoding.EncodeToString(cipherText))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密</span></span><br><span class="line">    plainText := AesCBCDecrypt(cipherText, []<span class="keyword">byte</span>(key))</span><br><span class="line">    fmt.Printf(<span class="string">"plain text is %s\n"</span>, PKCS7UnPadding(plainText))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 由于每次iv是随机的，所以结果都不一样，但是解密之后的明文都正确</span></span><br><span class="line"><span class="comment">// cipherText text is gFGf2lw9EQzQGxUtJGFQWDOaP3uU9CVWvLWCpSbeb9zrJqLUbSjS6d6GljtleGCFPFLWZZZ4a1RvKxR8wVT0d/U0cn8F4nwhEnun4Ba3t0M=</span></span><br><span class="line"><span class="comment">// plain text is Hello，我是一个测试加密内容你知道吗？？？</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说完Go里面的md5的用法，这篇文章咱说说用的比较多的加密方式在Go里面如何实现。首先，科普一下，一般待加密的内容被叫作明文，加密使用的关键元素被称为秘钥，加密的结果被称为密文，当然其中还有一个非常关键的加密算法。&lt;/p&gt;
&lt;p&gt;一般加密算法可分为对称加密和非对称加密这两个分类，这两者区别很明显，对称加密是指我们拿到秘钥和密文可以解密出明文，在加密和解密时使用的是同一个秘钥；而非对称加密算法需要两个密钥来进行加密和解密，这两个密钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程开发" scheme="https://wangbjun.site/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.site/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang计算文件MD5</title>
    <link href="https://wangbjun.site/2020/coding/golang/file-md5.html"/>
    <id>https://wangbjun.site/2020/coding/golang/file-md5.html</id>
    <published>2020-03-07T02:42:22.000Z</published>
    <updated>2020-03-07T03:26:53.067Z</updated>
    
    <content type="html"><![CDATA[<p>前面这篇文章<a href="https://wangbjun.site/2020/coding/golang/md5.html">&lt;Golang里面MD5的写法和性能&gt;</a>介绍了如何计算字符串的md5，下面我们来说说如何计算文件的md5。</p><a id="more"></a><h2 id="1-错误的方式"><a href="#1-错误的方式" class="headerlink" title="1.错误的方式"></a>1.错误的方式</h2><p>有人说，文件可以读取成字符串，然后再计算就可以了，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FileMD5</span><span class="params">(filePath <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    file, err := os.Open(filePath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    all, err := ioutil.ReadAll(file)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MD5(<span class="keyword">string</span>(all)), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法确实没问题，但是需要考虑一个问题，假如文件比较大呢？比如有好几个GB，如果按这个做法也得占用好几个GB内存，肯定存在问题。</p><p>经过我测试，在实际运行中，这种方式占用的内存是文件大小的好几倍，1个GB的文件需要大概4个GB的内存，太恐怖了。</p><h2 id="2-正确的方式"><a href="#2-正确的方式" class="headerlink" title="2.正确的方式"></a>2.正确的方式</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FileMD5</span><span class="params">(filePath <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    file, err := os.Open(filePath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    hash := md5.New()</span><br><span class="line">    _, _ = io.Copy(hash, file)</span><br><span class="line">    <span class="keyword">return</span> hex.EncodeToString(hash.Sum(<span class="literal">nil</span>)), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过实际测试发现占用内存几乎非常非常少，这里大家就会发现md5.New()的用途所在了，简单分析一下为什么这种方式占用内存少。</p><p>首先要了解<strong>io.Copy</strong>方法的含义，可以先看看注释：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy copies from src to dst until either EOF is reached</span></span><br><span class="line"><span class="comment">// on src or an error occurs. It returns the number of bytes</span></span><br><span class="line"><span class="comment">// copied and the first error encountered while copying, if any.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A successful Copy returns err == nil, not err == EOF.</span></span><br><span class="line"><span class="comment">// Because Copy is defined to read from src until EOF, it does</span></span><br><span class="line"><span class="comment">// not treat an EOF from Read as an error to be reported.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If src implements the WriterTo interface,</span></span><br><span class="line"><span class="comment">// the copy is implemented by calling src.WriteTo(dst).</span></span><br><span class="line"><span class="comment">// Otherwise, if dst implements the ReaderFrom interface,</span></span><br><span class="line"><span class="comment">// the copy is implemented by calling dst.ReadFrom(src).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(dst Writer, src Reader)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> copyBuffer(dst, src, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出来，它底层调用了一个copyBuffer，这个方法底层在copy的时候会临时分配一个buffer缓存区，默认大小32k，每次只会占用32k大小内存，如果想自定义缓存区大小可以使用<strong>CopyBuffer</strong>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CopyBuffer is identical to Copy except that it stages through the</span></span><br><span class="line"><span class="comment">// provided buffer (if one is required) rather than allocating a</span></span><br><span class="line"><span class="comment">// temporary one. If buf is nil, one is allocated; otherwise if it has</span></span><br><span class="line"><span class="comment">// zero length, CopyBuffer panics.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyBuffer</span><span class="params">(dst Writer, src Reader, buf []<span class="keyword">byte</span>)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> buf != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(buf) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"empty buffer in io.CopyBuffer"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copyBuffer(dst, src, buf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后配合Sum方法，每次计算32k，不断循环计算，直到算完，所以几乎不占用内存。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>如果计算的文件都是小文件，内存比较大的话，追求速度的话可以使用第一种方法，如果你计算的文件非常大，务必使用第二种方法，不然内存会爆掉。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面这篇文章&lt;a href=&quot;https://wangbjun.site/2020/coding/golang/md5.html&quot;&gt;&amp;lt;Golang里面MD5的写法和性能&amp;gt;&lt;/a&gt;介绍了如何计算字符串的md5，下面我们来说说如何计算文件的md5。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程开发" scheme="https://wangbjun.site/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.site/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang计算MD5的写法和性能</title>
    <link href="https://wangbjun.site/2020/coding/golang/md5.html"/>
    <id>https://wangbjun.site/2020/coding/golang/md5.html</id>
    <published>2020-03-05T13:10:00.000Z</published>
    <updated>2020-03-07T03:32:59.994Z</updated>
    
    <content type="html"><![CDATA[<p>用过PHP的童鞋知道在PHP里面md5很简单，是一个内置函数，可以直接调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jwang@jun:~$ php -a</span><br><span class="line">Interactive mode enabled</span><br><span class="line"></span><br><span class="line">php &gt; <span class="built_in">echo</span> md5(<span class="string">"12345"</span>);</span><br><span class="line">827ccb0eea8a706c4c34a16891f84e7b</span><br></pre></td></tr></table></figure><p>纠正一个错误的说法，很多人一直把md5叫作加密算法，实际上md5并不是加密，它既不是对称加密，也不是非对称加密，它只是一个摘要函数，一般被用于签名或者校验数据完整性。</p><p>虽然现在有文章说不推荐使用md5了，因为碰撞几率比较大，实际上，这个几率非常非常非常低，大只是相对于其它摘要函数来说，纯自然的情况下基本不可能碰撞，虽然可以用工具构造出来，但非常复杂。如果实在不放心，可以用sha1或者sha256，或者两者集合起来用，速度会慢一点，但安全性高一点，总之，md5由于速度快，简单易用，现在用的还是蛮多的。</p><a id="more"></a><p>言归正传，在Go的标准库里面并没有md5这个函数，但是在<strong>crypto</strong>包里面确实有相关实现，需要自己动手组装拼凑一下，网上流传的写法有很多种：</p><h2 id="1-第一种"><a href="#1-第一种" class="headerlink" title="1.第一种"></a>1.第一种</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MD5</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    hash := md5.New()</span><br><span class="line">    _, err := hash.Write([]<span class="keyword">byte</span>(s))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    sum := hash.Sum(<span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%x\n"</span>, sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>平时用到可能只是copy过来，没仔细看，今天来仔细看一下，首先，这个 md5.New() 返回的是一个结构体 digest：</p><img src = "/images/2020-03-06_21-34.png" /><p>这个结构体成员啥意思呢？其实细说起来，这和md5的算法有关了，咱也不知道，咱也不敢问！</p><p>但是仔细看一下这个结构体的方法，你会发现有一个叫Write，还有一个叫Sum，如果你英语不错，你可以看懂，Write就是把数据写到刚才这个结构体里面，先甭管它咋写，肯定是有算法规则，感兴趣可以研究研究。Sum稍微有点不一样，但是有一个参数，和一个返回值，这个方法的意思是把参数追加到进去并且返回摘要，由于我们之前已经写进去了，所以参数为nil即可。</p><img src = "/images/2020-03-06_21-39.png" /> <p>可见，一个md5方法Go就整了6行代码，老板看你代码写这么多，又可以加薪了，Go确实是好语言。</p><h2 id="2-第二种"><a href="#2-第二种" class="headerlink" title="2.第二种"></a>2.第二种</h2><p>如果你仔细看了这个包里面的 md5.go 文件，你会发现最下面有一个公开的方法Sum，仔细一看，这就是刚才我写的那个简化版：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sum returns the MD5 checksum of the data.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(data []<span class="keyword">byte</span>)</span> [<span class="title">Size</span>]<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> d digest</span><br><span class="line">    d.Reset()</span><br><span class="line">    d.Write(data)</span><br><span class="line">    <span class="keyword">return</span> d.checkSum()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们的方法可以简化为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MD5</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    sum := md5.Sum([]<span class="keyword">byte</span>(s))</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%x\n"</span>, sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然sum变量在这２个方法里面都是多余的，可以简化为一行代码即可。</p><h2 id="3-第三种"><a href="#3-第三种" class="headerlink" title="3.第三种"></a>3.第三种</h2><p>还有一种方式是使用io库的方法往里面写，主要是因为degest实现了<strong>io.Writer</strong>接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MD5</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    hash := md5.New()</span><br><span class="line">    _, _ = io.WriteString(hash, s)</span><br><span class="line">    <span class="keyword">return</span> hex.EncodeToString(hash.Sum(<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最后Sprintf方法是为了把结果转化成小写十六进制，也可以用<strong>hex.EncodeToString</strong>方法替代。</p><h2 id="4-性能对比"><a href="#4-性能对比" class="headerlink" title="4.性能对比"></a>4.性能对比</h2><p>这几种方式大同小异，理论上讲应该没有什么性能差距，不过既然Go自带Benchmark，我们就测一下吧：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMD5</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        MD5(<span class="string">"12345678901234567890"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jwang@jun:~/Documents/Work/learnGo/Std/md5$ go <span class="built_in">test</span> -bench=.</span><br><span class="line">goos: linux</span><br><span class="line">goarch: amd64</span><br><span class="line">BenchmarkMD5_1-12       10000000               359 ns/op</span><br><span class="line">BenchmarkMD5_2-12       10000000               356 ns/op</span><br><span class="line">BenchmarkMD5_3-12       10000000               163 ns/op</span><br><span class="line">BenchmarkMD5_4-12       10000000               296 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      _/home/jwang/Documents/Work/learnGo/Std/md5     11.757s</span><br></pre></td></tr></table></figure><p>不测不知道，一测吓一跳，其实前2个方法差不多很正常，但是第三个方法性能很好，其主要原因是因为Sprintf的性能比较差导致，不过<strong>md5.New()</strong>这种写法也比较慢。</p><h2 id="5-最佳写法"><a href="#5-最佳写法" class="headerlink" title="5.最佳写法"></a>5.最佳写法</h2><p>最终得出结论，性能最高的md5写法是这种，推荐大家使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MD5</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span>  &#123;</span><br><span class="line">    sum := md5.Sum([]<span class="keyword">byte</span>(s))</span><br><span class="line">    <span class="keyword">return</span> hex.EncodeToString(sum[:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-Sha1"><a href="#6-Sha1" class="headerlink" title="6.Sha1"></a>6.Sha1</h2><p>最后说个题外话，Go里面Sha1的写法和Md5几乎一致，只需要要把md5改成sha1即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sha1</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span>  &#123;</span><br><span class="line">    sum := sha1.Sum([]<span class="keyword">byte</span>(s))</span><br><span class="line">    <span class="keyword">return</span> hex.EncodeToString(sum[:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我也测了一下性能，它们之间的差距很小，md5是163ns/op，sha1是206ns/op，毕竟sha1比md5长一点。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用过PHP的童鞋知道在PHP里面md5很简单，是一个内置函数，可以直接调用：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;jwang@jun:~$ php -a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Interactive mode enabled&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;php &amp;gt; &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; md5(&lt;span class=&quot;string&quot;&gt;&quot;12345&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;827ccb0eea8a706c4c34a16891f84e7b&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;纠正一个错误的说法，很多人一直把md5叫作加密算法，实际上md5并不是加密，它既不是对称加密，也不是非对称加密，它只是一个摘要函数，一般被用于签名或者校验数据完整性。&lt;/p&gt;
&lt;p&gt;虽然现在有文章说不推荐使用md5了，因为碰撞几率比较大，实际上，这个几率非常非常非常低，大只是相对于其它摘要函数来说，纯自然的情况下基本不可能碰撞，虽然可以用工具构造出来，但非常复杂。如果实在不放心，可以用sha1或者sha256，或者两者集合起来用，速度会慢一点，但安全性高一点，总之，md5由于速度快，简单易用，现在用的还是蛮多的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程开发" scheme="https://wangbjun.site/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.site/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>如何高效的学习编程？</title>
    <link href="https://wangbjun.site/2020/life/how-to-learn.html"/>
    <id>https://wangbjun.site/2020/life/how-to-learn.html</id>
    <published>2020-03-03T04:48:37.000Z</published>
    <updated>2020-03-08T12:54:47.944Z</updated>
    
    <content type="html"><![CDATA[<p>今天想聊一聊学习这个话题，理想情况下，每个人都应该有适合自己的一套学习方法和节奏，主要因为不同人对知识的理解和吸收速度不一样，举个非常简单的例子，在网上看视频或者电影，有些人觉得2倍速播放刚刚好，而有些人甚至还要降速才能看明白，才能Get到点。即便如此，我觉得有些学习的经验和方法是可以共享的，虽然它不一定适合所有人。</p><p>人一生都在学习，学习不一定是在课堂上，特别是在互联网时代，我们可以随时随地打开手机观看各种课程，尤其是在编程行业，更需要不断持续的学习才能保持竞争力。我也是自学入行编程，期间也看过很多网上的视频教程，平时学习的时候也经常看一些博客教程，可以说现在也基本上是靠自学成长，颇有感触。</p><a id="more"></a><p>在学生时代，我也算是班级里面名列前茅的选手，在别人眼里我很厉害，每次考试都能考一个非常高的分数，但是我自己却感觉很轻松，我每天和其它同学一样，一起上课学习、按时完成老师安排的作业，没有什么额外的事情。而我周围的也有些同学非常努力，早起晚睡，周末还会上家教，但成绩却一般般。举一个不太恰当的例子，10万块钱在你眼里可能是巨款，但是在有钱人的眼里那只是零花钱。所以在一些牛人的眼里有些问题太简单了，他们可以分分钟钟给你手写一个翻转二叉树算法，这真的不是他们很努力，有些只不过是天分而已，而你刷了几百遍leetcode依然达不到人家的水平。</p><p>正视智商上的差距并不意味着努力没用，因为在大部分时候，我们远远没有达到需要拼智商的地步，努力能够弥补很多差距，即使智商很高的人也需要努力，不然也就是当代“伤仲永”而已。</p><h1 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h1><p>在我很早学习Java的时候，我在网上看过一个叫韩顺平的人的视频教程，他在开课之前有一小节专门讲了如何高效的学习编程这个话题，他总结了几个点，我觉得非常有道理，后来得知，他不仅仅教Java，也教PHP、Linux、Go，但是每次开课的时候都会讲一下这几点学习方法，个人感觉这几点讲的非常好，这里和大家分享一下：</p><img src="/images/2020-03-03-1.png" /> <ul><li><p>高效而愉快的学习</p></li><li><p>先建立一个整体的框架，然后细节</p></li><li><p>在实际工作中，要培养用到什么，能够快速学习的能力</p></li><li><p>先know how，再know why</p></li><li><p>软件编程是一门“做中学”的学科，不是会了再做，而是做了才会</p></li><li><p>适当的囫囵吞枣</p></li><li><p>学习软件编程是在琢磨别人怎么做，而不是我认为应该怎么做的过程</p></li></ul><blockquote><p>韩顺平是清华大学毕业，之前一直在某智任教，后来听说自己开设了一个培训班，但是经营不善倒闭了，现在又重返课堂了。</p></blockquote><p>仔细想一下，这些点讲的非常有道理，很多人在学习的时候往往忽视了整体，盯着一个点在那死磕，有点盲人摸象的感觉，比如你要学习使用一门语言，你首先应该知道这门语言适合干啥，然后再去了解大体有哪些特点，再去写一个最简单的例子，学习基本语法，具体的细节等以后渐渐熟悉了再去学习。</p><p>我们不能要求自己一上来就把所有的功能都学会了再做事情，编程行业发展到现在每一个细分领域只要你想去研究学习都有一大堆东西，需要大量时间，很多东西都是发展了很多年不断迭代的结果。你不能要求自己一上来就写一个没有bug、面面俱到的代码，但是你可以去不停改进优化你的代码。</p><p>What？Why？How？是什么？为什么？怎么用？这一条几乎可以适用于各行各业,我见过很多人，一上来就对着教程照葫芦画瓢，完全没有理解，效率自然不高。</p><h1 id="类比"><a href="#类比" class="headerlink" title="类比"></a>类比</h1><p>学习最快的方法就是用一个已知的东西去理解一个未知的东西，这个方法大部分情况下都是可用的，比如说你学习完了PHP再去学习Java或者Go，你会发现基本语法差不多，所以上手很快。</p><p>在编程行业，很多经验都是相互借鉴的，比如说PHP的composer和Node的npm它们都是一个包管理工具，是用来解决包依赖问题，一样功能的还有Linux操作系统里面apt和yum。编程里面常常提到的设计模式就是一种共同性的思想，虽然不同语言的具体实现可能有所差异。</p><p>即使不是同一个行业，也有些思想可以借鉴，比如，有人在讲述buffer和cache的区别的时候举了一个这样的例子，cache就相当于京东在每个城市周边的仓库，它可以快速的把你买的东西寄到你手上而不用从厂家发货。</p><p>但IT行业是一个非常喜欢吹牛逼的行业，经常会发明一些新鲜的词汇来唬人，比如云计算、云原生、5G云、大数据、人工智能等等。可能这个和风投资本有关，创业的人需要拿出一些看起来很厉害的东西唬住投资人，如果你仔细了解过这些“高大上”的词汇背后，你会发现其实还是熟悉的东西。</p><h1 id="网课"><a href="#网课" class="headerlink" title="网课"></a>网课</h1><p>现在知识付费非常火，卖课的广告到处都是，很多技术公众号天天也在贩卖焦虑，然后卖课。卖网课几乎是一个一本万利的生意，你只要录制一次就可以卖给N人，相对于书本来说，连印刷的成本都省了。</p><p>在早期我也看过很多视频教程，很多确实非常有用。但我现在看来，视频这种形式比较适合入门初学者，它可以快速的帮助你了解学习一门知识，特别是你啥也不会的时候，跟着视频学会快很多。</p><p>但是当你进入一个行业几年之后，视频课程基本上不是一个很好的选择了，大部分课程讲的东西都比较宽泛和全面，实际上你不一定用得到，很多人就听了一些公众号的忽悠，买了很多课，有些根本没时间看，有些看完时间一久就忘了。所以我建议还是得结合实际应用有针对性的去学习，很多优秀的开源项目的官方文档已经写的非常清楚了，有些怕你不会用连demo都给你写好了。</p><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p>记笔记是个好习惯，我记得以前上学的时候很多同学记笔记记的非常认真，老师在黑板上写，同学都在下面抄，一字不漏。老师经常说让大家不要照抄，不要把时间浪费在抄笔记上面，要多注意老师讲的东西。毕竟那会教育条件很差，现在估计学校里面应该都是直接投影仪放PPT了，学生也不用抄笔记了，直接拷贝就行了。</p><p>不过我还是建议大家有时间可以写点总结性的笔记，也可以叫作博客，不一定要写出多么有深度，你只需要记录自己学到一些东西或者自己的一些想法即可，因为有时候很多东西你感觉你自己学到了，但是让你写出来就会不一样了，写作的过程通常也是一个思考的过程，有助于查漏补缺。</p><p>所以如果有时间，建议抽出时间不妨就某一个技术点写出你自己的理解，写得好还是可以帮助别人，何乐不为呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天想聊一聊学习这个话题，理想情况下，每个人都应该有适合自己的一套学习方法和节奏，主要因为不同人对知识的理解和吸收速度不一样，举个非常简单的例子，在网上看视频或者电影，有些人觉得2倍速播放刚刚好，而有些人甚至还要降速才能看明白，才能Get到点。即便如此，我觉得有些学习的经验和方法是可以共享的，虽然它不一定适合所有人。&lt;/p&gt;
&lt;p&gt;人一生都在学习，学习不一定是在课堂上，特别是在互联网时代，我们可以随时随地打开手机观看各种课程，尤其是在编程行业，更需要不断持续的学习才能保持竞争力。我也是自学入行编程，期间也看过很多网上的视频教程，平时学习的时候也经常看一些博客教程，可以说现在也基本上是靠自学成长，颇有感触。&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="https://wangbjun.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="学习" scheme="https://wangbjun.site/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>谈一谈阿里外包工作</title>
    <link href="https://wangbjun.site/2020/life/2019-4.html"/>
    <id>https://wangbjun.site/2020/life/2019-4.html</id>
    <published>2020-03-01T02:00:00.000Z</published>
    <updated>2020-03-01T06:58:01.384Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过几篇文章名字叫<a href="https://wangbjun.site/2020/life/2019-1.html">《一个野生程序员的北漂之路》</a>，这篇文章应该算是后续吧，聊聊我如何进阿里外包，主要是结合我的经历和我所了解的一些事实谈谈我的感受和看法，仅供其他朋友参考。</p><h2 id="上家公司残局"><a href="#上家公司残局" class="headerlink" title="上家公司残局"></a>上家公司残局</h2><p>看过前面文章的人应该知道我上一家公司因为是P2P行业受到打击，目前已经处于立案阶段，整个公司几百员工都失业了，我也不例外。刚开始我对公司还抱有希望，在家休息等待了2周之后我才明白公司是真的没了，自己找工作吧，当时公司为了不仅欠了我们半月工资，而且连社保也没钱缴纳（财务账户被冻结），甚至都无法给员工办理离职（公章被扣押），没人有操心这几百号员工怎么办，但是社保断了对很多人有很大影响，很多人都在问怎么办，最后公司的HR出来告诉我们可以自己找人代缴，但是由考虑到风险，需要员工签一个离职声明，然后公司才可以把社保做减员处理，于是大家争相签离职声明。</p><a id="more"></a><p>签了这个声明之后，基本上就和公司没关系了，但是公司无法开离职证明，所以找工作的时候得自己解决。其实从法律上说离职证明不是必须的，不过从公司的角度说，如果你同时在2家公司任职会对公司不利，有些公司会让你签一个免责声明，但不同公司的要求不一样，有些公司比较看重。</p><h2 id="面试经历"><a href="#面试经历" class="headerlink" title="面试经历"></a>面试经历</h2><p>后来，我出去面试了一周，面了10来家公司，有些是小公司，但是也有一些相对大一点的公司，比如百度、360等，面试的岗位有PHP和GO，不过最终结果都一样。一开始我就不抱太大期望，因为这会距离过年只有20天左右，年终招人的公司并不多，很明显有些公司就是走过场或者传说中的刷KPI。</p><p>前面说过，我自己的硬件条件很差：非科班、非重点、转行，而且之前的工作履历也一般，很多面试官拿到简历问我是什么专业，一听是非计算机专业就立马不一样了，其中有一个面试官比较实诚，直接和我说你这个专业让我觉得不踏实。另外就是，我自己准备的也不够充分，实力有限，打扰了，可能他们想招的都是高端人才，我要求工资上限才达到他们的下限。</p><p>但也有比较Nice的面试官，比如百度的，当时是去面的百度文库，PHP在百度有大规模应用招人还是挺多的（后续和面试官聊的时候发现也在转Go），聊的时候期间我问了一个有意思的问题，我说：“听说大厂用PHP和一般公司都不是一个用法，你们都是用的扩展，是真的吗？”他说也并不是，只有极少数对性能要求非常高的模块会用扩展写，大部分都是普通PHP代码，但是我们用的是自己写的框架。二面的应该是一个leader，一开始就问了一些非技术内容，然后问了一些技术内容，还让在纸上写一些东西，不过一个快排算法没写出来，那天刚好是元旦前一天，面试官说：“今天是2019年最后一天，非常有意义，马上下班去跨年了，如果你刚才那个算法写好了我就让你过了，不过也不一定，我待会和一面沟通一下，有消息再通知你”。虽然凉了，但是百度这2个面试官给我感觉比较尊重人，面试过程比较轻松，不像是有些公司的面试官盛世凌人，比如在问到我不会的问题时，我通常会说这块我确实没了解过，您能不能大概给我介绍下？很多面试官会说自己回去百度、自己回去再看看吧，极少数会给你解答。</p><h2 id="技术水平"><a href="#技术水平" class="headerlink" title="技术水平"></a>技术水平</h2><p>有一个问题特别有意思，在和百度一面聊的时候，他问我你觉得自己技术大概在什么水平，这个问题也有很多面试官问过，我一般会说中级，他说我觉得你差不多能达到高级、中高级，我说高级那不得熟知源码，他说熟知源码那得资深了。我并不太了解这个等级划分，我一般理解会有3个档次，初、中、高级，比如很多招聘会写高级开发工程师，但是不同公司的标准好像不一样，百度会有自身的T级别，而阿里则有P级别，比如在阿里，p5一般是高级，p6资深，p7技术专家，我猜那个面试官说的应该是按百度级别划分，但百度的我没了解。我记得有一次一个面试官问过我如果我要到资深的水平需要多久，我说大概要10年，但是我这时候理解的资深是相当于最高级的技术水平。不过有一点大家需要了解，国内很多大厂的技术定级，并不是完全是看技术，越往上往往靠的是管理，纯技术基本上没有活路。</p><h2 id="为什么要进外包？"><a href="#为什么要进外包？" class="headerlink" title="为什么要进外包？"></a>为什么要进外包？</h2><p>说到外包，其实一开始我是拒绝的，直到我有一个朋友在阿里外包（Web前端），她们是和阿里正式员工一起办公，外包公司是南京的一家公司，社保也不是最低缴纳，工作还挺轻松，一般晚上准时6点半下班，周末双休，极少加班，加班可以调休，看上去并不是很差。我知道，网上一直对IT外包评价非常差，99%的人不建议去外包岗位，除非无路可去，否则不要考虑外包，所以以前找工作的时候只要是外包的我一概不考虑，但是这次我想试一试。</p><p>抱着试试看的态度，我答应了一家武汉的外包公司的面试，面试岗位是阿里某部门Go语言的项目，其中主要原因是我对Go比较感兴趣，也想写Go。面试是电话面试，前后来了2个，电话都是来自杭州阿里巴巴的，如果说我找工作面其它公司的难度是10，那么外包可能只有3，结果很顺利的就到了谈薪的阶段，果不其然，工资确实压的很低，而且其它待遇基本为0。外包好像都会有一个套路，那就是开始给你压到很低，如果你不同意他们就会说我帮你申请特批，但是即使明面上的薪资达到了我的要求，但是其它福利基本为0，本质上还是降薪了。这里其它福利就是5险一金最低缴纳、没有任何补助、只有12薪、没有年终奖和奖金。</p><p>我在面外包之前也做了一些功课，比如和你聊的人，也就是外包的人事专员他们只负责招聘，招聘入职之后就和她没有什么关系了，他们一般会和你说一些“空大假”话，最常见的就是进大厂外包表现的好有可能转正，但是据我了解，这个概率很低，而且基本上是副作用，如果你想正式进大厂，反而不能去外包，其实并不是技术原因。有网友说，如果一个外包员工辞职之后再入职变成正式员工，你觉得外包公司会怎么想？这相当于大厂在和外包公司抢人，但是这些大厂和这些外包公司都是合作关系，就算明面上不说，估计私底下也签了协议。我觉得说的没毛病，不敢说绝对，但是现在通过外包进大厂其实很难，现在竞争激烈，大厂从来不缺人，其实还有另外一个原因，那就是大部分外包员工水平都很差。不过我确实有了解到一个通过外包进小米最后转正的人，PHP岗位。</p><h2 id="外包可能的坑"><a href="#外包可能的坑" class="headerlink" title="外包可能的坑"></a>外包可能的坑</h2><p>总之，在薪资问题上和这个人事专员以及她的上级领导几轮较量之后，她说可以给到我的薪资要求，但是我却说了No，因为我发现这家武汉的外包公司劣迹斑斑，在知乎上有很多“黑稿”，而且有理有据。最后我和这个人事专员摊牌了，她说她知道，她给我的辩解是如果真如网上说的这么差，那为什么还有这么多员工呢？为什么阿里依然和他们合作呢？</p><p>我无言以对，但是这些纠纷里面提到的问题大多集中在几个方面，我认为基本可信，比如说加班工资，很多大厂加班都很严重，外包也不例外，但是正式员工毕竟福利好，加班也是自愿加班，外包工资本身都很低，再996有点说不过去吧？于是有些外包公司就会承诺有加班费（一般都是调休），但是这笔加班费你想拿到有点难，要经过层层审批，很久很久，久到最后离职了还没拿到。还有一些控诉内容是调岗问题，大家要知道一个公司之所以招外包就是为了省钱，而且更加灵活，项目需要人的时候就招外包，项目不要人就可以“开除”外包，虽然我不知道外包公司和这些大厂签的什么协议，但是可以确定的是如果你外包的项目结束了，不需要人了，公司会让你去面试其它公司，假如很不幸没有公司招人（外包岗位都是一个萝卜一个坑）或者你没面试上，外包公司就会让你待岗，只会给你发一个基本工资，大概只有几千块，如果你仔细看一下外包合同，你会发现这个薪资构成就是这么写的，所以很多纠纷都在这里。</p><p>但是招聘你的时候，外包的人事专员都会告诉你这个项目是长期项目，他们和公司的合作是长期合作，其实话虽这么说，事实大家都清楚，没有什么是长期固定不变的，我相信这些纠纷可能不全是外包公司的问题，但是看判决书大部分都是员工胜诉，你们说公司有没有问题呢？</p><h2 id="再面外包"><a href="#再面外包" class="headerlink" title="再面外包"></a>再面外包</h2><p>这会距离过年还有2周时间，我承认我是有私心的，觉得当时工作反正不好找，也不想那么早回家，就先进外包干着，还有免费过年假期，万一太坑就明年再找，这家外包公司名字叫xx国际，在外包行业知名度比较高，巧的是面试的岗位和上次是同一个项目，但是好像不是一个部门，因为给我打电话面试不是同一个人。2轮电话面试轻松拿下，根据人事专员反馈阿里那边定级是高级，但是给的薪资我就呵呵了，脉脉应届生水平都不如，我懒的浪费时间应对他们的套路了，就直接说了最低数，低于这个数就别谈了。不知道是他们真缺人还是年底也不好招人，最后答应了，但是人事专员给我反馈说这个薪资属于他们的资深水平，需要特批，走一个流程，我说你们怕不是对资深有什么误解，她说他们和阿里签的什么框架协议就是这么规定的。最后她上级还打电话和我做个君子协议，意思说他们提申请，批下来我一定得去，不能放鸽子，这又是什么套路？</p><p>但是这个流程批了差不多一个星期，最后离过年还有一周的时候才正式入职，这中间有什么套路我就不清楚了，大公司OA流程确麻烦，那个人事专员确实没骗我，一直说在催，说什么领导出差、开年会，打电话也没人接，就算套路也是他们公司上层的旨意，但是都答应了我也不好意思再反悔了，就这么等了一周。</p><p>这里普及一下，干外包你需要面对2个公司，一个是你的外包公司也就是和你签合同给你发工资的公司，一个是你工作的公司也就是你真正上班的地方，比如阿里、百度，这种外包形式也叫人力外包、人力派遣。外包公司基本上都是听大厂安排，比如说此次疫情放假、健康打卡都是阿里安排的，外包公司基本上就是传话筒，虽然是传话筒，但是依然无法无视他们。</p><p>简单来说，你需要面对具体2个人，一个是你在大厂的主管，他负责给你安排工作、决定你的业绩考核，另一个是外包公司的接头人，他一般是给你传达一些公司的通知安排。我的主管在面试过程中还特意强调，他说：“阿里的正式员工招聘流程非常复杂、非常长，我们也想通过外包来做一些筛选，如果表现的好有机会转正，但是我不保证，只是说有这个可能”</p><h2 id="外包加班吗？"><a href="#外包加班吗？" class="headerlink" title="外包加班吗？"></a>外包加班吗？</h2><p>目前我还没加过班，原因很简单，我年前只工作了几天，那时候很多人都请假提前回家了，所以也没安排什么工作，而年后这段时间一直在家远程办公，工作量也很少，但是这不代表以后不加班，但是我之前问过我主管，他说没事可以早点走，但是他们一般都是9点以后走，阿里正式员工996毫无毛病。</p><p>但是我那几天刚好认识了几个从国门大厦过来在一起办公的不同部门的外包同事，他们刚好是我之前说的第一家武汉外包公司的员工，他们说他们主管要求必须待到9点之后，而且10点之后才算1个小时加班，可以调休。所以，这个问题没有固定答案，很多大公司内部不同部门也不一样，有些部门加班，有些不加班，如果非得说根据什么决定，那只能说是看主管，有些主管天天盯着你，而有些主管只要你把工作按时完成就行。</p><h2 id="外包工作地点"><a href="#外包工作地点" class="headerlink" title="外包工作地点"></a>外包工作地点</h2><p>这点只针对阿里外包有点用，一般来说，阿里外包都在国门大厦办公，那个地方是所有外包集中办公的地方，平时沟通的话主要通过远程视频，而阿里正式员工都在望京上班，望京有金辉大厦、阿里中心A、B座，但是也有部分的外包员工固定在望京上班，而且是和正式员工一起办公。</p><p>但是也不是绝对的，如果你在国门大厦，有时候主管会要求你来望京办公，这时候只能给你办一个访客证，阿里的管理特别严格，保安也很敬业，访客必须由正式员工带进访客专用电梯。而且这时候由于你没有固定工位，你只能去会议室办公，所以在国门大厦办公的外包基本上是来回于国门大厦和望京之间。为什么要这么做呢？其实是需求比较多的事情主管找机会盯着你，在国门大厦办公基本上没人管，考勤只看打卡记录，你没事干下去放放风，溜达一圈都可以。</p><h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><p>总得算起来，我目前也才上班一个多月，说起来也不算有什么发言权，但是还是想说一点，我不知道是阿里对信息安全要求非常高还是只针对外包，比如说电脑必须安装一个监控软件、不能安装微信、QQ，不能干工作之外的事情，还有一些比如说不能透露组织架构、透露工作内容等等，虽然说这些措施有点严格，但基本上还算合情合理。</p><p>所以这里面我只谈感受，首先，我的主管人比较随缘，很好说话，也很客气，其次，关于网传歧视外包员工这件事，目前没有感受到，主要是不在一起办公，目前只和他们一起吃过一次饭，确实没啥聊的，毕竟不熟，平时主要靠钉钉沟通，工作是工作，对事不对人。</p><p>不知是我的错觉还是阿里的文化如此，他们都喜欢给人点赞，每次解决一个问题或者完成一个工作，他们都会给你点赞，就是大拇指那个表情，我承认赞扬人是个美德，但是我平时很少赞扬人，所以注意到了这一点。</p><p>阿里是一个业务驱动的公司，当然这也没什么可说的，国内的公司都是业务驱动，以前在网上还看过一些《阿里巴巴的开发手册》，进去发现这和手册上说的不太一样，没见到规范在哪。。。一切以KPI为导向，但好像对外包没有KPI要求，为了完成KPI，996又有何怨言呢？</p><p>网上有些东西没说错，比如外包主要是在干一些边边角角的不是很核心的事情，比如说前端页面、一些增删改查的接口或重复性的工作。</p><p>至于我会在这里干多久，我也不知道，受现在疫情影响，经济环境差，或许我还会继续干下去，有时候一件事刚开始干起来可能很不爽，但是时间干的越久你会发现渐渐适应了，变成你的新舒适区了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写过几篇文章名字叫&lt;a href=&quot;https://wangbjun.site/2020/life/2019-1.html&quot;&gt;《一个野生程序员的北漂之路》&lt;/a&gt;，这篇文章应该算是后续吧，聊聊我如何进阿里外包，主要是结合我的经历和我所了解的一些事实谈谈我的感受和看法，仅供其他朋友参考。&lt;/p&gt;
&lt;h2 id=&quot;上家公司残局&quot;&gt;&lt;a href=&quot;#上家公司残局&quot; class=&quot;headerlink&quot; title=&quot;上家公司残局&quot;&gt;&lt;/a&gt;上家公司残局&lt;/h2&gt;&lt;p&gt;看过前面文章的人应该知道我上一家公司因为是P2P行业受到打击，目前已经处于立案阶段，整个公司几百员工都失业了，我也不例外。刚开始我对公司还抱有希望，在家休息等待了2周之后我才明白公司是真的没了，自己找工作吧，当时公司为了不仅欠了我们半月工资，而且连社保也没钱缴纳（财务账户被冻结），甚至都无法给员工办理离职（公章被扣押），没人有操心这几百号员工怎么办，但是社保断了对很多人有很大影响，很多人都在问怎么办，最后公司的HR出来告诉我们可以自己找人代缴，但是由考虑到风险，需要员工签一个离职声明，然后公司才可以把社保做减员处理，于是大家争相签离职声明。&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="https://wangbjun.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="Life" scheme="https://wangbjun.site/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>那些年，318徒步搭车之旅（二）</title>
    <link href="https://wangbjun.site/2020/life/walk-on-the-318-road-1.html"/>
    <id>https://wangbjun.site/2020/life/walk-on-the-318-road-1.html</id>
    <published>2020-02-25T15:50:08.000Z</published>
    <updated>2020-03-08T12:56:21.155Z</updated>
    
    <content type="html"><![CDATA[<p>每个人对旅行都有自己想法或出于各种目的，对于我当时来说，我并不完全是在旅行，只是把工作和对自由的追求结合在一起。但在这几年的旅行中，我都是独自一人踏遍大江南北，期间也遇到很多和我一样一个人出来旅行的人，我虽不善于交际，但是也在途中结识不少，大多萍水相逢，随后结伴而行度过一段时光，最后各奔东西，相忘于江湖。。。</p><a id="more"></a><p>在Ta们中，有人是纯粹出来旅游散心，有人是挑战自我，有人是对自然的热爱，有人是为了结交更多的朋友，也有人是在躲避生活。记得有一次在丽江一家青旅认识一位小姑凉，她说她在读高三，看长相似乎与我年龄相仿，曾一起骑车游逛古镇，后来听说她被她爸“抓”回去了，原来她父母离异，她这次是私自离校出来玩，她爸报警之后通过公安局查到青旅，做飞机从千里之外上门把人带走了。一个人出去旅行的人往往都有自己的故事，Ta们也许是习惯一个人，也许是追求流浪的状态，或许是想找个人倾诉，或借机摆脱烦恼，无论如何，这都是Ta们的旅行。</p><p>时间回到林芝，咱们继续说318的故事，林芝算是西藏地区非常大的一个城市，四面环山，云雾缭绕，旁边一条河流流过，自然环境非常好，本地也没什么工业，空气质量非常好，但是湿度也大，林芝这属于亚热带气候，夏天的时候下雨，雨蒸发变成云雾，然后又变成雨，一天可以下好几次雨。</p><img src="/images/2020-02-26-1.jpeg" /> <img src="/images/2020-02-26-2.jpeg" /> <p>我在林芝总共待了2天，随处逛了下，整个城市是一个严重依赖外部资源输入的地方，只有往西可以去西藏，往东就是2000多公里的318国道。期间去了一个国家森林公园，站在山上俯视了下整个城市，可以看见整个城市在一片河滩冲积平原上面，有很多在建的工程。</p><img src="/images/2020-02-26-3.jpeg" /> <img src="/images/2020-02-26-4.jpeg" /> <p>这座山名字叫作“比日神山”，可能是当地藏族人民的神山，所以在山上的栈道两边全部挂满了经文，这在西藏非常常见！</p><img src="/images/2020-02-26-5.jpeg" /> <img src="/images/2020-02-26-7.jpeg" /><p>这条桥叫作八一大桥，其实最早林芝市也叫八一镇，只不过发展的比较大就改成市了。</p><img src="/images/2020-02-26-6.jpeg" /> <p>刚刚去Google卫星地图上面看了下，发现虽然5年过去了，似乎变化并不大，从卫星地图上也可以看出来整个城市围绕着河道而建，这条河最终流向印度洋。</p><img src="/images/2020-02-26-9.jpeg" /> <img src="/images/2020-02-26-8.jpeg" /> <p>这样的城市看起来很好，但是似乎不是太适合现代人，除了空气比较好之外，周围被大山包围，阳光并不多。另外这地方太过偏远，离拉萨还有几百公里，网上买东西太慢，上网的话网速也慢，如果要去别的地方不坐飞机就更远了，虽然有机场，但是票价不便宜，另外各种生活物资，比如蔬菜、水果、海鲜水产基本上全靠外部输入，种类少价格高，可能适合有钱人买套房在这偶尔坐飞机过来度假，待上一段时间，感受一下慢生活。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每个人对旅行都有自己想法或出于各种目的，对于我当时来说，我并不完全是在旅行，只是把工作和对自由的追求结合在一起。但在这几年的旅行中，我都是独自一人踏遍大江南北，期间也遇到很多和我一样一个人出来旅行的人，我虽不善于交际，但是也在途中结识不少，大多萍水相逢，随后结伴而行度过一段时光，最后各奔东西，相忘于江湖。。。&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="https://wangbjun.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="Life" scheme="https://wangbjun.site/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>那些年，318徒步搭车之旅（一）</title>
    <link href="https://wangbjun.site/2020/life/walk-on-the-318-road.html"/>
    <id>https://wangbjun.site/2020/life/walk-on-the-318-road.html</id>
    <published>2020-02-12T07:40:07.000Z</published>
    <updated>2020-03-08T12:54:47.948Z</updated>
    
    <content type="html"><![CDATA[<p>那是2015年8月，我在拉萨停留几日，期间逛了下<code>大昭寺、布达拉宫门口</code>等打卡地点，作为一个非宗教人士，我对拉萨的这些宗教文化并无太多感触，也并不觉得灵魂有什么升华。大街上的商店大部分也都是卖着义乌批发制品，他们的售卖对象其实不是游客，而且来自西藏各地的牧民，但我花了100多买了一双山地运动鞋，扔掉了我脚上穿的特步运动鞋，这双运动鞋我在外穿了几个月，虽然也很便宜但是非常轻便，但是过于轻薄，因为我在策划一场没有安排和计划的318之旅，从拉萨坐火车往回走太远，不如走国道再去云南大理转转。</p><blockquote><p>后记，那双鞋质量很差，差的突破预期。。。</p></blockquote><a id="more"></a><img src="/images/2020-02-12-1.jpeg" /> <div align="center">    <audio controls autoplay loop>      <source src="/audios/fzw.mp3" type="audio/mpeg" >    </audio></div><p>说走就走，第一站是<code>林芝市</code>，早上我告别青旅，坐车前往距离拉萨几十公里外的一个县（墨竹工卡县），等等，不是说好的徒步搭车吗？其实我在外一般能坐车的地方肯定是自己坐车，极少去坐“黑车”或者搭车。但是西藏这个地方客运车辆很少，有些地方根本不通车，或者车次非常少（有些地区1-2天才发一趟车）。在国道上跑的车一类是大货车，大多都是从云南四川过来的货运车辆，珍惜生命远离大货车；另一类是私家车，以川字牌居多，其中大部分都是自驾游或者租的车，也有不少是藏族人当地车，还有部分以盈利为目的的“黑车”。</p><img src="/images/2020-02-12-2.jpeg" /> <p>大约中午的时候才到达了这个县，说是县城，但规模比我国中东部地区的一个镇都还小，基本上就是沿着国道2边有一些房子，路边商店买了一瓶水，望了望这街道，再看了下地图我离林芝还有300多公里。。。我决定开始搭车了。第一次搭车没什么经验，站路边招手半天没人停，也记不清大概过了多久，有一辆车停了，直接招呼我上车，车上有很多藏族人，车主的普通话很糟糕，我觉得大概是在问我去哪里，我说去林芝，也不知道他听懂了没，后面就一直没交流过，车上这些人说话我也听不懂，也没和我搭话，我自顾自刷着手机，中间路过<code>米拉山口</code>下来拍了张照，第一次在海拔这么高的地方，感觉脑袋有点懵，腿有点软，也不知道是不是因为坐的太久了。。。</p><blockquote><p>米拉山口是318国道海拔最高点，5000多米，当时下面已经在修隧道了，现在估计早已经修好了。其实318国道那几年到处都在架桥修隧道，路况好很多，现在估计随便一个车也能开过去。</p></blockquote><img src="/images/2020-02-12-3.jpeg" /> <p>大概5点多的时候，车子到了国道旁一个像是镇的地方，那块有一个岔路口，往前走是318，拐进去不知道是什么地方，看地图里面也没什么县或镇，估计这些藏族人家在深山。车上人都下来休息，这时候车主和我说，他们不往前面走了，要拐进去，离林芝也不远了，让我自己在路边再拦个车，最后让我让把<code>路费</code>付一下。其实付路费这事我觉得没啥问题，毕竟上车那会也没说不要钱，现在回忆起来也记不清楚是他到底开口要了多少钱，反正我记得我那会还还价了，最后给了100块外加一些零钱，可能不合他意，但是他也没做出什么出格的举动，因为那会我兜里也就踹了几百块钱，自己总得留点，再多要我确实也没有。</p><p>然而这里距离这个林芝还有100多公里，路边已经基本上没有什么车了，再过1个多小时天也快黑了。我进镇看了下，这个镇也很小，不过好在还有旅店和饭店，于是背着包在镇里面过了一遍，然后又回到了318国道，最后决定还是继续往前，先往前走着一边再搭车，如果实在搭不到车那就再往回走晚上住这里。</p><img src="/images/2020-02-12-4.jpeg" /> <p>这次运气比较好，很快就有一辆川字牌的车停下来了，车主是不是藏族人，上车后发现车子非常新，连后座的膜都还在，简单聊了几句，他说他是去云南送车的，让我不要动车上的东西，具体我也没多问。不过这大哥的车技确实了得，318上面弯道非常多，很多地方道路也不宽敞，但是这大哥每次转弯、会车的时候甚至都不用减速。虽然这次语言不是障碍，但是2个大老爷们也没什么太多可聊的，最后晚上9点多的时候到了林芝，我说了声谢谢后就下了车，这大哥什么也没说啥，一脚油门就走了，颇有几分干练和爽快。</p><p>虽然有点折腾，但是最终还是到达林芝市，迈出了318国道的第一步，万事开头难，谁知道接下来又会发生什么呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;那是2015年8月，我在拉萨停留几日，期间逛了下&lt;code&gt;大昭寺、布达拉宫门口&lt;/code&gt;等打卡地点，作为一个非宗教人士，我对拉萨的这些宗教文化并无太多感触，也并不觉得灵魂有什么升华。大街上的商店大部分也都是卖着义乌批发制品，他们的售卖对象其实不是游客，而且来自西藏各地的牧民，但我花了100多买了一双山地运动鞋，扔掉了我脚上穿的特步运动鞋，这双运动鞋我在外穿了几个月，虽然也很便宜但是非常轻便，但是过于轻薄，因为我在策划一场没有安排和计划的318之旅，从拉萨坐火车往回走太远，不如走国道再去云南大理转转。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;后记，那双鞋质量很差，差的突破预期。。。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="生活" scheme="https://wangbjun.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="Life" scheme="https://wangbjun.site/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>Golang测试用例编写</title>
    <link href="https://wangbjun.site/2020/coding/golang/unit-and-functional-test.html"/>
    <id>https://wangbjun.site/2020/coding/golang/unit-and-functional-test.html</id>
    <published>2020-02-10T10:15:00.000Z</published>
    <updated>2020-03-06T17:11:51.534Z</updated>
    
    <content type="html"><![CDATA[<p>如果你看过很多开源库的源码，你会发现大部分项目都有很多详细的测试代码，一般来说测试覆盖率越高说明这个项目的质量越高，所以好的项目测试是少不了的。很多公司对代码测试覆盖率也有要求，不为别的，只为更好的代码质量。</p><h2 id="1-分类"><a href="#1-分类" class="headerlink" title="1.分类"></a>1.分类</h2><p>虽然业界有一直开发模式叫做测试驱动开发（TDD），但是了解的人都知道<code>TDD</code>对开发要求太高了，它要求你先写测试用例然后再写代码，需要你写代码之前思考很多，需要大量时间，我实际开发中并没有采用过这种模式，估计国内都应该很少。</p><p>我们可以粗略的把测试用例简单划分为2种类型，一种是<code>单元测试</code>，它是针对某个模块、函数、方法的测试，另一种是<code>功能测试（集成测试）</code>，它是针对整个项目功能是否可用的测试。举个例子，你写个了Web服务接口，单元测试可能是针对这个接口里面调用的一个函数测试，而功能测试就是测试这个接口是否可用，因为一个接口可能调用了多个函数。</p><h2 id="2-单元测试"><a href="#2-单元测试" class="headerlink" title="2.单元测试"></a>2.单元测试</h2><p>Golang里面的测试和其它大部分语言的测试不多，只不过表示形式略有不同，比如Go的单元测试通常情况下是和被测试的代码放在一起的，以<code>xxx_test.go</code>命名并且测试的函数名必须以<code>Test</code>开头。</p><a id="more"></a><p>例如：<br>math.go 有以下2个函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"errors"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Div</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">"division by zero"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想测试这个文件，那么测试文件名字就应该叫 math_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDiv</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    i, err := Div(<span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        t.Fail()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> i != <span class="number">2</span> &#123;</span><br><span class="line">        t.Fail()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切换到工作目录下执行 <code>go test</code>即可，这个命令有很多附加参数，比如说<code>-v</code>可以查看详细情况，<code>-coverprofile</code>可以看测试覆盖率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jwang@jun:~&#x2F;Documents&#x2F;Work&#x2F;test$ go test -v -coverprofile&#x3D;c.out</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestDiv</span><br><span class="line">--- PASS: TestDiv (0.00s)</span><br><span class="line">PASS</span><br><span class="line">coverage: 66.7% of statements</span><br><span class="line">ok      _&#x2F;home&#x2F;jwang&#x2F;Documents&#x2F;Work&#x2F;test       0.001s</span><br></pre></td></tr></table></figure><p>根据测试函数参数类型的不同，Go里面把测试又细分为<code>*testing.T和*testing.B</code>，其实B是性能基准测试，通常用来测试算法性能，这里就不多说了。</p><p>单元测试的目的就是尽可能的覆盖到所有情况，说白了，就是枚举各种情况，根据输入的参数人工推导正确的结果，然后和实际得出的结果做比对，如果失败则说明程序有bug，比如上面的例子明显没有覆盖到所有情况，只达到了66.7%。</p><p>上面这段测试代码主要是没有覆盖到被除数为0的情况，下面完善一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDiv</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    i, err := Div(<span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        t.Fail()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> i != <span class="number">2</span> &#123;</span><br><span class="line">        t.Fail()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i, err = Div(<span class="number">4</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        t.Fail()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新执行<code>go test</code>会发现覆盖率达到了100%，也就是所有语句都覆盖到。</p><blockquote><p>请注意，覆盖率达到100%并不意味着代码没有问题。</p></blockquote><h2 id="3-表格测试"><a href="#3-表格测试" class="headerlink" title="3.表格测试"></a>3.表格测试</h2><p>表格测试严格来说并不是一种测试类型，只是一种测试方式，就是一种套路，上面的例子里面，我们需要手动构造每一个测试的入参和出参后执行、断言结果，有很多重复代码，我们可以使用表格测试优化一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDiv</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tests = []<span class="keyword">struct</span> &#123;</span><br><span class="line">        a        <span class="keyword">int</span></span><br><span class="line">        b        <span class="keyword">int</span></span><br><span class="line">        expected <span class="keyword">int</span></span><br><span class="line">        err      error</span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="literal">nil</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="literal">nil</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="literal">nil</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, DivisionByZeroError&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        i, err := Div(v.a, v.b)</span><br><span class="line">        <span class="keyword">if</span> i != v.expected || err != v.err &#123;</span><br><span class="line">            t.Errorf(<span class="string">"input %d, %d, expected %d, got %d"</span>, v.a, v.b, v.expected, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式比较简洁，参数一目了然，而且方便扩展添加新的用例，这里需要注意一下那个error，可以先定义一个自定义的error方便判断，同时使用了<code>t.Errorf</code>格式化入参和出参方便排查错误。</p><blockquote><p>为了更方便的断言结果，我们可以使用第三方的assert库，Github上面也有很多开源的测试库，可以简化你的操作，更快速的编写测试用例。</p></blockquote><h2 id="4-功能测试"><a href="#4-功能测试" class="headerlink" title="4.功能测试"></a>4.功能测试</h2><p>功能测试就和你用Postman去测试一样，我们需要把这个服务启动起来，然后模拟用户的操作，去测试结果是否符合预期。测试本身是个非常广泛的话题，有很多种方式，这里我只说说平时用的比较多的Http服务的接口测试。</p><p>首先，我们需要了解一下Go里面Http服务的创建方式，最简单的方式莫过于下面这种：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/div"</span>, DivHandler)</span><br><span class="line">    _ = http.ListenAndServe(<span class="string">":8888"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DivHandler</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span>  &#123;</span><br><span class="line">    a := request.PostFormValue(<span class="string">"a"</span>)</span><br><span class="line">    b := request.PostFormValue(<span class="string">"b"</span>)</span><br><span class="line"></span><br><span class="line">    paramA, _ := strconv.Atoi(a)</span><br><span class="line">    paramB, _ := strconv.Atoi(b)</span><br><span class="line"></span><br><span class="line">    i, err := Div(paramA, paramB)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        _, _ = writer.Write([]<span class="keyword">byte</span>(<span class="string">"error"</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    _, _ = writer.Write([]<span class="keyword">byte</span>(strconv.Itoa(i)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码就是使用了Go自带的http库创建了一个Web服务，它提供了一个接口，功能和之前的函数一样，如果出错的话就返回error。</p><p>我们可以使用Go的一个http recorder对这个http服务进行测试，方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"net/http/httptest"</span></span><br><span class="line">    <span class="string">"net/url"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDivHandler</span><span class="params">(t *testing.T)</span></span>  &#123;</span><br><span class="line">    recorder := httptest.NewRecorder()</span><br><span class="line"></span><br><span class="line">    params := url.Values&#123;&#125;</span><br><span class="line">    params.Add(<span class="string">"a"</span>, <span class="string">"42"</span>)</span><br><span class="line">    params.Add(<span class="string">"b"</span>, <span class="string">"2"</span>)</span><br><span class="line"></span><br><span class="line">    request, _ := http.NewRequest(<span class="string">"POST"</span>, <span class="string">"/div"</span>, strings.NewReader(params.Encode()))</span><br><span class="line">    request.Header.Add(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>)</span><br><span class="line"></span><br><span class="line">    DivHandler(recorder, request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> recorder.Result().StatusCode != <span class="number">200</span> &#123;</span><br><span class="line">        t.Error(<span class="string">"Test failed"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    body, _ := ioutil.ReadAll(recorder.Result().Body)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">string</span>(body) != <span class="string">"21"</span> &#123;</span><br><span class="line">        t.Error(<span class="string">"Test failed"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个测试用例里面，我主要测试了2点，一个是返回码是不是200，另外测试了一下正常的返回结果。不过很明显，我这里并没有覆盖到异常情况。</p><p>很多Go的Web框架，比如Beego和Gin，框架本身会多一层路由，但是测试方式大同小异，主要还是使用http recorder来实现，这里就不多说了。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>这里介绍的只是最简单测试方式，实际开发中想要完全做好测试还有很多问题，比如有些系统有很多外部依赖，在测试的时候可能还要借助于mock。再比如有很多Web服务还涉及到数据库层，想要完整测试还要做好数据回滚。</p><p>国内很多公司对测试要求并不严格，很多公司都不要求写测试，有些虽然有测试覆盖率要求，但是也是为了应付（代码都写完了，后面再加测试也就图个心理安慰），测试用例并无法保证代码质量，我觉得真正想提高代码质量还是得靠<code>code review</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你看过很多开源库的源码，你会发现大部分项目都有很多详细的测试代码，一般来说测试覆盖率越高说明这个项目的质量越高，所以好的项目测试是少不了的。很多公司对代码测试覆盖率也有要求，不为别的，只为更好的代码质量。&lt;/p&gt;
&lt;h2 id=&quot;1-分类&quot;&gt;&lt;a href=&quot;#1-分类&quot; class=&quot;headerlink&quot; title=&quot;1.分类&quot;&gt;&lt;/a&gt;1.分类&lt;/h2&gt;&lt;p&gt;虽然业界有一直开发模式叫做测试驱动开发（TDD），但是了解的人都知道&lt;code&gt;TDD&lt;/code&gt;对开发要求太高了，它要求你先写测试用例然后再写代码，需要你写代码之前思考很多，需要大量时间，我实际开发中并没有采用过这种模式，估计国内都应该很少。&lt;/p&gt;
&lt;p&gt;我们可以粗略的把测试用例简单划分为2种类型，一种是&lt;code&gt;单元测试&lt;/code&gt;，它是针对某个模块、函数、方法的测试，另一种是&lt;code&gt;功能测试（集成测试）&lt;/code&gt;，它是针对整个项目功能是否可用的测试。举个例子，你写个了Web服务接口，单元测试可能是针对这个接口里面调用的一个函数测试，而功能测试就是测试这个接口是否可用，因为一个接口可能调用了多个函数。&lt;/p&gt;
&lt;h2 id=&quot;2-单元测试&quot;&gt;&lt;a href=&quot;#2-单元测试&quot; class=&quot;headerlink&quot; title=&quot;2.单元测试&quot;&gt;&lt;/a&gt;2.单元测试&lt;/h2&gt;&lt;p&gt;Golang里面的测试和其它大部分语言的测试不多，只不过表示形式略有不同，比如Go的单元测试通常情况下是和被测试的代码放在一起的，以&lt;code&gt;xxx_test.go&lt;/code&gt;命名并且测试的函数名必须以&lt;code&gt;Test&lt;/code&gt;开头。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程开发" scheme="https://wangbjun.site/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.site/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>你是否真的需要使用Linux？</title>
    <link href="https://wangbjun.site/2020/linux/do-you-need-linux.html"/>
    <id>https://wangbjun.site/2020/linux/do-you-need-linux.html</id>
    <published>2020-02-10T01:52:44.000Z</published>
    <updated>2020-03-08T12:54:47.928Z</updated>
    
    <content type="html"><![CDATA[<p>自从跨入IT编程行业一直都在使用Linux桌面系统办公（尝试过挺多发行版，最终选择Ubuntu），平时生活也在用，不知不觉已经4年多了，也安利了身边很多人使用Linux，从最早的疯狂折腾到现在追求稳定，其实也颇有感触，闲来无事聊一聊。</p><p>我和很多人一样，最早接触的都是<code>Windows</code>系统的电脑，我也一度是Windows的爱好者，记得当年还对XP、IE情有独钟，装系统、优化系统这些事情当年也没少做，也没少折腾，基本上到了打开任务管理器，对里面每一个进程的作用以及关闭某个进程会导致什么问题都了解的地步。而当时我对Linux的印象也停留在黑框框上面，觉得很神秘，对技术要求很高，只在很多电影里面看见黑客会用到，毕竟那会我对OS需求只是到用的地步，并没有接触编程开发。</p><img src="/images/2020-02-10-1.jpeg" /> <a id="more"></a><p>实际上，踏入编程行业之后，我发现很多教学教程用的还是Windows居多，或者是Mac OS，使用Linux的人还真不多，那会我无意间了解到一个叫<code>Kali</code>的系统，了解这个系统的都知道，Kali这个系统是专门用于<code>安全渗透测试</code>，它开箱自带了很多非常有用的工具，比如说可以用于制作木马、中间人攻击、钓鱼、抓包破解WiFi等等，我最初也是因为对黑客比较感兴趣才会去使用这个系统。具体的话我在另一篇文章说到，我拿Kali做了很多有意思的事情，不过后来渐渐就不用了，毕竟我从事的不是IT网络安全行业。</p><p>我最早使用Ubuntu的时候，那会的版本使用的还是unity桌面，我个人非常喜欢这个桌面，但是Ubuntu 18.04之后的版本换成gnome了。目前我依然坚持使用unity的一个原因就是unity桌面的沉浸式状态栏非常好看，其次unity桌面的颜值很高，另外就是习惯了，毕竟用了好几年了，可惜被官方抛弃了。</p><img src="/images/2020-02-10-2.png" /> <p>大约2年前，我建了一个Ubuntu桌面的交流QQ群(<code>群号: 541114553</code>)，那会只有几个人，后来一直也没打理，没想到最近半年陆续有很多人申请加入，现在已经有100多人了。</p><img src="/images/2020-02-10-3.png" /> <p>但是我发现加群的人大部分都是小白，都是来问问题的，问的最多的问题都是关于安装的问题。诚然，Linux系统的安装确实是个头疼的事情，特别是在有独显的机器上面，可能还涉及到硬件驱动兼容性问题。有时候并不是我不想回答问题，只是有些问题完全是可以搜索解决的，只是很多伸手党懒的去研究，我在不同机器上面安装Linux的次数没有上百次也有几十次了，也安装过双系统，包括黑苹果双系统，折腾系统很多年，什么样的问题都遇到过，所以我这里总结一下解决问题的思路：</p><ul><li><p>首先，准确的描述报错问题。很多人在遇到问题之后搜索都不会，主要是因为不知道如何表达。有些人说自己英文太差，看不懂报错。。。也有人说报错太多，不知道哪地方是重点。</p></li><li><p>其次，先<code>百度|Google</code>一下，99%的问题网上都有答案，就看你会不会搜索。英文确实很主要，Google搜出来的很多都是英文的，如果你看不懂那确实有点难，毕竟翻译有时候并不准确。</p></li></ul><img src="/images/2020-02-10-4.png" /> <ul><li><p>然后，提问的艺术。提问要准确描述你要干什么？、你遇到的问题？、然后最好附上截图或者视频。</p></li><li><p>最后，既然选择使用Linux，就一定要有耐心和动手能力，我最早折腾Linux，不知道重复安装了多次，每次折腾挂了就重新安装。如果不想折腾，可以出门右转Windows或者Mac。</p></li></ul><p>针对大家遇到的Linux安装问题，我这里说一下常见的问题点：</p><ul><li><p>BIOS，建议关闭安全启动和快速启动，有些电脑<code>BIOS</code>里面有很多是为Windows优化的。如果你连BIOS是什么都不清楚，回去补功课吧。</p></li><li><p>显卡驱动，N卡对Linux的支持比较烂，但是英特尔家的集显还是比较好。如果安装有问题，可以尝试屏蔽独显，笔记本可能需要在BIOS里面调，台式机可以在<code>grub</code>加启动安装参数，具体的百度，在安装完成进系统之后再单独安装驱动。</p></li><li><p>硬件驱动，某些比较新的笔记本有些硬件，比如无线网卡，蓝牙可能没驱动，Linux的驱动都在内核里面，如果不支持你有2种选择，一种是查一查最新的内核有没有带驱动，如果有那可以升级内核。另一种是查看该硬件官网是否有单独的Linux驱动提供下载，如果有可以自己编译安装。</p></li><li><p>双系统，建议先安装Windows然后再安装Linux，很多发行版可以检测到你安装了Windows，所以在你安装Linux的时候可以保留Windows，自动变成双系统。而Windows安装则不会管你Linux，它会覆盖掉，虽然后面也可以通过修复引导等方式解决，不过很麻烦。</p></li></ul><p>最后，我想说一个比较重要的话题，那就是你为什么要使用Linux？</p><p>首先，我不建议非IT行业从事者使用Linux，操作系统本质上只是一个工具，大部分非IT技术行业者可能只是好奇，但他们没有相关技术能力解决一些问题，他们可以选择更好用的面向消费者的Windows或Mac，少折腾多花点时间放在工作上会更好。</p><img src="/images/2020-02-10-5.png" /><p>本人使用Ubuntu原因主要有下面几点：</p><ul><li><p>编程开发方便，无论是工具还是环境，Linux对编程都非常友好，这一点不用质疑。有人说使用Linux的人到最后都会转向Mac，我旁边确实有人是这样，但是我觉得我不会。Mac的操作习惯是反人类的，我曾经在黑苹果上面尝试过一段时间，最终还是没有坚持下去。</p></li><li><p>渲染效果，特别是高DPI下，Linux的渲染效果和Mac是同一个级别的，毕竟都是类Unix系统。建议有条件的童鞋可以换个4k屏幕，效果非常出众。</p></li><li><p>流氓软件少，Linux下很多国产软件也安分很多，比如搜狗输入法、WPS、网易云音乐都没有弹窗广告，也不会开机自启。另外，各种木马病毒也少很多，我用了这么多年从来没遇到过。</p></li></ul><p>如果非得说缺点，就是打不了游戏，虽然steam也有Linux版本，但是支持的游戏少，也就Dota2比较出名。我是安装的双系统，只有玩游戏会切换到Windows。</p><p>从国内Linux生态圈来说，最近几年确实好很多，主要是政策原因，很多软件纷纷推出Linux版本，比如百度网盘、QQ，但是诚意不足，很多都是拿Web端套个壳，要不然就是功能简陋。虽然总体上说Linux依然是少数人使用的系统，但是这并不妨碍Linux的发展，毕竟Linux不仅仅是工具，更是一种<code>自由</code>软件的信仰！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从跨入IT编程行业一直都在使用Linux桌面系统办公（尝试过挺多发行版，最终选择Ubuntu），平时生活也在用，不知不觉已经4年多了，也安利了身边很多人使用Linux，从最早的疯狂折腾到现在追求稳定，其实也颇有感触，闲来无事聊一聊。&lt;/p&gt;
&lt;p&gt;我和很多人一样，最早接触的都是&lt;code&gt;Windows&lt;/code&gt;系统的电脑，我也一度是Windows的爱好者，记得当年还对XP、IE情有独钟，装系统、优化系统这些事情当年也没少做，也没少折腾，基本上到了打开任务管理器，对里面每一个进程的作用以及关闭某个进程会导致什么问题都了解的地步。而当时我对Linux的印象也停留在黑框框上面，觉得很神秘，对技术要求很高，只在很多电影里面看见黑客会用到，毕竟那会我对OS需求只是到用的地步，并没有接触编程开发。&lt;/p&gt;
&lt;img src=&quot;/images/2020-02-10-1.jpeg&quot; /&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://wangbjun.site/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://wangbjun.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>谈谈城市化和农村现状</title>
    <link href="https://wangbjun.site/2020/life/city-and-county.html"/>
    <id>https://wangbjun.site/2020/life/city-and-county.html</id>
    <published>2020-02-07T04:57:19.000Z</published>
    <updated>2020-03-08T12:56:21.175Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此次疫情爆发，有人说现在农村最安全，因为农村一般都是自建房，分布零散，而城市里面都在小区里面，住在火柴盒一样的格子楼里面，进出同一个楼道，同一个电梯，被感染的几率大很多。</p></blockquote><p>我从小在农村长大，自始至今，依然是个农村人（户口还在农村），大学之后，基本上都在城里面上班工作，但是过年还是在老家。有时候早上还在车水马龙、遍布高楼大厦的城里面，晚上就来到了农村蛙声一片的田野边，一个是现代化的城市，另一个是传统的农村，感触十分之深。</p><p>今天我就聊聊我一些关于农村和城市的事和想法，可能比较零散，纯属回忆！</p><a id="more"></a><div align="center">    <audio controls autoplay loop>      <source src="/audios/ahq.mp3" type="audio/mpeg" >    </audio></div><h2 id="一样的经历"><a href="#一样的经历" class="headerlink" title="一样的经历"></a>一样的经历</h2><p>我在农村长大这些年的时光几乎和很多农村人一样，曾经也住过土房子，经常下河抓鱼摸虾，插过秧也种过地。。。很多和我年龄一样大但是在城里长大的孩子肯定没有经历过，但是或许他们父母（也可能是爷爷奶奶）经历过。</p><p>有趣的是，相对于和我同龄的人，我们虽然年龄相同但是经历不同，但我和他们父母虽然不在一个年龄段却可能拥有相同的经历。我相信，即使在2020年的今天，中国依然有很多孩子留守在农村，过着和我20年前差不多一样的农村生活。</p><h2 id="房地产市场化"><a href="#房地产市场化" class="headerlink" title="房地产市场化"></a>房地产市场化</h2><p>从农村到城市，这样的过程依然在很多地方进行着，只不过不同人可能处于不同的阶段，有些人可能在30年前就完成了这个过程。</p><p>有人说现在很多的城里人以前也是农村人，确实是这样，中国的城市化的快步发展很大程度上得益于国家政策的变化，也就是房地产市场化，开放城市落户，差不多是最近20年才完成的事情。我们盖了大概可以容纳30亿人的房子，全民都在买房、炒房，房子成为每个人最值钱的财产。</p><h2 id="落寞的小洋楼"><a href="#落寞的小洋楼" class="headerlink" title="落寞的小洋楼"></a>落寞的小洋楼</h2><p>我记得我上小学初中的时候那会，大约在03年左右，农村都在盖自建房以代替之前的土瓦房，那会很流行盖“小洋楼”，一般多为2-3层的楼房，现在你去农村看看还有很多，大部分都荒废了，因为农村根本没人了，即使现在农村几乎家家都有水泥路，有些地方甚至都通了自来水，光纤网络，虽然基础设施建设并不差，但是没人愿意住农村。</p><p>我在想，那会为什么没有人去城里买房呢？那会估计房子几百块一平方米就可以吧？</p><img src="/images/2020-02-07.jpeg" /> <p>其实并不是他们不想买，是因为根本买不到，我不知道中国房地产正式市场化具体时间点是什么时候，但是我肯定那会你在城里面买不到房子，也落不了户口，孩子更上不了学。</p><h2 id="割裂的家族"><a href="#割裂的家族" class="headerlink" title="割裂的家族"></a>割裂的家族</h2><p>农村有很多小村庄，一个村里面的基本上都是亲戚，毕竟那会兄弟姐妹很多，我有一个大伯，早年当兵，部队退伍之后给安排在省会，之后他们那一岔全部都在城里面发展了，他的子女就是原生的城里人了。早些年，村里老一辈在世的时候有时候还会回农村过年，清明节也会回家祭祖，小时候他们经常回来带着胶卷相机给我们拍照。</p><p>在农村，传统的血缘关系家族早已分崩离析，有钱的亲戚基本上都进了城，更有钱的甚至出了国，没钱的还在农村，久而久之就不联系了。即便现在网络通信发达，动动手指就能聊天视频，也懒的去问候寒暄。</p><p>传统的大家族时代一去不复返，现在很多人只生1个子女，慢慢在一个城市生根发芽，会逐渐演变成小家族（家庭）时代，我觉得这个重组的过程大约需要2代人吧。</p><blockquote><p>城里人亲戚基本上都在一个城市，而很多农村人的亲戚基本上遍布全国，这大概就是相濡以沫，不如相忘于江湖。</p></blockquote><h2 id="无处安放的土地"><a href="#无处安放的土地" class="headerlink" title="无处安放的土地"></a>无处安放的土地</h2><p>有些人可能不知道种地一年能挣多少钱，更不知道农业税有多重。我家以前大概分了10亩地，我记得忙活一年收的稻谷大概能卖5000块钱，其中农业税大概需要2000块钱。事实上，农业税只是统称，那会农村的税目不比现在企业的少，其中包括修路修桥、水利等很多类目。</p><p>在我上小学的时候，那些年农业税征收是政府的大事，每年秋收之后，田野间经常能看到浩浩荡荡的村干部一行十几人，挨家挨户催收。有些村民远远看见村干部来了，会关门出去躲开，但也有硬碰硬的，经常发生打架事件，村干部被打伤打死的事情时有发生。</p><p>那时候官民关系非常紧张，我亲眼所见，我叔的稻谷被村干部找来收粮人“强行”卖掉拿来交税（一般稻谷春季价格高一点，所以很多人会留着不卖），你不卖村干部帮你忙，卖了还帮你数钱，多的还你，比劫匪好一点。</p><blockquote><p>那时候中国工业刚刚起步，政府用农业补贴工业，对农民的压榨太狠了，后来工业差不多发展起来了，最终取消了农业税。</p></blockquote><p>为什么没人愿意种地？原因其实很简单，水稻小麦的价格是由政府定的（传说中的指导价），这个定价基本上是不让你饿死就行了，现在你随便去城里打工，一年收入也有好几万，你会为了几千块在家种地吗？</p><h2 id="农场主制度"><a href="#农场主制度" class="headerlink" title="农场主制度"></a>农场主制度</h2><p>现在农村的土地大部分都是承包给个人种植了，也就是说传说中的农场主制，不过这和美国的农场主差远了。土地大规模承包确实有利于机械化种植，发挥规模效益，但是其实很有限。很多地方连农场主都不想干了，土地就荒废了，原因很简单，也挣不了多少钱，一方面粮食价格国家控制，另一方面农药化肥价格是市场控制，作为种地的人，你什么都控制不了，连收成还得看天。</p><h2 id="消失的村镇"><a href="#消失的村镇" class="headerlink" title="消失的村镇"></a>消失的村镇</h2><p>这几年在农村过年晚上放烟花的人越来越少，农村基本上已经没人了，城里还不给放，印象中农村过年烟花放的最多的时候大约在05年左右，那会晚上农村还很热闹。</p><p>在农村有很多村和镇，有些地方逐渐发展壮大，有些地方逐渐消失，发展一个县城可能要吸引下面几十个乡镇的人口迁移，如果不这样做，那么多房子卖给谁呢？</p><p>但是光把房子盖起来，没有配套的工作，买了房又有什么用？这是很多三四线城市面临的问题</p><h2 id="房子还是公寓？"><a href="#房子还是公寓？" class="headerlink" title="房子还是公寓？"></a>房子还是公寓？</h2><p>在美国，一般说房子（house），是指那种带院子的独栋建筑，而中国所说的房子其实在美国一般被称为公寓（department），也就是格子房。在中国也有房子，不过一般都是别墅，很多大城市郊区都遍布了大规模的别墅群，但是和美国比还是差远了，而中国农村的自建房其实也可以算是别墅的一种。</p><p>如果你用过Google的卫星地图，你可以看看美国的城市，你会发现美国的城市规模非常之大，全部都是独栋建筑，很少有类似中国的高层小区。所以很多人戏称美国是大农村，没毛病，和中国农村差不多。</p><img src="/images/2020-02-07-2.jpeg" /> <p>中国这种密集的高层小区便于管理，可以很好利用公共基础设施，同时方便了快递、外卖、共享单车等行业发展，但是其弊端已经在慢慢展现。</p><p>如果能解决交通问题，我相信很多人还是愿意住在郊区、住在农村，每天开车去城里上班，而不用住在城中心拥挤的出租房或者监狱一样的格子楼。</p><h2 id="人口红利在消失"><a href="#人口红利在消失" class="headerlink" title="人口红利在消失"></a>人口红利在消失</h2><p>这基本上已经是公认的事实，很多年轻人受过教育，再加上中国不是一个尊重蓝领的社会，所以很多都不太想从事体力劳动，宁愿去拍段子玩抖音也不会去送快递。</p><p>在北上广这样的一些城市，只要你肯吃苦，无论是送快递还是送外卖，这些体力活一个月上万收入不是问题。即使在很多工厂的流水线上面，现在一个月拿5-6000块钱也不是什么难事。</p><p>我们父母这一代现在很多已经50多岁，基本快干不动，90后已经快30岁了，这群人马上就要成为社会主力。在未来，只要是涉及人力的活以后的成本会越来越高，这一点我们可以参考美国等发达社会，蓝领的工资很多时候比在办公室的白领还高，这种趋势势不可挡。</p><h2 id="李子柒式农村生活"><a href="#李子柒式农村生活" class="headerlink" title="李子柒式农村生活"></a>李子柒式农村生活</h2><p>中国的农村在很多人的印象里面只有一个字：穷，农村人几乎已经成了穷人的代言词，现在除了个别风景优美的地区被开发成了风景区，大部分农村和美也沾不上边。</p><p>李子柒给大家营造了一个梦想中的田园生活，而现实中的农村生活往往充满了破败荒芜，每个人都在努力工作努力赚钱，憧憬着买房买车，亦或是为子女忙碌。大部分农村人背井离乡，只为在城里面买房定居，过上更好的生活。</p><img src="/images/2020-02-07-1.jpeg" /> <p>或许当我们无欲无求的时候，才可以像李子柒视频那样潇洒，日出而作，日落而息，双手去耕作，用汗水收获果实。</p><p>农村的田园生活已经离我们太遥远了，在工业化时代，规模经济是趋势，社会分工日益明确，你不用亲手去种植蔬菜，你只需要选择一个可以挣钱的工作就行，你可以是流水线工人，也可以是办公室白领。</p><h2 id="如果"><a href="#如果" class="headerlink" title="如果"></a>如果</h2><p>如果我可以选择，我选择与自然为舞，不被高房价绑架，也不必终日为工作劳累，花更多的时间陪陪家人！你会怎么选？</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;此次疫情爆发，有人说现在农村最安全，因为农村一般都是自建房，分布零散，而城市里面都在小区里面，住在火柴盒一样的格子楼里面，进出同一个楼道，同一个电梯，被感染的几率大很多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我从小在农村长大，自始至今，依然是个农村人（户口还在农村），大学之后，基本上都在城里面上班工作，但是过年还是在老家。有时候早上还在车水马龙、遍布高楼大厦的城里面，晚上就来到了农村蛙声一片的田野边，一个是现代化的城市，另一个是传统的农村，感触十分之深。&lt;/p&gt;
&lt;p&gt;今天我就聊聊我一些关于农村和城市的事和想法，可能比较零散，纯属回忆！&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="https://wangbjun.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="Life" scheme="https://wangbjun.site/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>“武汉肺炎”小记</title>
    <link href="https://wangbjun.site/2020/life/wuhan-ncp.html"/>
    <id>https://wangbjun.site/2020/life/wuhan-ncp.html</id>
    <published>2020-02-06T01:51:06.000Z</published>
    <updated>2020-03-08T12:56:21.171Z</updated>
    
    <content type="html"><![CDATA[<p>截止我写这篇文章的时候，这次肺炎病毒已经感染了数万人，而且还在持续增长！</p><img src="/images/2020-02-06.jpg" /> <p>每天醒来第一件事情就是打开手机，刷新一下数据，从最开始的几百人、到几千人、再到现在的几万人。。。在这里我想说说自己看到或者了解到的一些社会现象，谈谈自己的感受。</p><p>在我的记忆力，2003年还非常遥远，那时候我应该还在上初中，记得那时候学校被封闭，外人不得进出，教室每天早上都会有一股浓厚的消毒水味。</p><a id="more"></a><p>由于我平时也会逛逛油管，在油管上面有很多“时政”自媒体，这也就是一些墙外消息的来源，人所以很早之前也听过一些“谣言”，说说武汉出现SARS病毒了。这种非官方新闻我一般都是半信半疑，在没有确凿证据的情况下也不敢全信，更不敢传播，不然被定个罪就麻烦了。</p><p>2020年1月19日，新闻说北京大兴有2例确诊，当天上班的时候也有很多讨论这件事，这时候很多人开始慌张了，公司前台给大家发口罩，不过我并没有要。</p><p>我当时觉得这事并没有多大，毕竟连政府都没什么行动，北京才2例，觉得很多人有点大惊小怪，有些朋友开始跑医院买口罩，很多医院的口罩卖空，一下子口罩成了稀缺品。晚上坐地铁的时候发现大约有50%的人都戴了口罩。那会我还没有把这事放在心上，因为买不到口罩所以上班也没戴口罩，甚至感觉某些人反应过度，开始拼命的要买口罩。</p><p>我是2020年1月22日的火车，从北京南站出发，那时候我发现候车厅大约80%的人都戴了口罩，感觉事态有点严峻，由于我自己没口罩，所以刻意和其他人保持了距离。</p><img src="/images/2020-01-22.jpeg" /> <p>2020年1月22日晚，坊间传言武汉要封城，我一个朋友这时候正在回家的火车上，她刚好要从武汉转车，听她说车上人都慌了，有人怕封城出不去直接在中途郑州站下车了。后来正式新闻出来了，1月23日10点，武汉正式封城。</p><p>实际上，这会官方数据确诊只有几百人，但是这种封城动作让人胆战心惊，网上各种“谣言”四起，其实很多“谣言”都是来自墙外新闻，我一直也在油管上关注，有人说凡是官方辟谣的都是真的，不管你们信不信，我反正是信了。</p><p>过年这段时间，非常糟糕，在家里哪里都不能去，走亲访友的计划全部取消。。。然后接连不断的新闻爆出: 出门不戴口罩违法、封城、封村、挖坑断路、假期延长、武汉人被举报排挤，只见疫情事态逐步升级！</p><img src="/images/2020-01-27.jpeg" /><p>由于我所在公司宣布2月3日起在家办公，但是我回家的时候并没有电脑，所以我决定2月2日返京。我们那高铁依然正常运行，入站的时候需要测体温，听说我走后第二天村就被封路了。</p><img src="/images/2020-02-02.jpeg" /><p>火车站人确实很少，不过我那车刚好是晚上，本身人就不多，火车上卧铺上我那间6个床位只有我一个人，我走了一圈看了下，大部分床位都没人，看来返京的人确实不多。</p><p>到了北京，我进地铁的时候看见几个安检员在那嬉笑，居然没有给我测体温。网上新闻报道北京很多小区不允许租房的人进小区，我并没有遇到这种情况，只是在门口登记了一下，虽然配备了测温枪，但是那保安并没有给我测量体温。</p><p>有一件意料之外的事情，大家都知道这次疫情对工业、餐饮、娱乐、旅游、交通等很多行业是个致命的打击，可以说整个国家经济都受到影响，损失非常惨重。但是很多小的口罩厂却发财了，这些口罩厂原来多是生产一些工业口罩、一次性普通口罩或者布口罩，原来卖几毛钱一个，利润率非常低，甚至可以说濒临倒闭，现在可以卖几块钱一个，虽然从单价上看并不贵，但是价格缺翻了很多倍。大家知道现在口罩太难买了，我至今出门只戴了一个布口罩，心理安慰是其一，主要是不戴口罩出不了门。短期内很多工厂都开不了工，口罩的缺口依然很大，毕竟中国有14亿人口，平时戴口罩的人很少，市场需求不大，现在人人都要戴口罩，即使所有口罩厂全力生产也无法满足需求，现在连一次性的普通口罩都买不到，更别说什么N95口罩。</p><p>这次病毒什么时候是个头？很多公司原定10号正式返岗上班的计划又遍了，有人说15号或许是个拐点，也有人得到2月底，很多地方的管控越来越严。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;截止我写这篇文章的时候，这次肺炎病毒已经感染了数万人，而且还在持续增长！&lt;/p&gt;
&lt;img src=&quot;/images/2020-02-06.jpg&quot; /&gt; 

&lt;p&gt;每天醒来第一件事情就是打开手机，刷新一下数据，从最开始的几百人、到几千人、再到现在的几万人。。。在这里我想说说自己看到或者了解到的一些社会现象，谈谈自己的感受。&lt;/p&gt;
&lt;p&gt;在我的记忆力，2003年还非常遥远，那时候我应该还在上初中，记得那时候学校被封闭，外人不得进出，教室每天早上都会有一股浓厚的消毒水味。&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="https://wangbjun.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="Life" scheme="https://wangbjun.site/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>一个野生程序员的北漂之路（三）</title>
    <link href="https://wangbjun.site/2020/life/2019-3.html"/>
    <id>https://wangbjun.site/2020/life/2019-3.html</id>
    <published>2020-01-22T06:43:14.000Z</published>
    <updated>2020-03-08T12:54:47.956Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章说到我二家公司由于经营不善，濒临倒闭，拖欠工资，最终我选择自离找工作。</p><p>2018年03月，这次找工作非常顺序，我请假面了大概5个公司拿到2个offer，最后选择了一家我觉得还可以的公司，xx网，工资15k。</p><blockquote><p>xx网实际上是某大型教育公司下面一个部门的网站，专门面向程序员，并不是公司名字，很多学习编程的同学应该看过他们网站的课程。</p></blockquote><p>之前也看过他们网站的课程，觉得很不错，这个部门有100多人，其中技术40多人，在这家公司的上班体验总体还不错，除了每天早上无聊的站会以及每周周会，公司属于业务驱动型，大多做的一些业务开发。</p><p>直到2018年底春节放假那天，技术老大拉我进屋，悄悄告诉我，经过公司决定，你今年没有年终奖，我当时一脸懵逼，问他为什么？</p><a id="more"></a><p>他吞吞吐吐说因为什么线上bug，但是也说不清楚，说只是通知我一声，怕我不了解情况以为是漏发了。</p><p>后来得知不止我一个人，总共有好几个人都没有年终奖，据老员工透露一般没有年终奖的过完年会给n+1，意思就是过完年裁员会给n+1赔偿，公司也不是第一次这样干。</p><img src="/images/20200202152512.jpg" /> <p>其实裁员我可以理解，为什么都是我们年初刚入职的员工呢？了解才得知原来整个公司去年早就换血了，只剩下几个小组leader是老员工，其它都是新来的。</p><p>我更不理解，虽然这一年我表现不算突出，但也算是兢兢业业，努力工作，为什么选择我呢？我想过很多原因，直到离职后来听一个同事说，公司给他们涨薪了，但是名额有限，老大给他自己河南老乡全部涨了…</p><p>我平时大多数都是埋头写代码，不擅长在领导面前表现，一年下来基本上没有和老大聊过什么，他也只在周会的时候会询问项目进度，更别说其它的事情了，如果说bug的话，写代码谁没有bug。</p><p>这时候我突然想起来公司年初的骚操作，年初公司入职的人非常多，正常是3个月试用期，然而就在试用期快结束的时候，有几个同事被告知试用期不合格，被辞退，我在办的入职他们在办离职。如果不合适就不要招人进来，招人之后干了3个月最后一天辞退，这种行为实在恶心。</p><p>过完年回来之后，我在忙完手头的工作，拿了2个月补偿就走了，对这种公司我没有什么留恋，也不想多待一天。</p><img src="/images/20200202152503.jpg" /> <p>公司有一个同事和我比较熟，后来聊天的时候他说他工资比较低，只有12k，老大过年前和他说年后给他涨工资，但是一直到次年6月份都没有兑现，最后他也走了。</p><blockquote><p>后来才得知，这家公司，负责这个项目的老大是销售出身，集团公司给我们部门定了销售KPI，由于远远没有达到预期目标，所以就拿技术开刀，不是第一次这样了，每年都会裁人招人，公司的文化就是这样，谁遇到谁倒霉。</p></blockquote><p>本以为这是一个拥有2000多人的公司，应该会稳定点，没想到我又栽了，又得重新找工作了。</p><hr><p>2019年03月，我重新整理了简历，开始了面试，这时候招聘市场早一年不如一年了，非常艰难，我的直属领导其实还挺好，找关系给我内推了，也给了offer，虽然最后我没去那家公司。</p><p>面了半月，拿到几个offer，有些薪资太低就没去了，有些是因为公司太小，不想去创业公司了。最终去了一家互联网金融集团下面的子公司，这家公司技术团队有200多人，我们部门有15个人，从技术团队建设上说，这家公司其实非常不错，比我去过的所有公司都要好。</p><blockquote><p>刚入职那会我对p2p还没什么概念，虽然也看了新闻，知道国家一直在管理规范p2p，清退一些不合格企业，但是这个公司借贷规模上百亿，也是上市公司，论体量也属于头部公司了，应该没问题。</p></blockquote><img src="/images/20200202154032.jpg" /> <p>2019年07月，董事长突然来公司给大家开了一个临时会议，给大家透露了一些情况，主要就是说政策又变了，公司非常难，他在努力解决困难，公司平台遭到挤兑，暂停提现了，如果大家有人要走，他也不拦着。这时候我才知道事情的严峻性，国家可能不会给p2p活路了。</p><p>一直在公司被抓之前，公司陆续有人离职，也在陆续招人，我们部门走了2个，我心里知道其实早就会有这一天，只是时间问题，但是我没有选择走，一方面是我们部门领导对我还行，中间还给我提了一次涨薪，虽然不多，还有就考虑到我刚来公司不久离职工作也不好找工作，决定再坚持一段时间，心想至少等过完年再看吧。</p><p>那会公司依然正常运行，工资不仅没有拖欠，经常还提前发，公司还给所有人都买了商业医疗补充保险，一切正常，谁也不知道哪一天什么时候到来。</p><p>2019年12月，早上，我还在地铁上，有人在公司群里说公司下面有好几辆警车，还有大巴，让我们先不要进公司，出事了。有些早上到公司的同事电话也打不通，谁也不知道是什么情况，直到下午5点某地公安局在网上发了一个蓝色通告，坐实被抓了。</p><blockquote><p>后来得知，那些同事都被警察安排坐在工位上，没收手机电脑，上厕所有人跟着，中午吃的盒饭，最终下午6点多的时候才放出来，公司所有电脑无论个人还是公司的，全部被查封带走调查了。</p></blockquote><p>领导让我们在家等消息，其实大家心里都清楚，基本上是完了，接连不断的新闻告诉我们，即使公司没有问题，p2p也是完了。。。</p><p>其实公司有没有问题我真不知道，有人担心作为公司员工会被追缴工资，这一点暂时还不确定，目前案件还在审理中，我也是受害者，我还在里面投资了1万多，也一样没有拿出来。</p><p>就这样，我又失业了…</p><hr><p>这几年，不知道是不是该说运气不好，之前的创业公司倒闭很正常，最近2年的公司规模也算比较大，但结局却一样悲惨，正如很多人说的垃圾公司毁一生，选择很重要，你不知道你进的公司是什么公司，特别是很多不出名的中小型公司，你也不知道你会遇到什么样的领导。</p><p>我知道以我现在的简历，很多公司都过不了，很多HR一看就认为跳槽频繁，工作不稳定，再加上非科班出身，出路很少！</p><p>我对自己的评价是工作态度认真负责、学习理解能力强，但是我并不是大牛，也不是那种可以手撸各种算法、精通各种源码和底层原理的技术大佬。</p><p>虽然这些年很多叫我大佬，但我知道那也只是客气话，技术这行了解的越多会发现你不会的更多，而且对于互联网技术现在基本上大家已经形成共识：淘汰快。</p><p>以前觉得技术很厉害，可以改变世界，现在觉得改变世界的其实是商业、是资本，技术只不过是商业工具，有时候也充当打手。</p><p>这几年一直很焦虑，实际上大部分技术人都是这样，总感觉有太多东西要去学，这个算法那个数据结构、xx架构、xx源码解读，卖课的公众号数不胜数，每天都在贩卖焦虑，看不完的技术视频和文章。。。</p><p>我现在甚至不太想去写代码了，这是一份相当枯燥和无聊的工作，你需要去解读产品的X逼需求，应付领导的傻X检查，去做很多和技术无关的工作！而且大部分公司并不重视你的代码质量，他们只关心项目进度，能不能按时上线，能不能为他带来利益。</p><p>最后，就这样吧，谢谢阅读！希望新的一年有新的变化！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章说到我二家公司由于经营不善，濒临倒闭，拖欠工资，最终我选择自离找工作。&lt;/p&gt;
&lt;p&gt;2018年03月，这次找工作非常顺序，我请假面了大概5个公司拿到2个offer，最后选择了一家我觉得还可以的公司，xx网，工资15k。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;xx网实际上是某大型教育公司下面一个部门的网站，专门面向程序员，并不是公司名字，很多学习编程的同学应该看过他们网站的课程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前也看过他们网站的课程，觉得很不错，这个部门有100多人，其中技术40多人，在这家公司的上班体验总体还不错，除了每天早上无聊的站会以及每周周会，公司属于业务驱动型，大多做的一些业务开发。&lt;/p&gt;
&lt;p&gt;直到2018年底春节放假那天，技术老大拉我进屋，悄悄告诉我，经过公司决定，你今年没有年终奖，我当时一脸懵逼，问他为什么？&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="https://wangbjun.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="Life" scheme="https://wangbjun.site/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>一个野生程序员的北漂之路（二）</title>
    <link href="https://wangbjun.site/2020/life/2019-2.html"/>
    <id>https://wangbjun.site/2020/life/2019-2.html</id>
    <published>2020-01-22T01:17:16.000Z</published>
    <updated>2020-03-08T12:56:21.163Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章说到我第一家公司因为融资断裂，发不起工资，解散了。这时候我们开发里面一位大佬，这里我称他为Q哥，他也刚进公司不久，如果按职级分，他应该属于高级开发工程师，平时带我们做项目，也会参与开发，毕竟当时公司开发人员不多。</p><p>当时他说他有个朋友给他介绍了一个公司，这公司非常缺人，可以直接带我们过去，不用技术面试，他和老板聊好了，我们过去见一下老板就行了。</p><a id="more"></a><p>第二天，我们几个人和老板在一个大酒店的套房里面见了面，老板看上去比较老，大概50多岁，叼着雪茄和我们聊了一些他的往事人生以及一些商业战略，最后还请我们吃了一顿简餐。</p><p>搞定了老板基本上就没问题了，老板想让我们直接入职，但公司的HR不答应，最后还给我们安排了一个HR面试，聊了聊人生以及薪资待遇，我没有要求涨薪，其中有一个小伙伴因为薪资没谈拢最后没去，最终Q哥带着我们上家公司总共不到10人空降了该公司。</p><blockquote><p>后来得知，其实这个公司也不完全是缺人，他们之前有一个不到10人的开发团队，但是项目开发进度缓慢，处于失败的边缘。听说老板花了上百万开了一个盛大的发布会，但是APP还没上线，延期很久，老板非常生气，想把技术团队都开除。</p></blockquote><p>我们空降之后，就立马开始了1个多月的封闭开发，加班加点，Q哥也一直盯着开发进度，最终顺利完成了预期目标。作为奖励，年底整个技术团队获得了一次海南三亚游，次年6月，公司搬入望京SOHO，换了一个非常大的办公室。</p><img src="/images/2020-01-03-1.jpg" /> <blockquote><p>后来了解，这老板花钱请了很多大公司的顾问，有几个BAT的技术顾问，也许是出于融资对外宣传需求，给人感觉很强大，而且技术团队之前一直是有这个百度的大佬兼职带队，就是不知道为什么进度缓慢，也没做出什么东西，据说他们之前已经做了一年多了。</p></blockquote><p>APP顺利上线后，看上去公司蒸蒸日上，但运营了几个月后发现并没有什么效果，此时Q哥主要心思不在技术上，甚至说他几乎不管技术，突然搞起运营了，亲自带队搞运营，这也最终导致了他的出走。</p><p>公司失败的原因有很多种，可能是这个老头子最终发现很多人都在围着他转，看上的是他的钱并没有用心做事，再加上他本身喜欢对产品指指点点，喜欢按着自己的想法做，比如说根据自己的想法给APP加一个功能，也从不考虑用户，整个公司说是面向老板开发也不过分。</p><p>2017年10月，由于业务基本上无增长，而且据说一年花了2000万，老板不想再投钱了，公司开始裁员，裁了几个人，办公室也从望京SOHO搬到望京西很偏的一个小商住两用办公楼，各种福利缩减，刚开始工资还能正常发放，后来每月都要拖欠工资，很多人开始离职。</p><img src="/images/2020-01-04-1.jpg" /> <blockquote><p>老板其实挺有钱，早年发家，经常去美国，那边也有业务，家人都在国外，拔过他的背景，也有些黑料，但人并不傻。这次创业应该在我来之前大约2年前就开始了，只不过不是这个公司，这个公司是后来重新注册，应该属于第二波尝试，这样几番折腾，几年下来基本上算是创业失败了。</p></blockquote><p>当时有的人劳动合同到期，公司也表示不再续期，让自己走人，没有什么工作可干，但是公司后面也不再裁员了，但是工资经常拖欠，不能按时发放，等到2018年春节之后，公司很多人都在找工作，我也趁机走了。</p><blockquote><p>不过还有同事没走继续在那边干，听他说后来没走的人每个月工资只发了一半，到最后人基本上都跑光了，可以说结果很悲催。</p></blockquote><p>我上一家公司虽然也是创业公司，但是最后起码好聚好散，但这家公司了老板最终选择故意拖欠工资逼你自己离职，当时很多人说要一起去告公司，不最终还是不了了之。</p><p>说到Q哥，我对他非常感激，他人很不错，但是说实话缺少领导力，感激是因为他带我进入这家公司，虽然最后发现是个火坑，但是这也不能怪他，谁也无法预料后来的事情。还有一点不信任是因为他后来的行为，他在这家公司大部分时间并没有管理技术，没有当好CTO，却去插上并扛下运营和产品，最终由于他的运营方案失败，自己出走，留下我们几个人不知所措。</p><p>他出走之后却又带着一位同事进入另一家类似公司，而这家公司一直是用比较传统的方法运营，但是其互联网这块是从零开始，老板据说是从华为出来，印象挺深的是我们第一次Q哥带我们和他见面的时候，刚下班还没吃晚饭，他说请我们吃饭，最后带着我们几个人在路边找了家面馆一人吃了一碗面，场面甚是尴尬！</p><p>Q哥说他技术入股，先带一个人过去，又拉了一个他以前的同事，等这边搞起来后期我们一起再过去。</p><p>可是好景不长，这家公司只持续了几个月，他们第一版东西做完之后，这个华为出来的老板居然打了退堂鼓，不想干了，不仅没有和他们签合同，连工资都一直拖着不发，最后沟通很久说可以搬电脑抵工资。。。结局就是就这么狗血！</p><p>这时候Q哥说又有朋友介绍一家新公司，说这家公司就是为了上市，资金实力雄厚，他以顾问的身份进去，可以推荐我们进去。。。说实话，经过这么多，我有点怕了，怕了创业公司。。。另外对Q哥的信任度也大大降低!</p><img src="/images/2020-01-17.jpg" /> <blockquote><p>Q哥是第一代北漂，比我们大不了多少岁，也是农村出来，但是来的早，赶上了IT行业发展的黄金时代，而且那会北京房价也不高，现在在北京有房有车，老婆孩子都很好，在我看来，算上成功人士了。但他自己好像并不是这么觉得，他觉得自己还没财务自由，总想做点事情出来，30多岁也算年轻，不想写代码，创业是个不错的选择。</p></blockquote><p>但是我其实并不想把所有宝都压在创业上面，我其实想找一个相对稳定的公司，所以后来他让我去他那边公司的时候我犹豫了，我最后决定自己投简历…</p><blockquote><p>虽然很久没有和Q哥聊了，但是知道他一直在创业，现在在做一个教育相关的小程序，希望他早日创业成功！</p></blockquote><p>这1年多，看尽了创业公司的各种结局，很多小创业公司九死一生，但是结局却各不相同。很多创业公司倒闭并不是因为技术，大部分都是因为商业模式，或者说是运营不起来，没有市场等各种原因，总之，创业难，想创业成功更难。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章说到我第一家公司因为融资断裂，发不起工资，解散了。这时候我们开发里面一位大佬，这里我称他为Q哥，他也刚进公司不久，如果按职级分，他应该属于高级开发工程师，平时带我们做项目，也会参与开发，毕竟当时公司开发人员不多。&lt;/p&gt;
&lt;p&gt;当时他说他有个朋友给他介绍了一个公司，这公司非常缺人，可以直接带我们过去，不用技术面试，他和老板聊好了，我们过去见一下老板就行了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="https://wangbjun.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="Life" scheme="https://wangbjun.site/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>一个野生程序员的北漂之路（一）</title>
    <link href="https://wangbjun.site/2020/life/2019-1.html"/>
    <id>https://wangbjun.site/2020/life/2019-1.html</id>
    <published>2020-01-21T15:32:27.000Z</published>
    <updated>2020-03-08T12:54:47.960Z</updated>
    
    <content type="html"><![CDATA[<p>虽然2020年已经到来，但是真正象征着新的一年的农历新年才刚刚开始，北漂4年多，IT这条路越走越窄，突然萌生出回家的念头，毕竟年龄也不小，算是90后最早一批奔三的人，还未成家，也谈不上立业。</p><p>在此回顾一下这些年在北京这几年的职业生涯，作为一种记录，也算是总结吧！</p><p>这些年在北京，工作换了很多个，几乎每年面试一次，微信里面同事倒是加了不少，除了聊的好的几个，大部分再也不联系。住的地方也是一年换一次，住过上下铺、地下室、天通苑、自如、一居室。。。</p><ul><li>2016年06月 第一家公司 –&gt; 融资失败、解散</li><li>2016年11月 第二家公司 –&gt; 濒临倒闭、欠薪</li><li>2018年03月 第三家公司 –&gt; 经营不善、裁员</li><li>2019年03月 第四家公司 –&gt; 涉及p2p、查封</li></ul><a id="more"></a><p>2015年10月，也许是在外漂泊够了（在此之前我一直在从事一份非常自由的工作），腰里揣着几万块钱，我决定来北京，去报名某智的培训班，学习Java。</p><p>为什么我要这么做？主要是因为从大学时代开始，我对编程就非常感兴趣，写过一点C，经常喜欢看一些关于计算机和网络的书籍，但是当时没有想过深入的学习，更没有想过毕业后会从事该行业，那时候纯粹是一些兴趣爱好。后在2013年的时候，在网上看到一些自学成才的例子，开始有这个想法，在家里自学过半年Java，买了几本书，也看了不少视频，但是最终因为各种原因并没有实际去找相关工作，曾经考虑过进培训班，但是当时也没钱就打消了这个念头，后来误打误撞去干别的事情了。</p><blockquote><p>现在回想起来，当时犯了一些错：单打独斗、学习效率不高、缺乏自信。主要是缺乏有经验的人指导，如果坚持下去或许是另一种结果，毕竟2013年那会IT的工作很好找，不像现在年年寒冬，各种裁员。</p></blockquote><p>时间回到2015年10月，这时候我已经有一定的经济能力，但是工作依然不稳定和明朗，也不知道该干啥去，但是觉得不能一直这么干下去，最终选择来北京培训，这个培训班的学费也从当年的几千块涨到1万多，不过尚可以接受。</p><p>不过最终报名的时候我选择了PHP，并没有学习Java，我当时主要是因为有人说PHP适合个人等中小型开发，而Java主要适合大型企业公司，其实现在这个说法也没错，但是当时我并不了解其实国内大厂都是Java的天下，PHP最终走向穷途末路。</p><img src="/images/2020-01-02.jpg" />  <p>由于我几年前学过C和Java，相当于有基础，所以在培训班非常轻松，很多知识似曾相识，甚至觉得老师讲的太无聊，基本上就是照本宣书，填鸭式教学。同时也发现培训班就像高中一样，有很多学习能力超级差的同学，也有学习能力强的人，我旁边有一些让我感觉属于那种怎么教都教不会的人，非常可惜他们听了培训机构的忽悠，花了很多钱，最终可能无法找到工作。</p><blockquote><p>那会我开始研究Linux，天天折腾Ubuntu，还有Kali，最有意思的是我用Kali的木马工具生成一些木马，然后利用PHP一句话木马攻破讲师的电脑，远程控制其电脑，还在其电脑上找到了我们班所有人的信息。<br>还有，比如说控制某些女生的电脑，打开其摄像头。。。不过纯属搞笑娱乐，并没有做一些过分的事情。</p></blockquote><p>在培训的这几个月里面，我真正学到东西不是很多，培训班大部分讲的东西都很基础，而且枯燥，老师每一个知识点写一个demo，缺乏编程思想层次的指导。对我来说最大的意义在于这段培训经历帮我建立了自信，因为我发现在所有的同学中我即使不是能力最强的，也是属于前排，心里对自己的能力有了一个定位。</p><p>时间过的很快，半年后，2016年5月，我们开始找工作了，出于无耐，我编了一个1年经验的简历，也有一些同学编了2-3年，还有更过分的则是造假学历、假毕业证，虽然这些都是培训机构默认的常规操作。</p><p>我这个人本身就不属于那种会说的人，以前撒谎都会脸红那种，虽然进入社会好几年但是依然无法做到游刃有余，在找了差不多半个月，面试了10几家公司之后终于拿到一个offer，虽然公司不大也是创业公司有10来个开发，但是毕竟是一个开始，工资是12k，社保最低缴纳，对我来说已经很好了，据说在所有的同学中算高的了，可能是因为我有一个本科学历吧，那时候大部分培训的同学都是专科。</p><blockquote><p>那会2016年正是创业潮，初创企业层出不穷，所以市场对开发人员有很大需求，所以像我这种半路出家的非科班选手依然有市场。</p></blockquote><p>第一次正式参加公司的编程开发工作，心里还有点紧张，很努力，不过也基本上都hold住了，然而这段工作并没有维持多久。。。</p><img src="/images/2020-01-03.jpg" /> <p>2016年11月，公司突然撑不住了。我之前一直没有关注这方面的消息，直到某一天老板说公司融资断了，发不起工资了，如果大家继续留下来也没有工资发，晚上一起吃个散伙饭吧！</p><p>那天是当月的20号，公司最后给每个人发了3000块钱，剩下的说先欠着，等哪天融到钱会第一时间给大家发工资，也可以继续回来工作，公司40多号人没有一个人提赔偿的事情，大家吃完饭喝完酒默默走人了，毕竟老板平时为人不错，不摆架子，好聚好散。</p><blockquote><p>这几年一直和其中一个同事有联系，听他说公司并没有倒闭，留了几个老员工做一些维护和少量开发工作，他就是其一。老板也在一直拉投资，客户也一直在增长，那年与其说倒闭，不如说是壮士断臂。在2018年底的时候，他和我说公司拉到了一笔投资，也不多，大概有几百万，公司正在招人扩大规模。我一直相信老板的话，觉得公司融到钱后把欠我们的半个月工资还给我们，事实上，至今老板从未和我们谈过这件事，我也未去询问过。不过我还是非常佩服这位老板的耐心和毅力，祝他早日能创业成功。</p></blockquote><p>在工作了还不到半年的时候，突然间我又失业了，又得重新找工作，但是事情却另有转机。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然2020年已经到来，但是真正象征着新的一年的农历新年才刚刚开始，北漂4年多，IT这条路越走越窄，突然萌生出回家的念头，毕竟年龄也不小，算是90后最早一批奔三的人，还未成家，也谈不上立业。&lt;/p&gt;
&lt;p&gt;在此回顾一下这些年在北京这几年的职业生涯，作为一种记录，也算是总结吧！&lt;/p&gt;
&lt;p&gt;这些年在北京，工作换了很多个，几乎每年面试一次，微信里面同事倒是加了不少，除了聊的好的几个，大部分再也不联系。住的地方也是一年换一次，住过上下铺、地下室、天通苑、自如、一居室。。。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2016年06月 第一家公司 –&amp;gt; 融资失败、解散&lt;/li&gt;
&lt;li&gt;2016年11月 第二家公司 –&amp;gt; 濒临倒闭、欠薪&lt;/li&gt;
&lt;li&gt;2018年03月 第三家公司 –&amp;gt; 经营不善、裁员&lt;/li&gt;
&lt;li&gt;2019年03月 第四家公司 –&amp;gt; 涉及p2p、查封&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="生活" scheme="https://wangbjun.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="Life" scheme="https://wangbjun.site/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github搭建免费技术博客</title>
    <link href="https://wangbjun.site/2020/linux/hexo-github-blog.html"/>
    <id>https://wangbjun.site/2020/linux/hexo-github-blog.html</id>
    <published>2020-01-08T04:05:45.000Z</published>
    <updated>2020-03-03T02:51:12.386Z</updated>
    
    <content type="html"><![CDATA[<p>最近想搭建了一个自己的博客网站，经过调研，最终决定使用Hexo+Github的形式搭建，大概花了3个小时的时间，这里简单记录一下过程，备用。</p><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>Github提供了一个免费的GIthub Pages功能，简单说就是可以让你存放静态的资源文件，比如css、js、html、image，同时会给你分配一个免费域名，格式：<a href="https://xxx.github.io" target="_blank" rel="noopener">https://xxx.github.io</a></p><p>所以你只需要注册一个Github账号，然后新建一个repository就行了，一毛线都不用花。</p><p>由于Github Pages只能托管静态资源，所以像WordPress这类博客肯定是无法运行的，这时候你有2种选择：</p><ol><li>手写静态页面，如果是前端大牛可以尝试这样</li><li>第三方博客工具生成，如Hexo、jekyll</li></ol><a id="more"></a><p>简单说，Hexo就是一个工具，它可以根据markdown文档自动生成博客的静态HTML页面，同时呢，你还可以一键换主题，网上有很多开源的主题。</p><p>Hexo 和 Github这2个完全可以单独使用，但是把2个结合起来就完美了，一个用来生成博客的静态文件，一个用户托管静态资源，服务器和域名都省了。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol><li><p>我不会告诉你如何注册Github账号、以及安装使用Git，作为一名编程开发人员应该都会</p></li><li><p>我其实也不想告诉你如何安装npm和node，但是我还是放个下载地址：<a href="https://nodejs.org/zh-cn" target="_blank" rel="noopener">https://nodejs.org/zh-cn</a></p></li></ol><h2 id="Hexo应用"><a href="#Hexo应用" class="headerlink" title="Hexo应用"></a>Hexo应用</h2><h3 id="安装运行环境"><a href="#安装运行环境" class="headerlink" title="安装运行环境"></a>安装运行环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装完成后，在命令行下执行hexo，应该可以看到以下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">jwang@jun:~$ hexo</span><br><span class="line">Usage: hexo &lt;command&gt;</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  help     Get help on a command.</span><br><span class="line">  init     Create a new Hexo folder.</span><br><span class="line">  version  Display version information.</span><br><span class="line"></span><br><span class="line">Global Options:</span><br><span class="line">  --config  Specify config file instead of using _config.yml</span><br><span class="line">  --cwd     Specify the CWD</span><br><span class="line">  --debug   Display all verbose messages in the terminal</span><br><span class="line">  --draft   Display draft posts</span><br><span class="line">  --safe    Disable all plugins and scripts</span><br><span class="line">  --silent  Hide output on console</span><br><span class="line"></span><br><span class="line">For more help, you can use &#39;hexo help [command]&#39; for the detailed information</span><br><span class="line">or you can check the docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;</span><br></pre></td></tr></table></figure><p>这里只是列出一部分命令，比较重要的就是init，它是用来创建一个新项目</p><h3 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p>文件夹名字自己起一个，它自动生成一个目录，里面文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── _config.yml</span><br><span class="line">├── db.json</span><br><span class="line">├── package.json</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><blockquote><p>简单说明一下，比较重要是有_config.yml文件,这是博客的配置，另外themes下是存放主题的目录，还有source下面的 _posts 目录，是博客文章markdown的源文件。</p></blockquote><p>然后我们进入该目录，生成静态文件并启动服务预览一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd blog</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>默认启动在本地4000端口，可以通过 -p 指定端口</p><h3 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &lt;article-name&gt;</span><br></pre></td></tr></table></figure><p>其实有2种方式写文章，一种是使用上述命令 new 一个，它会自动在source目录的_posts里面创建一个markdown文件。另一种就是你自己手动创建。</p><p>但是注意，文章头部会有一些注解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: Hexo+Github搭建免费技术博客</span><br><span class="line">date: 2020-01-08 12:05:45</span><br><span class="line">tags: Hexo</span><br><span class="line">category: 其它</span><br></pre></td></tr></table></figure><p>Hexo在生成静态页面的时候会解析这些注解，然后做一些处理，比如tags是标签、category是文章分类，都会用到。</p><p>不要忘记，每次更新文章之后，都需要执行<code>hexo g</code>重新生成静态页面。</p><h2 id="部署到GitPages"><a href="#部署到GitPages" class="headerlink" title="部署到GitPages"></a>部署到GitPages</h2><p>上面介绍如何使用Hexo生成博客，但是这时候只能在本地玩，如果你有自己的服务器的话，也可以不用GitPages，你把生成的静态文件，也就是public目录下的文件部署到你自己的服务器就行了。</p><p>如果你想部署到GitPages，那么继续接着看</p><blockquote><p>有一点需要注意，在创建GitPage仓库的时候，仓库名字最好是: 你的用户名.github.io 这种格式，如果不这样其实也行，就是分配的域名有点丑，比如说你仓库名字叫blog，那么域名就会变成 xxx.github.io/blog</p></blockquote><p>打开Hexo的配置文件_config.yml，修改repo为刚创建的仓库地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;YourgithubName&#x2F;YourgithubName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>为了更好的提交代码，我们需要安装一个插件 <code>npm install hexo-deployer-git --save</code></p><p>然后，我们使用<code>hexo d</code>就可以把代码提交到Github仓库了。</p><blockquote><p>等等。。。有人说网上很多文章还说要配置什么ssh秘钥，其实这块我觉得不是必须的，只是为了更方便的提交代码而已，具体步骤这里不再赘述。</p></blockquote><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>Hexo更换主题特别简单，只需要把主题文件夹clone到themes文件里面，然后修改_config.yml里面的 theme 配置项。</p><p>详细的步骤我这里就不解释了，你可以在Github使用 “hexo themes”关键字搜索，然后按照其readme文档说明安装即可，非常简单。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>如果你配置了ssh秘钥，则必须把deploy配置里的repo配置 https 地址改成 ssh 地址。</li><li>很多主题都有一个自己的_config.yml配置文件，里面有一些详细配置，比如是Next这个主题默认没有打开分类和标签项，需自己配置。</li><li>如果想实现“阅读全文”这种效果，有2种方式，第一种是需自己在markdown里合适的位置作注解，默认是 <code>&lt;!--more--&gt;</code>，还有一种在主题的配置里面，可以自动根据字数折叠，但是默认不推荐这种方式。</li><li>每个主题都有很多自定义的配置项，比如样式、字体、评论、浏览数，很多默认都没开启，可以好好看一下，都有注释。</li><li>最重要的一点，所有的东西都是开源的，如果你觉得很多样式或者细节不合适完全可以打开模板修改定制。</li></ol><p>最后，如果你闲麻烦，觉得我的博客还可以，想参考一下可以访问我的<a href="https://github.com/wangbjun/blog_hexo" target="_blank" rel="noopener">Github</a>，所有的文件和配置都在里面，欢迎采用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近想搭建了一个自己的博客网站，经过调研，最终决定使用Hexo+Github的形式搭建，大概花了3个小时的时间，这里简单记录一下过程，备用。&lt;/p&gt;
&lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;Github提供了一个免费的GIthub Pages功能，简单说就是可以让你存放静态的资源文件，比如css、js、html、image，同时会给你分配一个免费域名，格式：&lt;a href=&quot;https://xxx.github.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://xxx.github.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以你只需要注册一个Github账号，然后新建一个repository就行了，一毛线都不用花。&lt;/p&gt;
&lt;p&gt;由于Github Pages只能托管静态资源，所以像WordPress这类博客肯定是无法运行的，这时候你有2种选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;手写静态页面，如果是前端大牛可以尝试这样&lt;/li&gt;
&lt;li&gt;第三方博客工具生成，如Hexo、jekyll&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://wangbjun.site/categories/Linux/"/>
    
    
      <category term="Hexo" scheme="https://wangbjun.site/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>解决Golang测试配置文件加载问题</title>
    <link href="https://wangbjun.site/2019/coding/golang/golang-gin-config.html"/>
    <id>https://wangbjun.site/2019/coding/golang/golang-gin-config.html</id>
    <published>2019-11-19T03:49:25.000Z</published>
    <updated>2020-03-06T17:06:35.058Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写Go的项目，使用的框架是Gin，众所周知，Gin是一个比较简单的框架，只提供了核心功能，并没有配置文件模块，所以这块得自己搞了，Go的第三方解析配置的库非常多，无论是ini、yaml、json文件支持都非常好，而且Go的项目一般都是常驻进程的，所以只需要在项目启动的时候解析一次就行可以了。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>最简单的办法通常就是定义一个全局的配置变量供其它包使用，在init函数里面初始化加载配置文件，示例如下：</p><a id="more"></a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> config</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"gopkg.in/ini.v1"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Conf Config</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    App      App</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> App <span class="keyword">struct</span> &#123;</span><br><span class="line">    Port    <span class="keyword">string</span></span><br><span class="line">    Debug   <span class="keyword">string</span></span><br><span class="line">    Url     <span class="keyword">string</span></span><br><span class="line">    LogFile <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    envFile := <span class="string">"app.ini"</span></span><br><span class="line">    conf, err := ini.Load(envFile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Panicf(<span class="string">"parse conf file [%s] failed, err: %s"</span>, envFile, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    sectionApp := conf.Section(<span class="string">"APP"</span>)</span><br><span class="line">    Conf.App = App&#123;</span><br><span class="line">        Port:    sectionApp.Key(<span class="string">"PORT"</span>).String(),</span><br><span class="line">        Debug:   sectionApp.Key(<span class="string">"DEBUG"</span>).String(),</span><br><span class="line">        Url:     sectionApp.Key(<span class="string">"URL"</span>).String(),</span><br><span class="line">        LogFile: sectionApp.Key(<span class="string">"LOG_FILE"</span>).String(),</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">"init config file success"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，入口文件main.go文件都是位于项目根目录下面，和app.ini文件同级，所以这种写法完全没问题。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>但是当你跑测试用例的时候，而且当这个测试用例并不在项目根目录的时候就会产生问题: 找不到配置文件。</p><p>原因很简单，Go的测试用例最佳实践是和被测试的文件放在一起，所以测试文件可能在二级、三级甚至多级目录里面，如下图：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">├── app.ini</span><br><span class="line">├── config</span><br><span class="line">│   ├── Config.go</span><br><span class="line">│   └── DataBase.go</span><br><span class="line">├── controller</span><br><span class="line">│   ├── BaseController.go</span><br><span class="line">├── lib</span><br><span class="line">│   ├── <span class="keyword">function</span></span><br><span class="line">│   │   ├── Aes.go</span><br><span class="line">│   │   ├── Rsa.go</span><br><span class="line">│   │   ├── Rsa_test.go</span><br><span class="line">│   │   └── Uuid.go</span><br><span class="line">│   ├── httpLogger</span><br><span class="line">│   │   └── HttpLogger.go</span><br><span class="line">│   └── zlog</span><br><span class="line">│       ├── SqlLog.go</span><br><span class="line">│       └── ZapLogger.go</span><br><span class="line">├── main.go</span><br></pre></td></tr></table></figure><p>所以在测试文件的目录下肯定是找不到app.ini的，咋办呢？解决方法有很多</p><ul><li><p>copy一个配置到测试文件。这种方法最简单粗暴，但是太不灵活，测试用例可能在任何目录里面，这样搞有点难受</p></li><li><p>配置文件路径写成绝对路径。这种方法也不灵活，毕竟每个人的项目目录位置不一样，以后线上部署也麻烦</p></li><li><p>采用依赖注入的高级写法，测试的时候使用mock的方式注入配置。这种方法可以，也是比较好的方式，但是需要引入依赖注入组件，整个项目的架构需要更改，不推荐使用依赖注入把简单的问题复杂化。</p></li><li><p>跑测试的时候传入外部参数，依然不够灵活，而且麻烦</p></li></ul><p>这个问题，我思考了很久，最终想了一个足够简单灵活的方式，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">envFile := <span class="string">"app.ini"</span></span><br><span class="line"><span class="comment">// 读取配置文件, 解决跑测试的时候找不到配置文件的问题，最多往上找5层目录</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err := os.Stat(envFile); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        envFile = <span class="string">"../"</span> + envFile</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">conf, err := ini.Load(envFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Panicf(<span class="string">"parse conf file [%s] failed, err: %s"</span>, envFile, err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一个for循环解决了这个问题，如果怕不够保险，可以改成10，大多数项目目录应该不会这么深，虽然不够优雅，但是还是相对比较简单的。</p><p>各位有什么更好的方法吗？有的话请留言指教</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在写Go的项目，使用的框架是Gin，众所周知，Gin是一个比较简单的框架，只提供了核心功能，并没有配置文件模块，所以这块得自己搞了，Go的第三方解析配置的库非常多，无论是ini、yaml、json文件支持都非常好，而且Go的项目一般都是常驻进程的，所以只需要在项目启动的时候解析一次就行可以了。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h2&gt;&lt;p&gt;最简单的办法通常就是定义一个全局的配置变量供其它包使用，在init函数里面初始化加载配置文件，示例如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程开发" scheme="https://wangbjun.site/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.site/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Golang的recover异常处理机制</title>
    <link href="https://wangbjun.site/2019/coding/golang/golang-recover.html"/>
    <id>https://wangbjun.site/2019/coding/golang/golang-recover.html</id>
    <published>2019-11-10T12:22:04.000Z</published>
    <updated>2020-03-06T17:10:14.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-error"><a href="#1-error" class="headerlink" title="1.error"></a>1.error</h2><p>Golang被诟病非常多的一点就是缺少强大方便的异常处理机制，大部分高级编程语言，比如Java、PHP、Python等都拥有一种try catch机制，这种异常捕获机制可以非常方便的处理程序运行中可能出现的各种意外情况。</p><p>严格来说，在Go里面，错误和异常是2种不同的类型，错误一般是指程序产生的逻辑错误，或者意料之中的意外情况，而且异常一般就是panic，比如角标越界、段错误。</p><a id="more"></a><p>对于错误，Golang采用了一种非常原始的手段，我们必须手动处理可能产生的每一个错误，一般会把错误返回给调用方，下面这种写法在Go里面十分常见：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s, err := say()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%s\n"</span>, err.Error())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%s\n"</span>, s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"something error"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法最大的问题就是每一个error都需要判断处理，非常繁琐，如果使用try catch机制，我们就可以统一针对多个函数调用可能产生的错误做处理，节省一点代码和时间。不过咱们今天不是来讨论Go的异常错误处理机制的，这里只是简单说一下。</p><h2 id="2-panic"><a href="#2-panic" class="headerlink" title="2.panic"></a>2.panic</h2><p>一般错误都是显示的，程序明确返回的，而异常往往是隐示的，不可预测的，比如下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, cal(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, cal(<span class="number">5</span>,<span class="number">2</span>))</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, cal(<span class="number">5</span>,<span class="number">0</span>)) <span class="comment">//panic: runtime error: integer divide by zero </span></span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, cal(<span class="number">9</span>,<span class="number">5</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行第三个计算的时候会发生一个panic，这种错误会导致程序退出，下面的代码的就无法执行了。当然你可以说这种错误理论上是可以预测的，我们只要在cal函数内部做好处理就行了。</p><p>然而实际开发中，会发生panic的地方可能特别多，而且不是这种一眼就能看出来的，在Web服务中，这样的panic会导致整个Web服务挂掉，特别危险。</p><h2 id="3-recover"><a href="#3-recover" class="headerlink" title="3.recover"></a>3.recover</h2><p>虽然没有try catch机制，Go其实有一种类似的recover机制，功能弱了点，用法很简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, cal(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, cal(<span class="number">5</span>, <span class="number">2</span>))</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, cal(<span class="number">5</span>, <span class="number">0</span>))</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, cal(<span class="number">9</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%s\n"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，大家得理解defer的作用，简单说defer就类似于面向对象里面的析构函数，在这个函数终止的时候会执行，即使是panic导致的终止。</p><p>所以，在cal函数里面每次终止的时候都会检查有没有异常产生，如果产生了我们可以处理，比如说记录日志，这样程序还可以继续执行下去。</p><h2 id="4-注意的坑"><a href="#4-注意的坑" class="headerlink" title="4.注意的坑"></a>4.注意的坑</h2><p>一般defer recover这种机制经常用在常驻进程的应用，比如Web服务，在Go里面，每一个Web请求都会分配一个goroutine去处理，在没有做任何处理的情况下，假如某一个请求发生了panic，就会导致整个服务挂掉，这是不可接受的，所以在Web应用里面必须使用recover保证即使某一个请求发生错误也不影响其它请求。</p><p>这里我使用一小段代码模拟一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    requests := []<span class="keyword">int</span>&#123;<span class="number">12</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">41</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">31</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> n := <span class="keyword">range</span> requests &#123;</span><br><span class="line">        <span class="keyword">go</span> run(n) <span class="comment">//开启多个协程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//模拟请求错误</span></span><br><span class="line">    <span class="keyword">if</span> num%<span class="number">5</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"请求出错"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码无法完整执行下去，因为其中某一个协程必然会发生panic，从而导致整个应用挂掉，其它协程也停止执行。</p><p>解决方法和上面一样，我们只需要在run函数里面加入defer recover，整个程序就会非常健壮，即使发生panic，也会完整的执行下去。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>();err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%s\n"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">if</span> num%<span class="number">5</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"请求出错"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码只是演示，真正的坑是：如果你在run函数里面又启动了其它协程，这个协程发生的panic是无法被recover的，还是会导致整个进程挂掉,我们改造了一下上面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%s\n"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">if</span> num%<span class="number">5</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"请求出错"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> myPrint(num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myPrint</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> num%<span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"请求又出错了"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在run函数里面又通过协程的方式调用了另一个函数，而这个函数也会发生panic，你会发现整个程序也挂了，即使run函数有recover也没有任何作用，这意味着我们还需要在myPrint函数里面加入recover。但是如果你不使用协程的方式调用myPrint函数，直接调用的话还是可以捕获recover的。</p><p>总结一下就是defer recover这种机制只是针对当前函数和以及直接调用的函数可能产生的panic，它无法处理其调用产生的其它协程的panic，这一点和try catch机制不一样。</p><p>理论上讲，所有使用协程的地方都必须做defer recover处理，这样才能保证你的应用万无一失，不过开发中可以根据实际情况而定，对于一些不可能出错的函数加了还影响性能。</p><p>Go的Web服务也是一样，默认的recover机制只能捕获一层，如果你在这个请求的处理中又使用了其它协程，那么必须非常慎重，毕竟只要发生一个panic，整个Web服务就会挂掉。</p><p>最后，总结一下，Go的异常处理机制虽然没有很多其它语言高效，但是基本上还是能满足需求，目前官方已经在着完善这一点，Go2可能会见到。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-error&quot;&gt;&lt;a href=&quot;#1-error&quot; class=&quot;headerlink&quot; title=&quot;1.error&quot;&gt;&lt;/a&gt;1.error&lt;/h2&gt;&lt;p&gt;Golang被诟病非常多的一点就是缺少强大方便的异常处理机制，大部分高级编程语言，比如Java、PHP、Python等都拥有一种try catch机制，这种异常捕获机制可以非常方便的处理程序运行中可能出现的各种意外情况。&lt;/p&gt;
&lt;p&gt;严格来说，在Go里面，错误和异常是2种不同的类型，错误一般是指程序产生的逻辑错误，或者意料之中的意外情况，而且异常一般就是panic，比如角标越界、段错误。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程开发" scheme="https://wangbjun.site/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.site/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Protobuf入门和实战</title>
    <link href="https://wangbjun.site/2019/coding/golang/golang-protobuf.html"/>
    <id>https://wangbjun.site/2019/coding/golang/golang-protobuf.html</id>
    <published>2019-10-22T09:15:43.000Z</published>
    <updated>2020-03-06T17:08:33.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>Protobuf（Google Protocol Buffer）是 Google公司内部的混合语言数据标准，目前已经开源，支持多种语言（C++、C#、Go、JS、Java、Python、PHP），它是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。</p><p>说简单点，Protobuf就是类似JSON、XML这样的数据交换格式，当今互联网JSON是最流行的格式了，XML用的也挺多，最初接触到Protobuf是因为gRPC默认使用它作为数据编码，相比于JSON和XML，它更小，更快！</p><a id="more"></a><p>举个例子：如果我们想表达一个人名字叫John，年龄是28岁，邮箱是<a href="mailto:jdoe@gmail.com">jdoe@gmail.com</a>这样的结构化数据，并且需要在互联网上传输</p><ul><li><p>使用XML表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;person&gt;</span><br><span class="line">   &lt;name&gt;John&lt;&#x2F;name&gt;</span><br><span class="line">   &lt;age&gt;28&lt;&#x2F;age&gt;</span><br><span class="line">   &lt;email&gt;jdoe@example.com&lt;&#x2F;email&gt;</span><br><span class="line"> &lt;&#x2F;person&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用JSON表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: John,</span><br><span class="line">    age: 28,</span><br><span class="line">    email: jdoe@example.com</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用Protobuf表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message Person &#123;</span><br><span class="line">    string name &#x3D; 1;</span><br><span class="line">    int32 age &#x3D; 2;</span><br><span class="line">    string email &#x3D; 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>从可读性和表达能力上看，XML最好，JSON其次，而Protobuf这个其实只是一个DSL，用来定义数据结构和类型，实际生成的数据是二进制的，不可读，但Protobuf追求的是性能和速度，关于它们之间的对比，后面再说，咱们先说用法。</p><h2 id="2-安装环境"><a href="#2-安装环境" class="headerlink" title="2.安装环境"></a>2.安装环境</h2><p>Protobuf的使用比较麻烦，首先需要安装Protobuf的编译工具(Protocol Buffers compiler)，Ubuntu环境下自带编译环境，其它平台可自行安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jwang@jwang:~$ protoc --version</span><br><span class="line">libprotoc 3.8.0</span><br></pre></td></tr></table></figure><p>然后还需要安装不同语言的运行环境，具体可以参考<a href="https://github.com/protocolbuffers/Protobuf" target="_blank" rel="noopener">github.com/protocolbuffers/Protobuf</a></p><h2 id="3-编写proto文件"><a href="#3-编写proto文件" class="headerlink" title="3.编写proto文件"></a>3.编写proto文件</h2><p>proto其实是一种DSL语法，这个proto文件最终会使用protoc编译成不同语言的文件，然后在程序里面调用，这也是Protobuf跨平台的关键。关于proto文件的语法这里不详细介绍，建议大家参考<a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="noopener">官方文档</a>，东西很多，也很详细。</p><p>我这里拿一个简单实际的例子（person.proto）来说明一下，建议大家使用Goland安装一个插件，这样有颜色还可以检查语法：</p><ul><li>第一行syntax是声明proto语法版本，如果不声明默认是2，建议使用3版本</li><li>然后是package也就包，这个影响到最后生成的go文件的包</li><li>后面message是用来声明一个数据对象，我觉得可以理解为结构体struct，这个数据对象有自己的数据成员，每个字段有类型和默认值。</li><li>proto的数据类型有标量类型和枚举类型，由于不同语言的数据类型不太一样，所以这里的类型和实际语言的类型有一个对应转换关系，具体可以参考官方文档</li><li>repeated 相当于声明一个数组，比如在上面的例子，意思就是car是一个string类型的数组</li><li>message可以嵌套声明，也可以引用一个类型</li><li>最迷惑的东西估计就是后面那个1,2,3,4…了，据官方文档的说法是为了在二进制格式里面标记数据，在每一个message里面必须是唯一的，从最小的1开始，一直可以到2的29次方-1，也就是536870911，但是19000到19999是保留的数字。</li></ul><p>基本语法还是挺简单的，不过有些深入的用法这里没有介绍到，想要了解的话务必查看官方文档，不过定义数据结构和类型只是第一步，接下来我们还要使用protoc把这个文件编译成对应语言的文件。</p><h2 id="4-编译proto文件"><a href="#4-编译proto文件" class="headerlink" title="4.编译proto文件"></a>4.编译proto文件</h2><p>以Go语言为例，建议切换到proto文件目录执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out&#x3D;. person.proto</span><br></pre></td></tr></table></figure><p>其中–go_out表示输出go版本的，其它语言把go替换就行了，比如–php_out、–java_out,=后面是需要输出的目录，我选择.表示当前目录，当然你也可以指定输入和输出目录，最后面则是需要编译的文件，可以指定单个文件，也可以使用通配符同时编译多个文件。</p><p>执行完命令之后，你会发现当前目录多了一个person.pb.go文件，这是一个标准的go语法文件，里面主要是一个结构体和一些getter函数，其它的我也不太懂是什么意思就不说了，但是并不影响我们使用。</p><h2 id="5-使用"><a href="#5-使用" class="headerlink" title="5.使用"></a>5.使用</h2><p>以Go为例，我们需要安装一个<a href="github.com/golang/Protobuf/proto">运行库</a>，其它语言也差不多，官方针对每一个语言都有一个单独的介绍文档，务必查阅一下。</p><p>下面是一个完整的案例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/golang/Protobuf/proto"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//实例化模型对象，填充数据</span></span><br><span class="line">    p := &amp;Person&#123;</span><br><span class="line">        Id:    <span class="number">1</span>,</span><br><span class="line">        Name:  <span class="string">"jun"</span>,</span><br><span class="line">        Age:   <span class="number">25</span>,</span><br><span class="line">        Money: <span class="number">24.5</span>,</span><br><span class="line">        Car:   []<span class="keyword">string</span>&#123;<span class="string">"car1"</span>, <span class="string">"car2"</span>&#125;,</span><br><span class="line">        Phone: &amp;Person_Phone&#123;Number: <span class="string">"0551-12323232"</span>, Type: <span class="string">"1"</span>&#125;,</span><br><span class="line">        Sex:   Person_female,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Marshal序列化</span></span><br><span class="line">    out, err := proto.Marshal(p)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//序列化得到结果是二进制的，是不可读的，所以这里保存到文件</span></span><br><span class="line">    file, _ := os.OpenFile(<span class="string">"out"</span>, os.O_CREATE|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">    _, _ = file.Write(out)</span><br><span class="line">    _ = file.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//unMarshal还原数据，从文件里面读取</span></span><br><span class="line">    in, _ := os.Open(<span class="string">"out"</span>)</span><br><span class="line">    bytes, err := ioutil.ReadAll(in)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    p1 := &amp;Person&#123;&#125;</span><br><span class="line">    err = proto.Unmarshal(bytes, p1)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//调用string()方法打印，也可以使用其生成的getter函数</span></span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, p1.String())</span><br><span class="line">        fmt.Printf(<span class="string">"%d\n"</span>, p1.GetId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-与JSON对比"><a href="#6-与JSON对比" class="headerlink" title="6.与JSON对比"></a>6.与JSON对比</h2><p>由于XML目前很少使用在Web API接口上，所以这里就不对比了，主要看一下和JSON的对比，包含2个方面：速度和大小。</p><p>为了测试，我在proto文件里面又加了一个数据对象，表示一个组里面有多个person对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message Group &#123;</span><br><span class="line">    repeated Person person &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别测试有1,10,100个对象的时候对比情况，测试代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkProto</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    g := &amp;Group&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        p := &amp;Person&#123;</span><br><span class="line">            Id:    <span class="keyword">int32</span>(i),</span><br><span class="line">            Name:  <span class="string">"测试名称"</span>,</span><br><span class="line">            Age:   <span class="keyword">int32</span>(<span class="number">25</span> * i),</span><br><span class="line">            Money: <span class="number">240000.5</span>,</span><br><span class="line">            Car:   []<span class="keyword">string</span>&#123;<span class="string">"car1"</span>, <span class="string">"car2"</span>, <span class="string">"car3"</span>, <span class="string">"car4"</span>, <span class="string">"car5"</span>, <span class="string">"car7"</span>, <span class="string">"car6"</span>, <span class="string">"car21"</span>, <span class="string">"car22"</span>,&#125;,</span><br><span class="line">            Phone: &amp;Person_Phone&#123;Number: <span class="string">"0551-12323232"</span>, Type: <span class="string">"1"</span>&#125;,</span><br><span class="line">            Sex:   Person_female,</span><br><span class="line">        &#125;</span><br><span class="line">        g.Person = <span class="built_in">append</span>(g.Person, p)</span><br><span class="line">    &#125;</span><br><span class="line">    b.ResetTimer()</span><br><span class="line">        b.N = <span class="number">1000</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        out, err := proto.Marshal(g)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g1 := &amp;Group&#123;&#125;</span><br><span class="line">        err = proto.Unmarshal(out, g1)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkJson</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    g := &amp;Group&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        p := &amp;Person&#123;</span><br><span class="line">            Id:    <span class="keyword">int32</span>(i),</span><br><span class="line">            Name:  <span class="string">"测试名称"</span>,</span><br><span class="line">            Age:   <span class="keyword">int32</span>(<span class="number">25</span> * i),</span><br><span class="line">            Money: <span class="number">240000.5</span>,</span><br><span class="line">            Car:   []<span class="keyword">string</span>&#123;<span class="string">"car1"</span>, <span class="string">"car2"</span>, <span class="string">"car3"</span>, <span class="string">"car4"</span>, <span class="string">"car5"</span>, <span class="string">"car7"</span>, <span class="string">"car6"</span>, <span class="string">"car21"</span>, <span class="string">"car22"</span>,&#125;,</span><br><span class="line">            Phone: &amp;Person_Phone&#123;Number: <span class="string">"0551-12323232"</span>, Type: <span class="string">"1"</span>&#125;,</span><br><span class="line">            Sex:   Person_female,</span><br><span class="line">        &#125;</span><br><span class="line">        g.Person = <span class="built_in">append</span>(g.Person, p)</span><br><span class="line">    &#125;</span><br><span class="line">    b.ResetTimer()</span><br><span class="line">        b.N = <span class="number">1000</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        out, err := json.Marshal(g)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g1 := &amp;Group&#123;&#125;</span><br><span class="line">        err = json.Unmarshal(out, g1)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便对比，指定了测试次数为1000次，测试结果如下：</p><p>在1个person的级别：</p><p>可以看出，理论上proto明显比json要快不少，每次操作大概是4-5倍差距。后面在10，100个person的级别的测试中，基本上都是保持在4-5倍性能的差距，这个结果也和网上大部分测试结果一致。</p><p>关于生成的数据大小，这里也简单测试了一遍，还是上面的例子，我使用了10个person，Protobuf生成的文件大小是1030个byte,json生成的文件大小是1842个byte。</p><p>需要注意一点，虽然在大小上Protobuf也领先很多，但是据网上文章介绍，在经过nginx的gzip压缩之后，这2者大小基本上差不多。</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><p>Protobuf作为一种新的数据交换编码方式，虽然使用起来麻烦点，但是在性能和大小上面领先很多，可以用来替换json，使用在一些对性能要求高的场景，比如移动端设备通信。除此之外，目前Protobuf主要用在gRPC用作默认数据编码格式。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.简介&quot;&gt;&lt;/a&gt;1.简介&lt;/h2&gt;&lt;p&gt;Protobuf（Google Protocol Buffer）是 Google公司内部的混合语言数据标准，目前已经开源，支持多种语言（C++、C#、Go、JS、Java、Python、PHP），它是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。&lt;/p&gt;
&lt;p&gt;说简单点，Protobuf就是类似JSON、XML这样的数据交换格式，当今互联网JSON是最流行的格式了，XML用的也挺多，最初接触到Protobuf是因为gRPC默认使用它作为数据编码，相比于JSON和XML，它更小，更快！&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程开发" scheme="https://wangbjun.site/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.site/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>GRPC入门和实践</title>
    <link href="https://wangbjun.site/2019/coding/golang/golang-grpc.html"/>
    <id>https://wangbjun.site/2019/coding/golang/golang-grpc.html</id>
    <published>2019-08-28T15:15:43.000Z</published>
    <updated>2020-03-06T17:06:35.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gPRC"><a href="#gPRC" class="headerlink" title="gPRC"></a>gPRC</h1><p>首先，先阐述一个误区，很多人以为gRPC只能go语言使用，以为这个g代表的就是go，其实并不是，这个g应该理解成Google，这个rpc框架是Google出品，不过Go对这个框架的支持确实非常好，看一下官网的介绍：</p><blockquote><p>gRPC is a modern open source high performance RPC framework that can run in any environment. It can efficiently connect services in and across data centers with pluggable support for load balancing, tracing, health checking and authentication. It is also applicable in last mile of distributed computing to connect devices, mobile applications and browsers to backend services.</p></blockquote><p>详细的介绍可以参考<a href="https://grpc.io" target="_blank" rel="noopener">官网</a>（grpc.io）,简单说，gRPC是一个开源的高性能rpc框架。</p><p>说到rpc，很多搞微服务的都喜欢用，特别是Java领域，rpc全称 Remote Procedure Call，翻译过来叫远程过程调用，这个翻译并不是特别好理解。</p><a id="more"></a><p>举个例子，假设你写了一个算法，非常牛逼，你想把这个算法给别人用，你会咋办？</p><p>首先，得确定这个调用方在哪里？如果这个调用方都在一个项目里面，那我们只需要写个函数，告诉别人函数名字就行了:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lib</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"something very NB"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是现实是，这个调用方不是同一个项目的，代码不在一起，是其它项目需要用，咋办呢？</p><p>有人说，把代码copy给别人，比较low，而且有时候代码要保密。</p><p>有人说，使用http服务，写个接口出来，扔一个API文档，这个方案完全可以，但是不是今天的主角。</p><p>或许，我们也可以使用rpc通信。</p><h2 id="Golang-RPC"><a href="#Golang-RPC" class="headerlink" title="Golang RPC"></a>Golang RPC</h2><p>不少语言都有自己的rpc框架，比如PHP有phprpc和yar，但是这些rpc框架局限在这个语言，无法做到跨语言之间的调用，而Go也是类似，Go标准库自带的rpc有好几种，默认采用Gob编码，只能在Go语言之间使用,还有一种jsonrpc，采用的是json编码，如果你需要跨语言的话，最好采用gRPC。</p><p>Go RPC的函数只有符合下面的条件才能被远程访问：</p><ul><li>函数必须是导出的(首字母大写)</li><li>必须有两个参数，并且是导出类型或者内建类型</li><li>第二个参数必须是指针类型的</li><li>函数还要有一个返回值 error</li></ul><p>下面看一个简单例子：</p><h3 id="入参出参"><a href="#入参出参" class="headerlink" title="入参出参"></a>入参出参</h3><p>我们首先单独定义了需要被远程调用的方法，以及方法的入参和出参，后面的服务端和客户端都会用到：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> golang_rpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"log"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Add <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Add)</span> <span class="title">Plus</span><span class="params">(request Request, response *Response)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    response.Result = request.A + request.B</span><br><span class="line">    log.Printf(<span class="string">"Add...%d + %d"</span>, request.A, request.B)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">    A <span class="keyword">int</span></span><br><span class="line">    B <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Response <span class="keyword">struct</span> &#123;</span><br><span class="line">    Result <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h3><p>这里使用的http协议，其实还有一种tcp的用法，主要作用是注册rpc服务，开启服务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    . <span class="string">"gRPC/golang-rpc"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"net/rpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    add := <span class="built_in">new</span>(Add)</span><br><span class="line">    _ = rpc.Register(add)</span><br><span class="line">    rpc.HandleHTTP()</span><br><span class="line">    log.Println(<span class="string">"rpc server started at port 8888"</span>)</span><br><span class="line">    <span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":8888"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h3><p>客户端根据定义的入参结构体拼装好请求参数，调用rpc</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    . <span class="string">"gRPC/golang-rpc"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/rpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    dial, err := rpc.DialHTTP(<span class="string">"tcp"</span>, <span class="string">":8888"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    args := Request&#123;</span><br><span class="line">        A: <span class="number">1</span>,</span><br><span class="line">        B: <span class="number">2</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> response = Response&#123;&#125;</span><br><span class="line">    err = dial.Call(<span class="string">"Add.Plus"</span>, args, &amp;response)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"a = %d, b= %d, result = %d"</span>, args.A, args.B, response.Result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这只是展示了Go rpc的一种用法，Go rpc的除了支持tcp之外，还可以使用json，也就是jsonrpc，其编码方式是使用json而不是默认的Gob。</p><h2 id="RPC-vs-HTTP"><a href="#RPC-vs-HTTP" class="headerlink" title="RPC vs HTTP"></a>RPC vs HTTP</h2><p>我所参与项目大部分都是基于http，很少使用rpc，原因之一就是因为http特别成熟，文本协议，简单易用，支持广泛，而且其它支持比如负载均衡，流量控制都非常好用。</p><p>本质上，这个2种通信方式都可以实现远程过程调用，也就说把数据从一个地方传输到另一个地方（经过处理再返回回来）。当然也有人说http也是rpc的一种实现形式，这些概念性的东西这里就不争论了。</p><p>但是rpc确实有一些优点，其中最主要的就是传输效率高，因为http是文本协议，而rpc数据协议往往是二进制。</p><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><p>gRPC相比于其它rpc语言，目前发展迅速，不仅仅支持多语言（Go、Java、Python、JS），目前也支持Web端，意味着可以在某种程度上替代http了。</p><p>先不过多介绍太多理论的东西，这里先结合实际代码来看，默认情况下，gRPC使用Protobuf作为 Interface Definition Language（IDL），所谓IDL就是接口定义语言，说的通俗点就是描述这个服务的结构包括请求参数和响应结果。</p><p>这里说到的Protobuf又是什么东西呢？</p><blockquote><p>Protobuf(Google Protocol Buffers)是Google提供一个具有高效的协议数据交换格式工具库(类似Json)，但相比于Json，Protobuf有更高的转化效率，时间效率和空间效率都是JSON的3-5倍。</p></blockquote><p>下面，咱们先看一个demo，先写个helloWorld，gRPC的写法比起http服务确实复杂很多，我们不仅仅要写server端，还要写client端，而http服务的client端一般都有现成的工具（浏览器、curl），但gRPC的client必须是一对一定制化的，需根据IDL生成。</p><ol><li>Go的运行环境咱就不说了，目前gRPC要求Go版本在1.6以上</li><li>安装gRPC: go get -u google.golang.org/grpc</li><li>安装Protobuf v3 compiler，我的Ubuntu系统是自带这个，如果不带的话可以使用apt安装，其它系统可以参考<a href="https://github.com/protocolbuffers/Protobuf" target="_blank" rel="noopener">github</a></li><li>安装go的Protobuf插件： go get -u github.com/golang/Protobuf/protoc-gen-go</li></ol><p>这个IDL文件并不是Go的语法，只是Protobuf的描述语法，大概的意思相信大部分都能看懂，service 是用来定义服务，然后还定义了请求和响应的参数类型，详细的用法可以参考Protobuf的<a href="https://developers.google.com/protocol-buffers/docs/proto3#simple" target="_blank" rel="noopener">官方文档</a>。</p><p>项目的整理结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├── client</span><br><span class="line">│   └── client.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── proto</span><br><span class="line">│   ├── hello.pb.go</span><br><span class="line">│   └── hello.proto</span><br><span class="line">└── server.go</span><br></pre></td></tr></table></figure><p>切换到终端，在proto目录下执行<code>protoc --go_out=plugins=grpc:. *.proto</code>命令生成一个pb.go文件，这是一个go语法的文件，里面的东西非常多，我们真正用到的就是这个。</p><p>下面完成server端的开发：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    pb <span class="string">"gRPC/proto"</span></span><br><span class="line">    <span class="string">"google.golang.org/grpc"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *HelloService)</span> <span class="title">Hello</span><span class="params">(ctx context.Context, r *pb.HelloRequest)</span> <span class="params">(*pb.HelloResponse, error)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"new request..."</span>)</span><br><span class="line">    <span class="keyword">return</span> &amp;pb.HelloResponse&#123;Response: r.GetRequest() + <span class="string">" Server"</span>&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PORT = <span class="string">"8080"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    server := grpc.NewServer()</span><br><span class="line">    pb.RegisterHelloServiceServer(server, &amp;HelloService&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    listen, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":"</span>+PORT)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"net.Listen err: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    _ = server.Serve(listen)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>server端的主要作用是实现服务定义的接口，然后把服务注册到rpc server里面，最后启动服务等待请求的到来，和http服务有点类似。</p><p>虽然服务启动了，但是这时候无法像像http一样使用浏览器或者其它工具去访问，我们必须使用特定的客户端来访问服务，下面是客户端的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">    pb <span class="string">"gRPC/proto"</span></span><br><span class="line">    <span class="string">"google.golang.org/grpc"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PORT = <span class="string">"8080"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn, err := grpc.Dial(<span class="string">":"</span>+PORT, grpc.WithInsecure())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"grpc.Dial err: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">    client := pb.NewHelloServiceClient(conn)</span><br><span class="line">    resp, err := client.Hello(context.Background(), &amp;pb.HelloRequest&#123;</span><br><span class="line">        Request: <span class="string">"Hello gRPC"</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"client.Search err: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">"resp: %s"</span>, resp.GetResponse())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，先启动server，然后运行client。</p><p>有人可能会说，废了这么大劲，到最后结果和http服务有啥区别？我使用http服务分分钟钟搞定的事情，gRPC还需要定义这个那个…但是gRPC的功能不止这些。</p><h2 id="流式请求"><a href="#流式请求" class="headerlink" title="流式请求"></a>流式请求</h2><p>上面的demo只是一个simple模型，类似于http的request和response模型，但是gRPC还支持流式请求，其交互模型包括：</p><ol><li>服务端流。客户端发出一个请求，服务端返回一个响应流</li><li>客户端流。客户端发出一个请求流，服务端返回一个响应</li><li>双向流。客户端和服务端可以互相通信，类似websocket一样</li></ol><p>具体的应用场景可以结合业务需求来定，这里demo就不展示了，官方有非常详细的example，其实大部分时候还是使用simple模型比较多。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>目前gRPC已经支持移动端和Web，如果拿来替代http也可行，但是http很容易调试和测试，而gRPC则很难，而且http的通用性更广泛，如果是对外提供的公开API，非http莫属。</p><p>目前来说gPRC比较适合用在一些对性能要求高而且比较稳定的场景，比如项目内部微服务之间的通信，这也是大多数rpc框架的主要应用场景。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;gPRC&quot;&gt;&lt;a href=&quot;#gPRC&quot; class=&quot;headerlink&quot; title=&quot;gPRC&quot;&gt;&lt;/a&gt;gPRC&lt;/h1&gt;&lt;p&gt;首先，先阐述一个误区，很多人以为gRPC只能go语言使用，以为这个g代表的就是go，其实并不是，这个g应该理解成Google，这个rpc框架是Google出品，不过Go对这个框架的支持确实非常好，看一下官网的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;gRPC is a modern open source high performance RPC framework that can run in any environment. It can efficiently connect services in and across data centers with pluggable support for load balancing, tracing, health checking and authentication. It is also applicable in last mile of distributed computing to connect devices, mobile applications and browsers to backend services.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;详细的介绍可以参考&lt;a href=&quot;https://grpc.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;（grpc.io）,简单说，gRPC是一个开源的高性能rpc框架。&lt;/p&gt;
&lt;p&gt;说到rpc，很多搞微服务的都喜欢用，特别是Java领域，rpc全称 Remote Procedure Call，翻译过来叫远程过程调用，这个翻译并不是特别好理解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程开发" scheme="https://wangbjun.site/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Grpc" scheme="https://wangbjun.site/tags/Grpc/"/>
    
  </entry>
  
  <entry>
    <title>短网址原理和实现</title>
    <link href="https://wangbjun.site/2019/coding/short-url.html"/>
    <id>https://wangbjun.site/2019/coding/short-url.html</id>
    <published>2019-07-09T11:02:46.000Z</published>
    <updated>2020-03-05T14:52:28.803Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1.背景介绍"></a>1.背景介绍</h2><p>相信很多人手机上都收到过一些营销短信，短信里面有时候会附带一些网址，如下图<br><img src="https://wangbjun.github.io/images/old/16ada545111ae94d.jpg" alt=""><br>这些网址往往都是非常短，但是当我们打开之后，如果你仔细观察，中间会有跳转，最终浏览器地址栏显示的网址并不是你短信里面看到的网址，这就是短网址！</p><a id="more"></a><h2 id="2-原理和应用"><a href="#2-原理和应用" class="headerlink" title="2.原理和应用"></a>2.原理和应用</h2><p>短网址一般是采用一个非常短域名下，路径参数一般只有3-6个字符组成，非常简洁！</p><p>使用短网址的前提是先生成短网址，主要是采用某种算法让一段短的字符对应一个长的字符，比如说从常用的0-9、a-z、A-Z共62个字符中选择6个字符，那意味着有62的6次方种组合，大概有568亿不重复的短网址可用！</p><p>服务器通过路径参数查询到真实的长网址，然后使用301/302跳转到真实的网址即可！</p><p>关于跳转，301 是永久重定向，302 是临时重定向。短地址一经生成就不会变化，所以用 301 是符合 http 语义的，浏览器会记录跳转地址，同时对服务器压力也会有一定减少。但是如果使用了 301，我们就无法统计到短地址被点击的次数了，如果对数据统计有要求的话，使用302跳转可能比较好一些！</p><p>短网址的主要好处是方便传输记忆，特别是在短信里面使用的时候，短信对内容字数有限制，还有比如说微博分享也使用了短网址！</p><h2 id="3-市面现有案例"><a href="#3-市面现有案例" class="headerlink" title="3.市面现有案例"></a>3.市面现有案例</h2><p>目前市面上有很多免费的短链接服务，功能基本上都一样，也没有什么限制！</p><p>(1)百度的短链接(<a href="https://dwz.cn/)，百度不仅仅提供了网页入口，也提供了接口和开发文档，简单易用！" target="_blank" rel="noopener">https://dwz.cn/)，百度不仅仅提供了网页入口，也提供了接口和开发文档，简单易用！</a></p><p>(2)新浪的短链接(<a href="https://sina.lt/)，目前仅提供网页入口，未发现接口服务！" target="_blank" rel="noopener">https://sina.lt/)，目前仅提供网页入口，未发现接口服务！</a></p><p>(3)淘宝的短链接(<a href="https://tb.am/)，目前仅提供网页入口，未发现接口服务！" target="_blank" rel="noopener">https://tb.am/)，目前仅提供网页入口，未发现接口服务！</a></p><p>市面还有很多其它的小的公司提供短链接服务，有些是部分免费，有些短链接是有效期的，这里不一一介绍！</p><h2 id="4-常用算法"><a href="#4-常用算法" class="headerlink" title="4.常用算法"></a>4.常用算法</h2><p>网上比较流行的算法有进制算法、摘要（Hash）算法、随机数算法，下面简单介绍一下：</p><h3 id="一-进制算法"><a href="#一-进制算法" class="headerlink" title="一.进制算法"></a>一.进制算法</h3><p>这个算法网上也有叫作自增序列算法，特点就是永不重复，设置 id 自增，一个 10进制 id 对应一个62进制的数值，1对1，也就不会出现重复的情况，这个利用的就是低进制转化为高进制时，字符数会减少的特性。</p><p>计算机中常见的进制有2进制，8进制，10进制，16进制，进制越大，能够表示的数越大，占用的字数也越少。下面举个例：</p><p>10进制的1000，在8进制里面是1750，在16进制里面就是3E8，那在62进制里面呢？有人说，计算机里面没有62进制。。。虽然没有，但是我们可以造一个，进制的转换算法是固定的，最常见的就是“除基取余法”！</p><p>我们假设62进制的字符序列为 0-9a-zA-Z，顺序可以打乱，但是应该固定下来，是一个从0角标开始的到61的数组，我们暂且称之为字母表！</p><p>====&gt; 1000/62 = 16，余8</p><p>====&gt; 16/62 = 0，余16</p><p>余数得到的数字是16、8，然后找到字母表里面角标为16和8的字符拼起来，就是g8，非常短，只有2位数！假如说我们想至少产生6位字符，那么我们可以从一个比较大的数字开始，具体可以看下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1位620 - 61</span><br><span class="line">2位384462 - 3843</span><br><span class="line">3位约 23万3844 - 238327</span><br><span class="line">4位约 1400万238328 - 14776335</span><br><span class="line">5位约 9.1亿14776336 - 916132831</span><br><span class="line">6位约 568亿916132832 - 56800235583</span><br></pre></td></tr></table></figure><h3 id="二-Hash算法"><a href="#二-Hash算法" class="headerlink" title="二.Hash算法"></a>二.Hash算法</h3><h4 id="第一种方式："><a href="#第一种方式：" class="headerlink" title="第一种方式："></a>第一种方式：</h4><p>简单的对长链接进行加盐md5，会生成一个32位的字符串，随机从里面取6个字符，或者简单粗暴取最后6位，但是md5只包含0-9A-Fa-f,比字母表的里面字符还少，冲突几率更大！</p><h4 id="第二种方式："><a href="#第二种方式：" class="headerlink" title="第二种方式："></a>第二种方式：</h4><p>1.将长网址 md5 生成 32 位签名串,分为 4 段, 每段 8 个字节</p><p>2.对这四段循环处理, 取 8 个字节, 将他看成 16 进制串与 0x3fffffff(30位1) 与操作, 即超过 30 位的忽略处理</p><p>3.这 30 位分成 6 段, 每 5 位的数字作为字母表的索引取得特定字符, 依次进行获得 6 位字符串</p><p>4.总的 md5 串可以获得 4 个 6 位串,取里面的任意一个就可作为这个长 url 的短 url 地址</p><p>生成的方式更加复杂，重复的几率低，但是依然会出现冲突！</p><h3 id="三-随机数算法"><a href="#三-随机数算法" class="headerlink" title="三.随机数算法"></a>三.随机数算法</h3><p>这个更简单，直接对这个62个字符数组做随机选择，选择其中6个字符当作短链接码，简单易用，但是难免会出现重复冲突！</p><h3 id="四-算法对比"><a href="#四-算法对比" class="headerlink" title="四.算法对比"></a>四.算法对比</h3><p>第一种算法只要解决自增id问题就可以避免冲突，自增id可以采用数据库自增主键，每次生成短码只需一次数据库操作（insert操作，获取主键id，然后算出短码即可）</p><p>第二种和第三种算法其实都差不多，都是依赖于程序随机，容易出现冲突，这就需要每次在插入数据库的时候判重，效率低一些！</p><h2 id="5-安全"><a href="#5-安全" class="headerlink" title="5.安全"></a>5.安全</h2><p>短链接虽然方便了传输和记忆，但是由于链接组成的字符个数少，更容易被爆破、猜测攻击，攻击者可以轻松遍历所有字符组成的链接！</p><p>所以不建议使用短链接发送具有私密性的网址，比如说重置密码链接，对一些权限、敏感信息的链接要做好二次鉴权！</p><p>最后，推荐一个使用golang写的短网址项目，可以作为一个单独服务部署使用: <a href="https://github.com/praglody/shorturl" target="_blank" rel="noopener">https://github.com/praglody/shorturl</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-背景介绍&quot;&gt;&lt;a href=&quot;#1-背景介绍&quot; class=&quot;headerlink&quot; title=&quot;1.背景介绍&quot;&gt;&lt;/a&gt;1.背景介绍&lt;/h2&gt;&lt;p&gt;相信很多人手机上都收到过一些营销短信，短信里面有时候会附带一些网址，如下图&lt;br&gt;&lt;img src=&quot;https://wangbjun.github.io/images/old/16ada545111ae94d.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;这些网址往往都是非常短，但是当我们打开之后，如果你仔细观察，中间会有跳转，最终浏览器地址栏显示的网址并不是你短信里面看到的网址，这就是短网址！&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程开发" scheme="https://wangbjun.site/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="短网址" scheme="https://wangbjun.site/tags/%E7%9F%AD%E7%BD%91%E5%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 下nvidia显卡驱动安装</title>
    <link href="https://wangbjun.site/2019/linux/ubuntu-nvidia-dirver.html"/>
    <id>https://wangbjun.site/2019/linux/ubuntu-nvidia-dirver.html</id>
    <published>2019-07-01T04:11:09.000Z</published>
    <updated>2020-03-05T14:54:49.221Z</updated>
    
    <content type="html"><![CDATA[<p>Linux下面的显卡驱动一直是个麻烦事，主要是独立显卡，特别是（NVIDIA）英伟达的显卡，气的当年祖师爷怒竖中指，虽然很多年过去了，情况有所改变，但也不是特别好！</p><h2 id="集成显卡"><a href="#集成显卡" class="headerlink" title="集成显卡"></a>集成显卡</h2><p>如果你在Linux下面不打游戏，也不搞深度学习，强烈建议你卸载独立显卡已提高性能，当然前提是你使用的intel带集显CPU，大部分intel自带集显的性能已经能满足了</p><p>Intel对Linux支持很好，所以Linux下面的intel集显驱动非常好，内核自带，不需要额外安装，流畅度也挺高，1080p下面60fps不是问题，但是如果你使用4k显示器，intel集显大部分都是带不动。</p><a id="more"></a><p>至于AMD的APU驱动，本人并没有试过，这里不作任何发言！</p><h2 id="独立显卡"><a href="#独立显卡" class="headerlink" title="独立显卡"></a>独立显卡</h2><p>如果你使用了一台4k显示器，大部分情况下你需要一个独立显卡，因为集显的话只有部分intel高端CPU和高端主板才能达到4k+60fps的情况（dp线），但是使用独显的话就很容易达到，毕竟集显免费送，独显可是要花钱买的。</p><p>虽然Linux自带了一个开源的 nouveau 驱动，但是性能真的堪忧，拿来带4k是不行的，必须安装独显驱动。</p><p>现在市场上大部分都是NVIDIA的显卡，我本人使用的也是N卡，至于A卡的情况这里也不作发言，下面说的只针对NVIDIA卡。</p><h2 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h2><p>虽然NVIDIA官网提供了最新Linux驱动的下载选项，但是本人并不建议大家尝试手动安装，因为非常麻烦，而且不同发行版不同版本之间可能存在兼容性问题。</p><p>不过这里还是简单说下步骤：</p><ol><li>下载安装文件，增加可执行权限，打开英伟达官网，在驱动下载页面可以下载最新的Linux驱动。</li><li>屏蔽nouveau驱动，编辑 /etc/modprobe.d/blacklist.conf 文件，在文件末尾加入一行 blacklist nouveau，然后使用 sudo update-initramfs -u 更新内核文件，成功后重启！</li><li>关闭x-server，在Ubuntu下面可以使用 service lightdm stop 命令</li><li>进入终端，执行安装文件，根据指示依次进行，这个脚本会做一些检测，如果检测到你没有屏蔽nouveau驱动会提示你，然后你可以选择自动创建，之后重启电脑，返回第3步</li><li>如果一切顺利的话，应该可以安装成功，但是往往没这么简单，比如会出现gcc版本不对的问题，还有一些第三方依赖问题，甚至卡死问题。<br>所以，我这里并不建议大家自己手动安装！！！</li></ol><h2 id="自动安装"><a href="#自动安装" class="headerlink" title="自动安装"></a>自动安装</h2><p>不同Linux发行版安装显卡驱动略有差异，有不少发行版都提供了一个比较简单的安装方式，比如Ubuntu在附加驱动里面就可以安装驱动。<br><img src="/images/old/7645cd7fcf2d40079e5aa87cb7d2c6ba.jpeg" /></p><p>在附加驱动里面我们可以选择需要安装的驱动，在这里列出的基本上都不会有问题，安装完成之后重启即可，默认情况下会自动启用独显！英伟达的显卡会有一个驱动设置面板，可以做一些简单设置。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>正常情况下，安装显卡驱动还是非常简单的，特别是在Ubuntu下面，鼠标点点就行了，然而现实往往没有这么简单，可能会遇到很多意外，下面我就说说常见的问题：</p><h3 id="1-卡登录"><a href="#1-卡登录" class="headerlink" title="1.卡登录"></a>1.卡登录</h3><p>安装完显卡驱动之后，登录的时候输入密码点击确认之后会返回登录页面，无法进入桌面，循环登录，也就是卡登录，通常这情况都是由于驱动不兼容或者设置不正确导致。</p><p>不过不要慌，卸载掉驱动就行了，虽然无法进入图形桌面，我们可以使用 <code>Alt+F1-F5</code>进入命令行，然后登录后，使用命令行下载NVIDIA驱动，<code>sudo apt purge nvidia*</code></p><p>卸载掉驱动后，重启就可以进入桌面了，然后可以尝试安装其它版本的驱动。</p><h3 id="2-卡死机"><a href="#2-卡死机" class="headerlink" title="2.卡死机"></a>2.卡死机</h3><p>表现就是在安装驱动的过程中，卡在哪里，鼠标键盘无响应，这种情况下基本上是内核卡死了，你等多久都没用。</p><p>一般是因为主板某些设置，比如安全启动，建议关闭安全启动，也就是secure boot</p><p>还有可能是因为内存原因，我之前就是因为主板上面插了4根8G内存条，但是有2根是2400MHz，有2根是2666MHz，基频不一致。</p><p>还有比如说CPU超频了，经过我测试，Linux对CPU超频的兼容性不好，如果超频可能会导致死机，不建议大幅度超频！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux下面的显卡驱动一直是个麻烦事，主要是独立显卡，特别是（NVIDIA）英伟达的显卡，气的当年祖师爷怒竖中指，虽然很多年过去了，情况有所改变，但也不是特别好！&lt;/p&gt;
&lt;h2 id=&quot;集成显卡&quot;&gt;&lt;a href=&quot;#集成显卡&quot; class=&quot;headerlink&quot; title=&quot;集成显卡&quot;&gt;&lt;/a&gt;集成显卡&lt;/h2&gt;&lt;p&gt;如果你在Linux下面不打游戏，也不搞深度学习，强烈建议你卸载独立显卡已提高性能，当然前提是你使用的intel带集显CPU，大部分intel自带集显的性能已经能满足了&lt;/p&gt;
&lt;p&gt;Intel对Linux支持很好，所以Linux下面的intel集显驱动非常好，内核自带，不需要额外安装，流畅度也挺高，1080p下面60fps不是问题，但是如果你使用4k显示器，intel集显大部分都是带不动。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://wangbjun.site/categories/Linux/"/>
    
    
      <category term="Ubuntu" scheme="https://wangbjun.site/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Golang的常用数据结构</title>
    <link href="https://wangbjun.site/2019/coding/golang/golang-datastruct.html"/>
    <id>https://wangbjun.site/2019/coding/golang/golang-datastruct.html</id>
    <published>2019-06-19T13:00:33.000Z</published>
    <updated>2020-03-06T17:03:36.689Z</updated>
    
    <content type="html"><![CDATA[<p>闲着无事，随便写写，初学Go，望各位大神轻喷！Go自带的几个复合数据类型，基本数据类型咱就不说了，大部分语言常见的几种复合数据类型大概有数组、字典、对象等，不同语言叫法不一样，用法也有差异，比如说PHP里面数组其实严格来说不算数组。</p><a id="more"></a><h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h2><p>Go里面的数组和C类似，是由<strong>有序</strong>的<strong>固定长度</strong>的<strong>特定类型</strong>元素组成。画重点，固定长度和特定类型。在很多弱类型的语言里面，数组非常随意，PHP的数组本质上是一个hash table，和C的数组差异太大，所以写惯了PHP再写Go的话这点需要注意。</p><h3 id="基础用法1"><a href="#基础用法1" class="headerlink" title="基础用法1:"></a>基础用法1:</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> b [<span class="number">10</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    b[<span class="number">0</span>] = <span class="string">"a1"</span></span><br><span class="line">    b[<span class="number">1</span>] = <span class="string">"b2"</span></span><br><span class="line">    b[<span class="number">2</span>] = <span class="string">"c5"</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, a)</span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, b)</span><br><span class="line">&#125;</span><br><span class="line">---结果---</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[a1 b2 c5       ]</span><br></pre></td></tr></table></figure><p>从语法上看，Go定义数组的类型放在后面，这点写惯C系语言的估计蛋疼。数组也是通过索引下标访问，如果不初始化赋值的话，默认情况下，int类型的元素是0,string类型是空字符串。</p><h3 id="基础用法2"><a href="#基础用法2" class="headerlink" title="基础用法2"></a>基础用法2</h3><p>我们也可以不先定义，直接使用字面量初始化数组：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%v"</span>, a)</span><br><span class="line">&#125;</span><br><span class="line">---结果---</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">7</span>]</span><br></pre></td></tr></table></figure><p>在这种情况下，我们可以省略长度,使用3个点代替，编译器会自动判断。</p><h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><p>主要有两种方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">        fmt.Print(a[i])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">        fmt.Print(k, <span class="string">"-&gt;"</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果知道长度的话可以使用for循环，否则可以使用for range 这种语法。</p><h3 id="数组函数"><a href="#数组函数" class="headerlink" title="数组函数"></a>数组函数</h3><p>Go内置了一些函数可以操作数组，如果你使用了IDE的话，可以“点”出来：</p><img src = "/images/old/5f6e3e27ly1fzgltdja32j20g4054wen.jpg" /><p>然而，append并不是用来操作数组的，其实它是用来操作变长数组的，即slice, 又称切片。</p><h2 id="2-Slice（切片）"><a href="#2-Slice（切片）" class="headerlink" title="2.Slice（切片）"></a>2.Slice（切片）</h2><p>传统的数组长度固定，所以实际用途并不多，除非你明确知道自己想要多长的数组，很多时候我们需要的是一个可以改变长度大小的数组，在Go里面这类型被称为切片。</p><p>slice其实是从数组而来的，它和数组非常像，区别就在于slice没有固定长度，非常方便，所以平时一般都是用这个比较多。</p><h3 id="基础用法1-1"><a href="#基础用法1-1" class="headerlink" title="基础用法1:"></a>基础用法1:</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    a = <span class="built_in">append</span>(a, <span class="number">2</span>)</span><br><span class="line">    a = <span class="built_in">append</span>(a, <span class="number">1</span>)</span><br><span class="line">    a = <span class="built_in">append</span>(a, <span class="number">4</span>)</span><br><span class="line">    a = <span class="built_in">append</span>(a, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%v"</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区别就在于slice在定义的时候不需要指定长度，也不用3个点，但是这就意味着你不能使用索引下标的方法去赋值了，可以使用append函数去追加元素。</p><p>而且在使用slice的也需要注意下标，如果大于slice的长度也会出现 <code>panic: runtime error: index out of range</code>。</p><h3 id="基础用法2-1"><a href="#基础用法2-1" class="headerlink" title="基础用法2"></a>基础用法2</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;</span><br><span class="line"></span><br><span class="line">    s1 := a[<span class="number">0</span>:]</span><br><span class="line"></span><br><span class="line">    s2 := a[<span class="number">1</span>:<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">    s3 := a[<span class="number">4</span>:<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, a)</span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, s1)</span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, s2)</span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, s3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>slice可以使用<code>[start:end]</code>这种语法从一个数组里面生成，比如<code>a[1:5]</code>意思是生成一个包含数组索引1到5的之间元素的slice。</p><blockquote><p>在Go里面不同长度但是同一类型的数组是不同类型的，比如你定义了2个int数组，一个长度为5，一个长度为10，他们其实并不是同一个类型，虽然都是int类型。cannot use a (type [10]int) as type [5]int in argument</p></blockquote><p>所以在大部分时候我们需要的是一个slice，并不是一个数组。虽然这个2个用法基本上一毛一样。。。</p><h2 id="3-Map"><a href="#3-Map" class="headerlink" title="3.Map"></a>3.Map</h2><p>在很多语言里面，map被叫作字典，这个中文名称很亲切，字典就是一种key value结构，小时候大家都用过新华字典，字典的特征就是每一个字都对应一个解释。但是Go的map是无序的，这点大家需要注意。如果有童鞋写过PHP，会发现这个数据类型类似PHP里面的关联数组。</p><p>在Go里面，它和slice的区别就是slice的索引是数值，map的索引类型就丰富了，基本上常用数据类型都支持，甚至包括结构体。</p><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><p>和其它数组类型一样，map也支持先定义后赋值，或者直接使用字面量创建。但是如果使用先定义后赋值这种方式，map需要使用make初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    m1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">    m1[<span class="string">"name"</span>] = <span class="string">"Golang"</span></span><br><span class="line">    m1[<span class="string">"address"</span>] = <span class="string">"BeiJin"</span></span><br><span class="line"></span><br><span class="line">    m2 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"GoLand"</span>,</span><br><span class="line">        <span class="string">"addr"</span>: <span class="string">"ShangHai"</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, m1)</span><br><span class="line">    fmt.Printf(<span class="string">"%v"</span>, m2)</span><br><span class="line">&#125;</span><br><span class="line">---结果---</span><br><span class="line"><span class="keyword">map</span>[name:Golang address:BeiJin]</span><br><span class="line"><span class="keyword">map</span>[name:GoLand addr:ShangHai]</span><br></pre></td></tr></table></figure><p>map可以使用for range 语法遍历，但是需要注意的是每次遍历的顺序是无序的。</p><p>如何判断一个key是否存在map里面？在PHP里面我们有一个array_key_exists函数，在Go里面写法略有不同：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age, ok := m1[<span class="string">"age"</span>]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">"age 不存在"</span>, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实如果你不判断是否存在直接取也可以，并不会报错，只不过获取到的值是一个对应类型的零值。</p><h2 id="4-结构体"><a href="#4-结构体" class="headerlink" title="4.结构体"></a>4.结构体</h2><p>Go的结构体也类似C，类似于现在很多面向对象的语言里面的类，往往用来存储一组相关联的数据，Go虽然不是一个完全面向对象的语言，但是使用结构体可以实现类似效果。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Goods <span class="keyword">struct</span> &#123;</span><br><span class="line">    name    <span class="keyword">string</span></span><br><span class="line">    price   <span class="keyword">int</span></span><br><span class="line">    pic     <span class="keyword">string</span></span><br><span class="line">    address <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> goods Goods</span><br><span class="line">    goods.name = <span class="string">"商品1"</span></span><br><span class="line">    goods.price = <span class="number">100</span></span><br><span class="line">    goods.pic = <span class="string">"http://xxxx.jpg"</span></span><br><span class="line">    goods.address = <span class="string">"中国"</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, goods)</span><br><span class="line"></span><br><span class="line">    goods2 := Goods&#123;</span><br><span class="line">        name:    <span class="string">"商品2"</span>,</span><br><span class="line">        price:   <span class="number">200</span>,</span><br><span class="line">        pic:     <span class="string">"http://xxxx.png"</span>,</span><br><span class="line">        address: <span class="string">"日本"</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%v"</span>, goods2)</span><br><span class="line">&#125;</span><br><span class="line">---结果---</span><br><span class="line">&#123;商品<span class="number">1</span> <span class="number">100</span> http:<span class="comment">//xxxx.jpg 中国&#125;</span></span><br><span class="line">&#123;商品<span class="number">2</span> <span class="number">200</span> http:<span class="comment">//xxxx.png 日本&#125;</span></span><br></pre></td></tr></table></figure><p>先定义后赋值或者字面量赋值都可以，值得一提的是在Go里面如果结构体或者其属性的首字母大写则表示该结构体或者属性可以被导出，也就是被其它包使用。结构体里面的属性成员的类型也可以是结构体，这就变相实现了类的继承。</p><p>既然结构体和类差不多，那类的方法在哪里定义呢？这点Go实现的就比较巧妙了！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Goods)</span> <span class="title">getName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> g.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要在函数的前面放一个变量，就变成了方法。在很多语言里面，函数和方法区分不是很明显，大部分时候我们都是混着叫，但是在Go里面，方法指的是针对某一类型的函数。比如在上面的例子里面，这个<strong>getName</strong>函数就是针对<strong>Goods</strong>结构体的,用面向对象的说法就是一个类方法。所以我们可以使用 <code>goods.getName()</code>的形式调用这个方法。</p><blockquote><p>上面的代码里那个附加的参数p，叫做方法的接收器（receiver），早期的面向对象语言留下的遗产将调用一个方法称为“向一个对象发送消息”。<br> 在Go语言中，我们并不会像其它语言那样用this或者self作为接收器；我们可以任意的选择接收器的名字。由于接收器的名字经常会被使用到，所以保持其在方法间传递时的一致性和简短性是不错的主意。这里的建议是可以使用其类型的第一个字母。</p></blockquote><p>在Go里面我们可以为任何类型定义方法，无论是常见的int、string，还是map、struct都没问题，下面的例子里面就是为int类型扩展一个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myInt := MyInt(<span class="number">10</span>)</span><br><span class="line">    res := myInt.add(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%d"</span>, res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyInt)</span> <span class="title">add</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(m) + a</span><br><span class="line">&#125;</span><br><span class="line">---结果---</span><br><span class="line"><span class="number">110</span></span><br></pre></td></tr></table></figure><p>我们无法直接使用基本数据类型，但是我们可以起一个别名，纯属娱乐！</p><h2 id="5-JSON"><a href="#5-JSON" class="headerlink" title="5.JSON"></a>5.JSON</h2><p>严格来说，JSON并不是一种数据类型，但是json是现在最流行的数据交换格式，Go对json的支持也很好，在Go里面主要通过结构体生成json，我们也可以把一个json转换成结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Goods <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="keyword">string</span></span><br><span class="line">    Price   <span class="keyword">int</span></span><br><span class="line">    Address <span class="keyword">string</span> <span class="string">`json:"address2"`</span></span><br><span class="line">    Tag     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    goods := Goods&#123;</span><br><span class="line">        <span class="string">"商品1"</span>, <span class="number">100</span>, <span class="string">"中国"</span>, <span class="string">"特价"</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bytes, err := json.Marshal(goods)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%s"</span>, bytes)</span><br><span class="line">&#125;</span><br><span class="line">---结果---</span><br><span class="line">&#123;<span class="string">"Name"</span>:<span class="string">"商品1"</span>,<span class="string">"Price"</span>:<span class="number">100</span>,<span class="string">"address2"</span>:<span class="string">"中国"</span>,<span class="string">"Tag"</span>:<span class="string">"特价"</span>&#125;</span><br></pre></td></tr></table></figure><p>把结构体转换成json可以使用Marshal方法，有一点需要注意: 结构体的属性成员首字母必须大写，但是可以使用注解的Tag标注转换成json之后的key名称。</p><p>json字符串转换成结构体步骤差不多：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Goods <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="keyword">string</span></span><br><span class="line">    Price   <span class="keyword">int</span></span><br><span class="line">    Address <span class="keyword">string</span> <span class="string">`json:"address2"`</span></span><br><span class="line">    Tag     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    jsonStr := <span class="string">`&#123;"Name":"商品1","Price":100,"address2":"中国","Tag":"特价"&#125;`</span></span><br><span class="line"></span><br><span class="line">    goods := Goods&#123;&#125;</span><br><span class="line"></span><br><span class="line">    err := json.Unmarshal([]<span class="keyword">byte</span>(jsonStr), &amp;goods)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%v"</span>, goods)</span><br><span class="line">&#125;</span><br><span class="line">---结果---</span><br><span class="line">&#123;商品<span class="number">1</span> <span class="number">100</span>  特价&#125;</span><br></pre></td></tr></table></figure><p>这在我们平时写接口或者请求接口的时候非常好使，简单易用！</p><p>好了，今天就介绍这么多了，谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闲着无事，随便写写，初学Go，望各位大神轻喷！Go自带的几个复合数据类型，基本数据类型咱就不说了，大部分语言常见的几种复合数据类型大概有数组、字典、对象等，不同语言叫法不一样，用法也有差异，比如说PHP里面数组其实严格来说不算数组。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程开发" scheme="https://wangbjun.site/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.site/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>解决sudo command not found 报错</title>
    <link href="https://wangbjun.site/2019/linux/sudo-command-not-found.html"/>
    <id>https://wangbjun.site/2019/linux/sudo-command-not-found.html</id>
    <published>2019-06-02T03:29:06.000Z</published>
    <updated>2020-03-05T14:52:59.022Z</updated>
    
    <content type="html"><![CDATA[<p>偶尔发现的一个问题，平时主要使用 <strong>Ubuntu</strong> 操作系统，有时候安装一些软件会用加一些自定义PATH，往往为了方便都会把配置写到  <strong>/etc/environment</strong> 里面,这样所有用户包括root都有效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jwang@jwang:~$ cat &#x2F;etc&#x2F;environment </span><br><span class="line">PATH&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:</span><br><span class="line">&#x2F;bin:&#x2F;usr&#x2F;games:&#x2F;usr&#x2F;local&#x2F;games:&#x2F;home&#x2F;jwang&#x2F;MyBin:&#x2F;opt&#x2F;go&#x2F;bin&quot;</span><br><span class="line">export GOPATH&#x3D;&#x2F;home&#x2F;jwang&#x2F;Go</span><br></pre></td></tr></table></figure><a id="more"></a><p>比如说安装了go，在使用 <strong>sudo go</strong> 这样命令的时候会报错，但是切换到 root 用户却没有问题，使用普通用户也没问题，查了一下发现原来 sudo 里面有一些配置：</p><img src="/images/old/3571187-2c5fdea0a1fd3101.png" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo visudo</span><br></pre></td></tr></table></figure><img src="/images/old/3571187-319d779b9cae7fc2.png" /><p>在这个 <strong>/etc/sudoers</strong> 文件里面，有一个secure_path配置，大家一看就知道了，它的意思当你使用 <strong>sudo+command</strong> 这种形式执行命令的时候会从其配置的路径里面寻找命令，肯定是没有你自定义的PATH的，这个主要是安全考虑。</p><p><strong>解决方法</strong>有几种：</p><ol><li><p>直接把自定义PATH路径配置在secure_path里面，简单粗暴，就是有点麻烦</p></li><li><p>将 Defaults env_reset 改成 Defaults !env_reset 取消掉对PATH变量的重置，然后在.bashrc中最后添加alias sudo=’sudo env PATH=$PATH’，这个感觉更麻烦</p></li><li><p>直接把这3行注释掉，经测试完全没有任何问题</p></li></ol><p>我是采用第3种方式解决的，非常好用，暂时未发现问题！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;偶尔发现的一个问题，平时主要使用 &lt;strong&gt;Ubuntu&lt;/strong&gt; 操作系统，有时候安装一些软件会用加一些自定义PATH，往往为了方便都会把配置写到  &lt;strong&gt;/etc/environment&lt;/strong&gt; 里面,这样所有用户包括root都有效：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;jwang@jwang:~$ cat &amp;#x2F;etc&amp;#x2F;environment &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PATH&amp;#x3D;&amp;quot;&amp;#x2F;usr&amp;#x2F;local&amp;#x2F;sbin:&amp;#x2F;usr&amp;#x2F;local&amp;#x2F;bin:&amp;#x2F;usr&amp;#x2F;sbin:&amp;#x2F;usr&amp;#x2F;bin:&amp;#x2F;sbin:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;bin:&amp;#x2F;usr&amp;#x2F;games:&amp;#x2F;usr&amp;#x2F;local&amp;#x2F;games:&amp;#x2F;home&amp;#x2F;jwang&amp;#x2F;MyBin:&amp;#x2F;opt&amp;#x2F;go&amp;#x2F;bin&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export GOPATH&amp;#x3D;&amp;#x2F;home&amp;#x2F;jwang&amp;#x2F;Go&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://wangbjun.site/categories/Linux/"/>
    
    
      <category term="Sudo" scheme="https://wangbjun.site/tags/Sudo/"/>
    
  </entry>
  
  <entry>
    <title>Golang的依赖注入简介</title>
    <link href="https://wangbjun.site/2019/coding/golang/golang-di.html"/>
    <id>https://wangbjun.site/2019/coding/golang/golang-di.html</id>
    <published>2019-05-15T13:13:49.000Z</published>
    <updated>2020-03-06T17:05:15.850Z</updated>
    
    <content type="html"><![CDATA[<p>DI - Dependency Injection，即“依赖注入”，是指组件之间依赖关系由容器在运行期决定，与此同时还有一个叫作IOC的词汇，IOC即控制反转。</p><p>理论上讲，这2个概念都是基于OOP编程而产生的思想，在OOP编程里面，我们强调对象之间的依赖关系，比如说对象B依赖对象A的某些功能，我们就说B依赖A。</p><p>DI毕竟不是Go语言的专利，它是一种编程思想，在很多语言里面都有体现和实现，相信很多具有编程经验的人也有所了解，下面咱们直接开始讲在Go语言里面怎么使用DI。</p><a id="more"></a><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>Golang的DI目前主要有2种方式，一种是使用反射特性实现，代表开源项目有facebook/inject，还有uber/dig。另一种是代码自动生成，代表开源项目有google/wire。</p><p>下面咱们看一个案例：</p><p>由于Go并不是纯OOP语言，所以这里使用struct模拟对象的概念，有3个对象，其中App依赖DB和Redis。</p><p>DB：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Object</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123;</span><br><span class="line">    config <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(DB)</span> <span class="title">Get</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"I am DB"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Object</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Redis <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Redis)</span> <span class="title">Get</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"I am Redis"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>App:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Object</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> App <span class="keyword">struct</span> &#123;</span><br><span class="line">    r  Redis</span><br><span class="line">    db DB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p App)</span> <span class="title">Work</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"I can work"</span>)</span><br><span class="line">    p.db.Get()</span><br><span class="line">    p.r.Get()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不使用依赖注入，我们只能手动解决依赖，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"di/Object"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    app := Object.App&#123;</span><br><span class="line">        R:  Object.Redis&#123;&#125;,</span><br><span class="line">        DB: Object.DB&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    app.Work()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法并无太大问题，简单安全，不过项目非常大的时候，对象之间依赖关系复杂，手动解决依赖可能非常麻烦，这时候就需要自动注入依赖了。</p><h2 id="facebook-inject"><a href="#facebook-inject" class="headerlink" title="facebook/inject"></a>facebook/inject</h2><p>这是Facebook开源的一个项目，地址：github.com/facebookgo/inject</p><p>它使用struct的tag声明依赖，第一个无值语法是针对关联类型的单例依赖的常见情况。第二个触发器创建关联类型的私有实例。最后一个是要求一个名为 “dev logger” 的依赖关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#96;inject:&quot;&quot;&#96;</span><br><span class="line">&#96;inject:&quot;private&quot;&#96;</span><br><span class="line">&#96;inject:&quot;dev logger&quot;&#96;</span><br></pre></td></tr></table></figure><p>下面以App为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> App <span class="keyword">struct</span> &#123;</span><br><span class="line">    R  Redis <span class="string">`inject:""`</span></span><br><span class="line">    DB DB <span class="string">`inject:""`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"di/Object"</span></span><br><span class="line">    <span class="string">"github.com/facebookgo/inject"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> g inject.Graph</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> app Object.App</span><br><span class="line"></span><br><span class="line">    _ = g.Provide(</span><br><span class="line">        &amp;inject.Object&#123;Value: &amp;Object.DB&#123;&#125;,&#125;,</span><br><span class="line">        &amp;inject.Object&#123;Value: &amp;Object.Redis&#123;&#125;,&#125;,</span><br><span class="line">        &amp;inject.Object&#123;Value: &amp;app,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    _ = g.Populate()</span><br><span class="line"></span><br><span class="line">    app.Work()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给struct tag只是第一步，在程序启动的时候需要先注入依赖。</p><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>一般说到依赖注入必然会用到反射，说到Go的反射，大多数人都会说性能很差。</p><p>这个inject库也是用到了反射原理，性能会不会很差呢？</p><p>其实还是看用法，官方推荐在应用程序启动的时候注入所有依赖，而不是在运行中注入依赖，这样即使慢，也只是程序每次启动的时候慢，并不影响后续的运行情况。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DI - Dependency Injection，即“依赖注入”，是指组件之间依赖关系由容器在运行期决定，与此同时还有一个叫作IOC的词汇，IOC即控制反转。&lt;/p&gt;
&lt;p&gt;理论上讲，这2个概念都是基于OOP编程而产生的思想，在OOP编程里面，我们强调对象之间的依赖关系，比如说对象B依赖对象A的某些功能，我们就说B依赖A。&lt;/p&gt;
&lt;p&gt;DI毕竟不是Go语言的专利，它是一种编程思想，在很多语言里面都有体现和实现，相信很多具有编程经验的人也有所了解，下面咱们直接开始讲在Go语言里面怎么使用DI。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程开发" scheme="https://wangbjun.site/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.site/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang处理TCP“粘包”问题</title>
    <link href="https://wangbjun.site/2019/coding/golang/golang-tcp-package.html"/>
    <id>https://wangbjun.site/2019/coding/golang/golang-tcp-package.html</id>
    <published>2019-05-10T04:05:45.000Z</published>
    <updated>2020-03-06T17:10:14.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是粘包？"><a href="#1-什么是粘包？" class="headerlink" title="1.什么是粘包？"></a>1.什么是粘包？</h2><p>“粘包”这个说法已经被诟病很久了，既然坊间流传这个说法咱们就沿用吧，关于这个问题比较准确的解释可以参考下面几点：</p><ol><li>TCP是流传输协议,是一种面向连接的、可靠的、基于字节流的传输层通信协议</li><li>TCP没有包的概念，它只负责传输字节序列，UDP是面向数据报的协议，所以不存在拆包粘包问题</li><li>应该由应用层来维护消息和消息的边界，即需要一个应用层协议，比如HTTP</li></ol><p>所以，本质上这是一个没有正确使用TCP协议的而产生的问题，有网友说了一句非常形象的话：“打开家里的水龙头， 看着自来水往下流， 然后你告诉我， 看， 自来水粘在一起了， 不是有病？”</p><a id="more"></a><h2 id="2-如何解决粘包？"><a href="#2-如何解决粘包？" class="headerlink" title="2.如何解决粘包？"></a>2.如何解决粘包？</h2><p>通常来说，一般有下面几种方式：</p><ol><li>消息长度固定，提前确定包长度，读取的时候也安固定长度读取，适合定长消息包。</li><li>使用特殊的字符或字符串作为消息的边界，例如 HTTP 协议的 headers 以“\r\n”为字段的分隔符</li><li>自定义协议，将消息分为消息头和消息体，消息头中包含表示消息总长度</li></ol><h2 id="3-Golang实战"><a href="#3-Golang实战" class="headerlink" title="3.Golang实战"></a>3.Golang实战</h2><p>首先，来看一个存在粘包问题的例子：</p><h3 id="一、Server端："><a href="#一、Server端：" class="headerlink" title="一、Server端："></a>一、Server端：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listen, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8888"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> listen.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := listen.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            data := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">            _, err := conn.Read(data)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Printf(<span class="string">"%s\n"</span>, err.Error())</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            receive := <span class="keyword">string</span>(data)</span><br><span class="line">            log.Printf(<span class="string">"receive msg: %s\n"</span>, receive)</span><br><span class="line"></span><br><span class="line">            send := []<span class="keyword">byte</span>(strings.ToUpper(receive))</span><br><span class="line">            _, err = conn.Write(send)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Printf(<span class="string">"send msg failed, error: %s\n"</span>, err.Error())</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            log.Printf(<span class="string">"send msg: %s\n"</span>, receive)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单说一下这段代码，有点socket编程的基础的话应该很容易理解，基本上都是Listen -&gt; Accept -&gt; Read这个套路。</p><blockquote><p>有些人一下子就看出来这个服务有点“问题”，它是同步阻塞的，也就意味着这个服务同一时间只能处理一个连接请求，其实解决这个问题也很简单，得益于Go协程的强大，我们只需要开启一个协程单独处理每一个连接就行了。不过这不是今天的主题，有兴趣的童鞋可以自行研究。</p></blockquote><h3 id="二、Client端："><a href="#二、Client端：" class="headerlink" title="二、Client端："></a>二、Client端：</h3><p>这个服务的功能特别简单，客户端输入什么我就返回什么，客户端的话，这里我使用telnet来演示：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jwang@jwang:~$ telnet 127.0.0.1 8888</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to 127.0.0.1.</span><br><span class="line">Escape character is '^]'.</span><br><span class="line">111111</span><br><span class="line">111111</span><br><span class="line">123456</span><br><span class="line">123456</span><br></pre></td></tr></table></figure><blockquote><p>当你按回车键的时候telnet会在消息后面自动追加”\r\n“换行符并发送消息！</p></blockquote><p>从代码里面可以看到，在接受消息的时候我们每次读取10个字节的内容输出并返回，如果输入的消息小于等于8（减去换行符）个字符的时候没有问题，但是当我们在telnet里面输入大于10个字符的内容的时候，这些数据的时候会被强行拆开处理。</p><p>当然这里有人说了，可不可以一次读多点，然而读多少都会存在这个问题，而且TCP会有缓存区，不一定能够及时把消息发出去，像Nagle优化算法会将多次间隔较小、数据量小的数据，合并成一个大的数据块，然后进行封包，还是会存在问题。</p><p>如果我们把这个内容看作是一个业务消息，这个业务消息就被拆分放到下个消息里面处理，必然会产生问题，这就是“粘包”问题的由来。说到底，还是用的人的问题，没有确定好数据边界，如果简单粗暴的读取固定长度的内容，必然会出现问题。</p><h2 id="4-边界符解决粘包问题"><a href="#4-边界符解决粘包问题" class="headerlink" title="4.边界符解决粘包问题"></a>4.边界符解决粘包问题</h2><p>前面说过这个问题，我们可以通过定义一个边界符号解决粘包问题，比如说在上面的例子里面telnet会自动在每一条消息后面追加“\r\n”符号，我们恰好可以利用这点来区分消息。</p><ol><li>定义一个buffer来临时存放消息</li><li>从conn里面读取固定字节大小内容，判断当前内容里面有没有分隔符</li><li>如果没有找到分隔符，把当前内容追加到buffer里面，然后重复第2步</li><li>如果找到分隔符，把当前内容里面分隔符之前的内容追加到buffer后输出</li><li>然后重置buffer，把分隔符之后的内容追加到buff，重复第2步 </li></ol><p>不过Go里面提供了一个非常好用的buffer库，为我们节省了很多操作</p><p>我们可以使用bufio库里面的NewReader把conn包装一下，然后使用ReadSlice方法读取内容，该方法会一直读直到遇到分隔符，非常简单实用。</p><h3 id="一、Server端：-1"><a href="#一、Server端：-1" class="headerlink" title="一、Server端："></a>一、Server端：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listen, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8888"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> listen.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := listen.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">        reader := bufio.NewReader(conn)</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            slice, err := reader.ReadSlice(<span class="string">'\n'</span>)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Printf(<span class="string">"%s"</span>, slice)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、Client端：-1"><a href="#二、Client端：-1" class="headerlink" title="二、Client端："></a>二、Client端：</h3><p>Client这里可以直接使用telnet，也可以自己写一个，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8888"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(<span class="string">"dial error:"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> err error</span><br><span class="line">        _, err = conn.Write([]<span class="keyword">byte</span>(strconv.Itoa(i) + <span class="string">" =&gt; 77777\n"</span>))</span><br><span class="line">        _, err = conn.Write([]<span class="keyword">byte</span>(strconv.Itoa(i) + <span class="string">" =&gt; 88888\n"</span>))</span><br><span class="line">        _, err = conn.Write([]<span class="keyword">byte</span>(strconv.Itoa(i) + <span class="string">" =&gt; 555555555555555555555555555555555555555555\n"</span>))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">        _, err = conn.Write([]<span class="keyword">byte</span>(strconv.Itoa(i) + <span class="string">" =&gt; 123456\n"</span>))</span><br><span class="line">        _, err = conn.Write([]<span class="keyword">byte</span>(strconv.Itoa(i) + <span class="string">" =&gt; 123456\n"</span>))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">        _, err = conn.Write([]<span class="keyword">byte</span>(strconv.Itoa(i) + <span class="string">" =&gt; 9999999\n"</span>))</span><br><span class="line">        _, err = conn.Write([]<span class="keyword">byte</span>(strconv.Itoa(i) + <span class="string">" =&gt; 0000000000000000000000000000000000000000000\n"</span>))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要说缺点，这种方式主要存在2点，第一点是分隔符的选择问题，如果需要传输的消息包含分隔符，那就需要提前做转义处理。第二点就是性能问题，如果消息体特别大，每次查找分隔符的位置的话肯定会有一点消耗。</p><h2 id="5-在头部放入信息长度"><a href="#5-在头部放入信息长度" class="headerlink" title="5.在头部放入信息长度"></a>5.在头部放入信息长度</h2><p>目前应用最广泛的是在消息的头部添加数据包长度，接收方根据消息长度进行接收；在一条TCP连接上，数据的流式传输在接收缓冲区里是有序的，其主要的问题就是第一个包的包尾与第二个包的包头共存接收缓冲区，所以根据长度读取是十分合适的。</p><h3 id="一、Server端：-2"><a href="#一、Server端：-2" class="headerlink" title="一、Server端："></a>一、Server端：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"encoding/binary"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listen, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8888"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> listen.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := listen.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">        reader := bufio.NewReader(conn)</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">//前4个字节表示数据长度</span></span><br><span class="line">            peek, err := reader.Peek(<span class="number">4</span>)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            buffer := bytes.NewBuffer(peek)</span><br><span class="line">            <span class="comment">//读取数据长度</span></span><br><span class="line">            <span class="keyword">var</span> length <span class="keyword">int32</span></span><br><span class="line">            err = binary.Read(buffer, binary.BigEndian, &amp;length)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//Buffered 返回缓存中未读取的数据的长度,如果缓存区的数据小于总长度，则意味着数据不完整</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">int32</span>(reader.Buffered()) &lt; length+<span class="number">4</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从缓存区读取大小为数据长度的数据</span></span><br><span class="line">            data := <span class="built_in">make</span>([]<span class="keyword">byte</span>, length+<span class="number">4</span>)</span><br><span class="line">            _, err = reader.Read(data)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Printf(<span class="string">"receive data: %s\n"</span>, data[<span class="number">4</span>:])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、Client端：-2"><a href="#二、Client端：-2" class="headerlink" title="二、Client端："></a>二、Client端：</h3><p>需要注意的是发送数据的编码，这里使用了Go的binary库，先写入4个字节的头，再写入消息主体，最后一起发送过去。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"encoding/binary"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8888"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(<span class="string">"dial error:"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        data, _ := Encode(<span class="string">"123456789"</span>)</span><br><span class="line">        _, err := conn.Write(data)</span><br><span class="line">        data, _ = Encode(<span class="string">"888888888"</span>)</span><br><span class="line">        _, err = conn.Write(data)</span><br><span class="line">        time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">        data, _ = Encode(<span class="string">"777777777"</span>)</span><br><span class="line">        _, err = conn.Write(data)</span><br><span class="line">        data, _ = Encode(<span class="string">"123456789"</span>)</span><br><span class="line">        _, err = conn.Write(data)</span><br><span class="line">        time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encode</span><span class="params">(message <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 读取消息的长度</span></span><br><span class="line">    <span class="keyword">var</span> length = <span class="keyword">int32</span>(<span class="built_in">len</span>(message))</span><br><span class="line">    <span class="keyword">var</span> pkg = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    <span class="comment">// 写入消息头</span></span><br><span class="line">    err := binary.Write(pkg, binary.BigEndian, length)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写入消息实体</span></span><br><span class="line">    err = binary.Write(pkg, binary.BigEndian, []<span class="keyword">byte</span>(message))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pkg.Bytes(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p>世界上本没有“粘包”，只不过是少数人没有正确处理TCP数据边界问题，成熟的应用层协议（http、ssh）都不会存在这个问题。但是如果你使用纯TCP自定义协议，那就需要自己处理好了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-什么是粘包？&quot;&gt;&lt;a href=&quot;#1-什么是粘包？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是粘包？&quot;&gt;&lt;/a&gt;1.什么是粘包？&lt;/h2&gt;&lt;p&gt;“粘包”这个说法已经被诟病很久了，既然坊间流传这个说法咱们就沿用吧，关于这个问题比较准确的解释可以参考下面几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TCP是流传输协议,是一种面向连接的、可靠的、基于字节流的传输层通信协议&lt;/li&gt;
&lt;li&gt;TCP没有包的概念，它只负责传输字节序列，UDP是面向数据报的协议，所以不存在拆包粘包问题&lt;/li&gt;
&lt;li&gt;应该由应用层来维护消息和消息的边界，即需要一个应用层协议，比如HTTP&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，本质上这是一个没有正确使用TCP协议的而产生的问题，有网友说了一句非常形象的话：“打开家里的水龙头， 看着自来水往下流， 然后你告诉我， 看， 自来水粘在一起了， 不是有病？”&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程开发" scheme="https://wangbjun.site/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.site/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 4K显示器缩放设置</title>
    <link href="https://wangbjun.site/2019/linux/ubuntu-4k-scale.html"/>
    <id>https://wangbjun.site/2019/linux/ubuntu-4k-scale.html</id>
    <published>2019-05-03T04:21:06.000Z</published>
    <updated>2020-03-05T14:52:28.799Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://wangbjun.github.io/images/old/16d0f0f03263cb7b.jpg" alt=""></p><p>开头一张图介绍一下我现在日常生活和开发使用的电脑配置：Ubuntu 16.04 + i7-8700k + 1060 + nvme ssd + 32G RAM + 4k显示器，这个配置倒不算很高端，但是开发用体验很高，系统的流畅程度非常高</p><a id="more"></a><p>电脑CPU和内存可以差点，ssd是必须有的，另外还有一个亮点是LG的4k显示器，这个体验非常棒，现在4k显示器非常便宜，我这个也就2k左右的价格。</p><p>今天的主题就是4k显示器，众所周知，Mac的显示效果之所以出众是由于其高超的屏幕分辨率，几年前Mac都已经用上了3k分辨率，而且大多数Windows笔记本还用着1080p，苹果的IMac早已经用上了5k显示器。</p><p>换句话说，买Mac买的就是显示屏，没有屏幕的硬件加持，什么操作系统优化都是扯淡！有了4k显示器，你发现装上Windows显示效果也不差，不过这块我需要说一下，同等硬件下，Linux和Mac的显示效果确实要比Windows好一点，对高分屏的支持好很多。</p><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>我个人比较喜欢unity桌面，所以还是用Ubuntu 16.04，我曾经尝试过Ubuntu 18.04，但是感觉gnome桌面在流畅度和易用性方面和unity还是有不少差距，所以本篇文章可能支持适合unity桌面吧</p><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>如果你要换4k显示屏，有一点需要注意，不少i7 CPU 内置集显理论上是带的动4k+60fps的，但是只支持dp接口，不支持hdmi，这一点可以在intel官网的cpu详细规格里面可以查阅。但是大部分主板都不会带dp接口，很少很少，只有极少部分高端主板会带，而现在大部分独显都会带dp口。</p><p>众所周知，NVIDIA的独显在Linux上面的驱动支持都不是太好，但是intel的集显支持非常好，如果你想要使用4k显示器，一个独显少不了，不过据我目前的使用体验来说，1060 表现还不错，建议大家开启高性能模式，如下图：<br><img src="https://wangbjun.github.io/images/old/16d0f203bbf9601b.jpg" alt=""></p><h2 id="缩放设置"><a href="#缩放设置" class="headerlink" title="缩放设置"></a>缩放设置</h2><p>这是重点，根据我经验，在4k+27英寸显示器的配置下，缩放设置很简单，不需要什么环境变量，直接在显示里面设置缩放就行，默认是1，设置一个1.75-2比较合适。<br><img src="https://wangbjun.github.io/images/old/16d0f23300cd21d1.jpg" alt=""><br>实际上，上面这个设置好，已经可以解决99%的缩放问题了，不需要什么环境变量，上一些应用的图给大家看看：</p><p><img src="https://wangbjun.github.io/images/old/16d0f26799e5bf08.jpg" alt=""></p><p><img src="https://wangbjun.github.io/images/old/16d0f27645283d4e.jpg" alt=""></p><p><img src="https://wangbjun.github.io/images/old/16d0f27f294742ce.jpg" alt=""></p><h2 id="deepin缩放"><a href="#deepin缩放" class="headerlink" title="deepin缩放"></a>deepin缩放</h2><p>有些软件不走上面的缩放设置，比如deepin qq或wechat，估计很多用Linux的都会使用移植的deepin应用，但是也有办法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WINEPREFIX&#x3D;~&#x2F;.deepinwine&#x2F;Deepin-WeChat deepin-wine winecfg</span><br></pre></td></tr></table></figure><p>在弹出的对话框里面找到graphics设置，设置一个比较合适的dpi，以我个人经验，150-170比较合适，如下图：<br><img src="https://wangbjun.github.io/images/old/16d0f2ba8e833515.jpg" alt=""></p><h2 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h2><p>网易云的软件在4k下面也是个刺头，暂时没有完美的方案，但是有一个可以凑合用，在网易的desktop文件Exec配置里面加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--force-device-scale-factor&#x3D;1.75</span><br></pre></td></tr></table></figure><h2 id="搜狗输入法"><a href="#搜狗输入法" class="headerlink" title="搜狗输入法"></a>搜狗输入法</h2><p>搜狗输入法其实也是不支持4k自动缩放的，不过我们可以把皮肤的字体设置大一点，达到的效果是一样的：<br><img src="https://wangbjun.github.io/images/old/16d0f301af11cca2.jpg" alt=""></p><h2 id="QT系列软件"><a href="#QT系列软件" class="headerlink" title="QT系列软件"></a>QT系列软件</h2><p>Linux下面有很多基于QT开发的软件，它的缩放有可能是跟系统走的，但是也有可能不是，根据我的经验，QT需要设置一下2个环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export QT_DEVICE_PIXEL_RATIO&#x3D;2</span><br><span class="line">export QT_AUTO_SCREEN_SCALE_FACTOR&#x3D;1</span><br></pre></td></tr></table></figure><p>为什么有2个呢？据说第一个是老版本会用到，但是这个缩放因子只支持整数倍，你不能写1.5，有点蛋疼！</p><p>有些软件设置之后可能会放的太大，这时候我建议针对不同的软件，可以在启动之前使用export设置环境变量，或者在其快捷方式里面设置一下都可以，特殊情况特殊处理，但是大部分设置为2的话还可以接受。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://wangbjun.github.io/images/old/16d0f0f03263cb7b.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;开头一张图介绍一下我现在日常生活和开发使用的电脑配置：Ubuntu 16.04 + i7-8700k + 1060 + nvme ssd + 32G RAM + 4k显示器，这个配置倒不算很高端，但是开发用体验很高，系统的流畅程度非常高&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://wangbjun.site/categories/Linux/"/>
    
    
      <category term="Ubuntu" scheme="https://wangbjun.site/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Go面向对象写法</title>
    <link href="https://wangbjun.site/2019/coding/golang/golang-oop.html"/>
    <id>https://wangbjun.site/2019/coding/golang/golang-oop.html</id>
    <published>2019-04-19T14:05:43.000Z</published>
    <updated>2020-03-06T17:07:46.098Z</updated>
    
    <content type="html"><![CDATA[<p>Go并不是一个类似于Java、C++，或PHP这样内置面向对象语法的操作的语言，在Go里面名义上是没有类（class）这个概念的，但是这并不代表Go不能面向对象，毕竟面向对象只是一种设计思想！</p><p>为什么Go并不原生支持面向对象呢？这是一个问题</p><p>接下来，我会从面向对象的三大特性封装、继承、多态这个几个方面来讲讲Go是怎么实现的OOP的。</p><a id="more"></a><h3 id="1-封装"><a href="#1-封装" class="headerlink" title="1.封装"></a>1.封装</h3><p>闲话少说，在Go里面可以使用结构体模拟类:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Goods <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    price <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Go里面有一个约定俗称的规则，变量名、结构体名、结构体属性成员名大写代表是公开权限，可以被其它包使用。类似于类的<strong>public</strong>属性。如果小写就类似于<strong>private</strong>属性。</p><p>类里面除了属性之外，一般会有自己的方法，在Go里面可以这样实现(这里我采用的是Go modules结构)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Goods <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">    Price <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Goods)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> g.Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Goods)</span> <span class="title">SetName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    g.Name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Goods)</span> <span class="title">String</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"I am Goods"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是在函数名前加一个类型声明，如果你在方法里面不需要使用类本身，则可以省略参数标识。</p><p>如何使用这个“类呢”？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"demo/models"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    goods := models.Goods&#123;</span><br><span class="line">        <span class="string">"笔记本"</span>, <span class="number">100</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Printf(<span class="string">"Goods name is %s\n"</span>, goods.GetName())</span><br><span class="line">    </span><br><span class="line">    goods.SetName(<span class="string">"小米笔记本"</span>)</span><br><span class="line">    </span><br><span class="line">    fmt.Printf(<span class="string">"Goods name is %s\n"</span>, goods.GetName())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以采用字面量赋值的方式初始化对象，虽然结构体并没有构造函数这个东西，但是我们可以造个差不多的方式出来。</p><p>新增这个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGoods</span><span class="params">(name <span class="keyword">string</span>, price <span class="keyword">int</span>)</span> <span class="title">Goods</span></span> &#123;</span><br><span class="line">    g := Goods&#123;</span><br><span class="line">        Name:  name,</span><br><span class="line">        Price: price,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就可以这样使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> goods models.Goods</span><br><span class="line">goods = models.NewGoods(<span class="string">"笔记本"</span>, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>其实区别倒是不大，封装了一下，更加简洁，虽然达不到构造函数自动调用的效果。</p><h3 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h3><p>Go里面并没有extends这样的语法，但是结构体的成员可以是结构体，这实际上是使用组合实现了继承的效果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Apple <span class="keyword">struct</span> &#123;</span><br><span class="line">    Goods <span class="comment">//继承了Goods</span></span><br><span class="line">    Color <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewApple</span><span class="params">(name <span class="keyword">string</span>, price <span class="keyword">int</span>, color <span class="keyword">string</span>)</span> <span class="title">Apple</span></span> &#123;</span><br><span class="line">    apple := Apple&#123;</span><br><span class="line">        Goods&#123;name, price&#125;,</span><br><span class="line">        color,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> apple</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.go:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"demo/models"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    apple := models.NewApple(<span class="string">"红富士苹果"</span>, <span class="number">200</span>, <span class="string">"red"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"Apple name is %s"</span>, apple.GetName())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Apple可以使用Goods的方法和属性，使用组合的好处就是不存在多继承的限制，在很多面向对象的语言里面，只能单继承。</p><h3 id="3-多态"><a href="#3-多态" class="headerlink" title="3.多态"></a>3.多态</h3><p>虽然Go里面也没有implements这样的关键字，但是在Go里面可以使用interface来实现多态效果，而且Go里面的接口相当灵活。</p><p>定义接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Saleable <span class="keyword">interface</span> &#123;</span><br><span class="line">    Sell()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现接口(Apple)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Apple)</span> <span class="title">Sell</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    fmt.Println(<span class="string">"我实现了saleable接口"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    apple := models.NewApple(<span class="string">"红富士苹果"</span>, <span class="number">200</span>, <span class="string">"red"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> i models.Saleable</span><br><span class="line">    </span><br><span class="line">    i = &amp;apple</span><br><span class="line">    </span><br><span class="line">    i.Sell()</span><br><span class="line">&#125;</span><br><span class="line">---结果---</span><br><span class="line">我实现了saleable接口</span><br></pre></td></tr></table></figure><p>划重点，在GO里面只要一个结构体（struct）定义了一个接口(interface)里面的所有方法，就意味着这个这个struct实现了这个接口，这是隐式的。可见，在Go里面接口还是挺好用的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go并不是一个类似于Java、C++，或PHP这样内置面向对象语法的操作的语言，在Go里面名义上是没有类（class）这个概念的，但是这并不代表Go不能面向对象，毕竟面向对象只是一种设计思想！&lt;/p&gt;
&lt;p&gt;为什么Go并不原生支持面向对象呢？这是一个问题&lt;/p&gt;
&lt;p&gt;接下来，我会从面向对象的三大特性封装、继承、多态这个几个方面来讲讲Go是怎么实现的OOP的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程开发" scheme="https://wangbjun.site/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.site/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>详解中间件设计模式</title>
    <link href="https://wangbjun.site/2019/coding/designpattern-middleware.html"/>
    <id>https://wangbjun.site/2019/coding/designpattern-middleware.html</id>
    <published>2019-03-12T02:02:46.000Z</published>
    <updated>2020-03-05T14:51:07.479Z</updated>
    
    <content type="html"><![CDATA[<p>说到中间件（middleware），很多人应该都听说过，但是大体有2种意思，一种是一些衔接不同软件活系统的中间软件，比如说数据库中间件、消息中间件。另一种是在Web软件开发中代码层面的一种设计模式，比如说用户认证中间件、日志中间件，这些中间件的主要作用就是以一种集中统一、几乎无侵入的的方式去处理用户请求,而今天我们要讲的就是中间件设计模式。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>说起中间件模式，估计很多人都想起来下面这张图，一个Web请求经过多个中间件的过滤，像pipeline一样处理这个请求，最终返回响应。</p><img src = "/images/old/5f6e3e27ly1g3ow77jcovj20it0e9aas.jpg" /><p>中间件往往部署在路由的地方，用于统一过滤请求，举个例子，我们有一个特殊的服务，必须要求用户的年龄大于18岁，如果不使用中间件，我们传统的做法就是在每个请求的控制器或者方法里面做判断，从功能上说没啥问题，但是代码不够优雅，需要写很多重复代码，而且不利于维护，哪天我们要把这个年龄改成20岁呢？</p><img src = "/images/old/5f6e3e27ly1g3owo9uj4hj20i30a1t9o.jpg" /><p>但是常见的23种设计模式里面并没有中间件模式，其实中间件是管道模式（也有人说是装饰模式）的一种实现，我也不知道为什么大部分框架都叫做中间件(middleware)…?</p><p>说个题外话，大部分设计模式主要就是为了解耦，提高代码可维护性和扩展性，并不是必须的，但是大部分情况下还是有益的。</p><h2 id="管道模式"><a href="#管道模式" class="headerlink" title="管道模式"></a>管道模式</h2><p>管道又称为pipeline，又叫流水线，工厂里面流水线大家应该都见过，一个产品需要经过很多道工序才能完成，比如苹果手机的一根数据线，大概有20多道工序，在工厂里面这些数据线会被放到传送带上面，依次完成各个工序，我们可以把一个请求看作是一个产品，流水线的每道工序看作是处理对象。</p><p>下面直接看代码：</p><p>1.Middleware.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Middleware</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">execute</span><span class="params">(Closure $next)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.LogMiddleware.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogMiddleware</span> <span class="keyword">implements</span> <span class="title">Middleware</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">execute</span><span class="params">(Closure $next)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Before Log!\n"</span>;</span><br><span class="line">        $next();</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"After Log!\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.AuthMiddleware.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthMiddleware</span> <span class="keyword">implements</span> <span class="title">Middleware</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">execute</span><span class="params">(Closure $next)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Before Check Auth!\n"</span>;</span><br><span class="line">        $next();</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"After Check Auth!\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.Client.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $middlewares = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addMiddleware</span><span class="params">(Middleware $middleware)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;middlewares[] = $middleware;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getClosure</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">($current, $next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($current, $next)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">new</span> $next)-&gt;execute($current);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">defaultHandler</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"开始处理!\n"</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handler</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        call_user_func(array_reduce(<span class="keyword">$this</span>-&gt;middlewares, <span class="keyword">$this</span>-&gt;getClosure(), <span class="keyword">$this</span>-&gt;defaultHandler()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们定义了一个Middleware接口，规定了需要实现的方法，然后定义了多个具体实现类。有一个非常关键的地方就是这个方法的参数是有一个闭包函数，然后在实现类里面我们都必须调用这个方法。</p><p>最核心的代码在于Client类，首先它有一个成员变量，里面存储了多个实现了Middleware接口的对象，这个类里面最关键的方法就是getClosure，它返回一个闭包函数，这个闭包函数接受2个参数，这2个参数都是实现了Middleware接口的对象，但是这个闭包函数并没有立马执行。</p><p>其中一个非常关键的函数就是array_reduce,根据官方文档，array_reduce() 将回调函数 callback 迭代地作用到 array 数组中的每一个单元中，从而将数组简化为单一的值。先看一个非常简单的例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">$sum = array_reduce($arr, <span class="string">'sum'</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">($a, $b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"before add: $a, $b\n"</span>;</span><br><span class="line">  $sum =  $a + $b;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"after add: $a, $b\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> $sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump($sum);</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">before add: <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">after add: <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">before add: <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">after add: <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">before add: <span class="number">3</span>, <span class="number">3</span></span><br><span class="line">after add: <span class="number">3</span>, <span class="number">3</span></span><br><span class="line">before add: <span class="number">6</span>, <span class="number">4</span></span><br><span class="line">after add: <span class="number">6</span>, <span class="number">4</span></span><br><span class="line">before add: <span class="number">10</span>, <span class="number">5</span></span><br><span class="line">after add: <span class="number">10</span>, <span class="number">5</span></span><br><span class="line"></span><br><span class="line">int(<span class="number">15</span>)</span><br></pre></td></tr></table></figure><p>可见array_reduce会循环的把数组里面的数据两两代入函数，然后把返回的结果当作新的参数再次代入函数,最终会返回一个多层嵌套的闭包函数，然后通过call_user_func触发调用，这时候就会像拨洋葱一样，先从外面到里面，再从里面往外面。。。</p><p>上面的例子运行代码和结果如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$client = <span class="keyword">new</span> Client();</span><br><span class="line"></span><br><span class="line">$client-&gt;addMiddleware(<span class="keyword">new</span> LogMiddleware())</span><br><span class="line">    -&gt;addMiddleware(<span class="keyword">new</span> AuthMiddleware());</span><br><span class="line"></span><br><span class="line">$client-&gt;handler();</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Before Check age!</span><br><span class="line">Before Log!</span><br><span class="line">开始处理!</span><br><span class="line">After Log!</span><br><span class="line">After Check Age!</span><br></pre></td></tr></table></figure><p>仔细看一下这个结果，是不是非常像第一张图那样，不过这个例子里面少了一个非常重要的request对象，这里纯粹只是展示中间件运行原理，完整的实战代码可以参考laravel框架里面的源码，实现原理差不多，只不过框架功能更加全面，考虑的东西更多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说到中间件（middleware），很多人应该都听说过，但是大体有2种意思，一种是一些衔接不同软件活系统的中间软件，比如说数据库中间件、消息中间件。另一种是在Web软件开发中代码层面的一种设计模式，比如说用户认证中间件、日志中间件，这些中间件的主要作用就是以一种集中统一、几乎无侵入的的方式去处理用户请求,而今天我们要讲的就是中间件设计模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程开发" scheme="https://wangbjun.site/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="中间件" scheme="https://wangbjun.site/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Golang字符串处理函数浅析</title>
    <link href="https://wangbjun.site/2019/coding/golang/golang-string-function.html"/>
    <id>https://wangbjun.site/2019/coding/golang/golang-string-function.html</id>
    <published>2019-02-12T12:15:43.000Z</published>
    <updated>2020-03-06T17:10:14.990Z</updated>
    
    <content type="html"><![CDATA[<p>很多从PHP转Go的小伙伴经常会怀恋PHP丰富的字符串函数，Go的标准库针对字符串的操作函数虽然不少但是还是不够丰富，很多时候还得自己造，下面我就结合PHP里面字符串的操作函数来说说Go里面怎么实现。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>Go是强类型语言，有一个单独的字符串类型 string，如果熟悉Go语言的人应该了解string底层是切片，切片底层是数组，所以字符串也叫字符数组。</p><p>举个最简单的例子，有一个字符串 12ab34cd56, 我们要获取其第3到第5个字符之间的元素怎么做呢？</p><p>熟悉PHP的童鞋可以会想到PHP里面有一个 substr的函数可以做到，但是Go里面呢？</p><p>我们打开IDE看一下，其实标准库里面的 strings 包已经有非常多的函数了，大约有20多个，包含常见的trim、index、replace、contain等功能，但是没有找到我们想要的？</p><p>其实很简单，因为string本质上是切片，所以我们可以直接使用切片来分割字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">"12ab34cd56"</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, str[<span class="number">2</span>:<span class="number">4</span>]) <span class="comment">//ab</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, str[<span class="number">3</span>:]) <span class="comment">//b34cd56</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, str[:<span class="number">3</span>]) <span class="comment">//12a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片的切割用法就不多说了，从0角标开始，包含开始，不包含结束。</p><p>不过这种写法是有bug的，它只可以针对单字节字符，针对中文这种多字节字符串就不可以了，PHP里面也一样，PHP里面针对多字节字符有一个 mbstring 扩展，也有 mb_substr 这样的函数专门处理多字节字符。</p><h2 id="Rune"><a href="#Rune" class="headerlink" title="Rune"></a>Rune</h2><p>在国内编程，大部分时候不可避免的要处理中文字符串，所以像计算长度、切割一定要处理好多字节的问题，Go里面针对多字节的字符有一个rune类型，针对上面的这个问题，我们这样做：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">"我爱学习Go语言"</span></span><br><span class="line"></span><br><span class="line">    rStr := []<span class="keyword">rune</span>(str)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, <span class="keyword">string</span>(rStr[<span class="number">2</span>:<span class="number">4</span>])) <span class="comment">//学习</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, <span class="keyword">string</span>(rStr[<span class="number">3</span>:])) <span class="comment">//习Go语言</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, <span class="keyword">string</span>(rStr[:<span class="number">3</span>])) <span class="comment">//我爱学</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式完全没问题，如果说问题可能就在于多了一次内存分配，那rune到底是什么呢？</p><p>rune类型在Go里面实际上是int32的别名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is</span></span><br><span class="line"><span class="comment">// used, by convention, to distinguish byte values from 8-bit unsigned</span></span><br><span class="line"><span class="comment">// integer values.</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rune is an alias for int32 and is equivalent to int32 in all ways. It is</span></span><br><span class="line"><span class="comment">// used, by convention, to distinguish character values from integer values.</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br></pre></td></tr></table></figure><p>byte是8位，可以表示-128-127之间的数，用来存储单字节字符刚好，但是中文一般使用2-3个字节表示，byte就无能为力了，但是int32用来表示世界上所有字符也绰绰有余。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">r := <span class="string">"我爱学习Go语言"</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, r)</span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, []<span class="keyword">byte</span>(r))</span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, []<span class="keyword">rune</span>(r))</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果如下：</span></span><br><span class="line">我爱学习Go语言</span><br><span class="line">[<span class="number">230</span> <span class="number">136</span> <span class="number">145</span> <span class="number">231</span> <span class="number">136</span> <span class="number">177</span> <span class="number">229</span> <span class="number">173</span> <span class="number">166</span> <span class="number">228</span> <span class="number">185</span> <span class="number">160</span> <span class="number">71</span> <span class="number">111</span> <span class="number">232</span> <span class="number">175</span> <span class="number">173</span> <span class="number">232</span> <span class="number">168</span> <span class="number">128</span>]</span><br><span class="line">[<span class="number">25105</span> <span class="number">29233</span> <span class="number">23398</span> <span class="number">20064</span> <span class="number">71</span> <span class="number">111</span> <span class="number">35821</span> <span class="number">35328</span>]</span><br></pre></td></tr></table></figure><p>从上面的例子也可以说明，中文“我”实际上是以230 136 145 3个字节表示的，但是在rune类型里面是以25105表示的，这个数是Unicode编码的10进制表现形式。</p><p>所以，我们可以把一个字符串先转成rune数组，然后再使用切片切割。</p><h2 id="for…range"><a href="#for…range" class="headerlink" title="for…range"></a>for…range</h2><p>字符串本质上是字符数组，所以有也可以使用range遍历，而且range在迭代字符串的时候也是按字符遍历的，我们也可以利用这点分割字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubString</span><span class="params">(str <span class="keyword">string</span>, start, end <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n, i, k <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k = <span class="keyword">range</span> str &#123;</span><br><span class="line">        <span class="keyword">if</span> n == start &#123;</span><br><span class="line">            i = k</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> n == end &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        n++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str[i:k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><p>再看一个比较常见的PHP函数，反转字符串，在Go标准库里面也没有相应的实现</p><p>如果只考虑单字节我们可以很容易写出下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReverseString</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    b := []<span class="keyword">byte</span>(str)</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(b)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(b)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        b[i], b[j] = b[j], b[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果考虑到中文等多字节字符可以参考下面这种方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReverseRuneString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> start, size, end <span class="keyword">int</span></span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(s))</span><br><span class="line">    <span class="keyword">for</span> end &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        _, size = utf8.DecodeRuneInString(s[start:])</span><br><span class="line">        end = start + size</span><br><span class="line">        <span class="built_in">copy</span>(buf[<span class="built_in">len</span>(buf)-end:], s[start:end])</span><br><span class="line">        start = end</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(buf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p>除了字符串之外，PHP的数组功能也很强大，如果你不想自己造轮子，可以使用现成的第三方库，下面简单介绍一下几个项目：</p><h3 id="1-https-github-com-syyongx-php2go"><a href="#1-https-github-com-syyongx-php2go" class="headerlink" title="1.https://github.com/syyongx/php2go"></a>1.<a href="https://github.com/syyongx/php2go" target="_blank" rel="noopener">https://github.com/syyongx/php2go</a></h3><p>这个项目是使用Go实现PHP内置的函数库，东西比较多，不过这个库里面并没有特殊处理多字节字符串，需要注意一下。</p><h3 id="2-https-github-com-thinkeridea-go-extend"><a href="#2-https-github-com-thinkeridea-go-extend" class="headerlink" title="2.https://github.com/thinkeridea/go-extend"></a>2.<a href="https://github.com/thinkeridea/go-extend" target="_blank" rel="noopener">https://github.com/thinkeridea/go-extend</a></h3><p>这个项目收集了一些常用的操作函数，辅助更快的完成开发工作，并减少重复代码，都是一些比较实用的函数，虽然没有第一个那么全。</p><h3 id="3-https-github-com-jianfengye-collection"><a href="#3-https-github-com-jianfengye-collection" class="headerlink" title="3.https://github.com/jianfengye/collection"></a>3.<a href="https://github.com/jianfengye/collection" target="_blank" rel="noopener">https://github.com/jianfengye/collection</a></h3><p>Collection包目标是用于替换golang原生的Slice，使用场景是在大量不追求极致性能，追求业务开发效能的场景。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很多从PHP转Go的小伙伴经常会怀恋PHP丰富的字符串函数，Go的标准库针对字符串的操作函数虽然不少但是还是不够丰富，很多时候还得自己造，下面我就结合PHP里面字符串的操作函数来说说Go里面怎么实现。&lt;/p&gt;
&lt;h2 id=&quot;String&quot;&gt;&lt;a href=&quot;#String
      
    
    </summary>
    
    
      <category term="编程开发" scheme="https://wangbjun.site/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Golang" scheme="https://wangbjun.site/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Web开发中用到的Cache</title>
    <link href="https://wangbjun.site/2019/coding/web-cache-usage.html"/>
    <id>https://wangbjun.site/2019/coding/web-cache-usage.html</id>
    <published>2019-02-01T04:02:46.000Z</published>
    <updated>2020-03-05T14:51:07.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是Cache？"><a href="#1-什么是Cache？" class="headerlink" title="1.什么是Cache？"></a>1.什么是Cache？</h2><p>Cache(音: 侃屎),中文称为缓存，缓存可以说是计算机系统里面一味良药，在很多地方的设计都用到了Cache，比如在CPU里面的一级缓存，二级缓存，好的CPU还有三级缓存。硬盘也有缓存，比如一般1T的机械硬盘会有64M的闪存缓存。</p><p><img src="/images/2020-03-03.jpg" alt=""></p><p>在软件系统里面，缓存更是无处不在，比如浏览器本地缓存、网络缓存、CDN缓存、代理缓存…</p><a id="more"></a><p>缓存是一种设计思想，在现实生活中也有很多应用，比如京东物流，大家都知道在京东上面买东西快递非常快，那是因为京东在很多大城市的周围建立了自己的仓库，京东把销量比较好的商品提前放在仓库里面。当你下单的时候京东直接从附近的仓库给你发货，速度当然快，最快的情况下几个小时就可以收货。</p><p>如果不这样做，直接从厂家发货，比如你在北京，买的东西是从广东生产的，估计至少要2-3天！</p><h2 id="2-Cache解决的是什么问题？"><a href="#2-Cache解决的是什么问题？" class="headerlink" title="2.Cache解决的是什么问题？"></a>2.Cache解决的是什么问题？</h2><p>Cache主要解决数据获取成本高的问题,当你获取一个数据特别麻烦，成本非常高，这里的成本高可能是时间成本，比如网络请求时间，或者是验证问题，并且这个数据是重复的，多次获取的数据完全一样，那你就可以使用缓存。</p><p>在软件开发中，最常见的用法就是用来替代关系型数据库某些功能，比如在一个电商网站里面，一个商品的数据一旦上架之后很少改动，正常情况下，用户每次刷新页面都需要从数据库多个表里面获取同样的商品数据，如果网站用户非常多，这对数据库压力还是很大的，这时候就可以使用缓存，把每个商品的数据缓存起来，关于缓存在哪里这个问题咱们待会再说。</p><blockquote><p>最常见的做法就是以key-value的形式缓存数据，比如在上面的例子里面，以商品ID为key，商品信息为value。缓存一方面是为了降低数据库压力，这样就不用每次都查询数据库了，而且还可以提高网站速度，因为很多缓存是存储在内存里面的，这比磁盘的响应和读取速度高很多数量级。</p></blockquote><p>比如浏览器缓存，很多浏览器都会缓存网站的资源文件，比如图片,js,css,fonts，这样我们就不用每次去网站获取，提高了网页加载速度之外还节省了流量！</p><p>在很多数据变化不大，或者对数据时效性要求不高的地方我们都可以使用缓存来提供应用速度，比如接口缓存，假如我们需要调用一个外部接口获取一些数据，但是这个接口比较慢而我们又需要重复去获取这些数据，这时候也可以加缓存。但是缓存并不是银弹，缓存用的不好也会带来一些数据错乱问题，影响系统功能。</p><h2 id="3-Cache时效问题"><a href="#3-Cache时效问题" class="headerlink" title="3.Cache时效问题"></a>3.Cache时效问题</h2><p>缓存时效是使用缓存最需要解决的问题，比如上面说到的商品信息缓存，虽然这个商品信息并不是经常改动，但是万一改动了呢？这就会带来数据不一致问题。解决这个问题有2种相对简单的方法，一种是给缓存设置一个有效期，比如说缓存10分钟，10分钟之后缓存就会失效，然后重新从数据库查询数据重新设置缓存。</p><p>这样即使数据不一致，也最多只会影响10分钟，这在一些对数据时效性要求不高的应用里面也可以接受，主要是操作简单。</p><p>另一种方式则是在修改数据的时候主动更新缓存，这在方式虽然保证了缓存是最新的，但是操作起来并不简单，一个系统里面可能有多个修改数据的入口，如果某一个地方忘记更新缓存…。为了解决这个问题，有些人采用监控数据库binlog日志的方法来更新缓存，因为无论你通过什么方法修改数据，最终都要操作数据库，这样做虽然有效，但是明显更复杂。</p><p>当然我们也可以结合这2种方式，既给缓存设置一定的有效期，也在修改数据的时候更新缓存，这样即使忘记更新缓存，也能保证数据最终会一致。</p><img src = "/images/old/5f6e3e27ly1fymbog7e6zj20i707m0tf.jpg" /><p>在http协议里面，缓存是非常重要的，为了解决缓存时效性问题，协议定义了很多header，比如 Expires、Cache-Control、Last-Modified、If-Modified-Since、Etag，具体含义和用法这里不过多解释，但是这些协议头只是约定了一些规则，具体怎么实现还得看web服务器以及中间的代理服务器，其最终目的都是为了既能充分利用浏览器缓存提供网页加载速度，也能及时获取最新数据。</p><h2 id="4-缓存分类"><a href="#4-缓存分类" class="headerlink" title="4.缓存分类"></a>4.缓存分类</h2><p>如果从客户端到服务器中间的过程来分，缓存一般分为这几种：</p><h3 id="1-客户端缓存。"><a href="#1-客户端缓存。" class="headerlink" title="1.客户端缓存。"></a>1.客户端缓存。</h3><p>这个最常见的就是浏览器缓存，除此之外，其它很多手机App，客户端App理论上讲都可以使用缓存。</p><h3 id="2-代理服务器缓存"><a href="#2-代理服务器缓存" class="headerlink" title="2.代理服务器缓存"></a>2.代理服务器缓存</h3><p>最常见的就是各种CDN缓存。有些公司或者企业内部可能也有自己的缓存服务器。还有一些第三方宽带运营商，比如长城宽带，宽带通这类一般内部都有自己的缓存服务器，因为这些宽带服务商的的流量需要向电信、联通购买，如果它们内部能够缓存常用的资源，就可以大大节省流量开销，这也是为什么这些宽带便宜的原因之一。</p><h3 id="3-服务器缓存"><a href="#3-服务器缓存" class="headerlink" title="3.服务器缓存"></a>3.服务器缓存</h3><p>一个请求如果在客户端本地，中间代理服务器都没有找到缓存的资源，它就会到达最终服务器，我们一般说的 memcached，redis缓存就是指服务器缓存。服务器缓存根据类型的不同也可以分好几种：<br><img src = "/images/old/5f6e3e27ly1fymcn95eewj20ha09174r.jpg" /></p><h4 id="一-本地缓存"><a href="#一-本地缓存" class="headerlink" title="一.本地缓存"></a>一.本地缓存</h4><p>顾名思义，就是指我们把数据缓存在服务器本地，可细分为文件缓存和内存缓存，文件缓存一般适合少量数据，操作简单，读取速度一般，自带持久化，不会比数据库快很多。内存缓存是把数据存储在服务器内存里面，和内存一样，只要Web服务不重启，数据就不会丢失，和文件缓存比，内存缓存要快很多。</p><p>但是如果你有多台Web服务器并且做了负载均衡，使用本地缓存可能会带来数据不一致问题，更新起来更麻烦，一般很少用。</p><h4 id="二-远程缓存"><a href="#二-远程缓存" class="headerlink" title="二.远程缓存"></a>二.远程缓存</h4><p>这是针对本地缓存而言，所谓远程是指有一个服务器专门提供缓存服务，多台服务器使用同一个缓存服务，这就解决了本地缓存的问题。咱们最常用的memcached和redis就是属于远程内存缓存，其中redis支持持久化。</p><h4 id="三-分布式缓存"><a href="#三-分布式缓存" class="headerlink" title="三.分布式缓存"></a>三.分布式缓存</h4><p>这是第二种类型的扩展，这时候我们不仅仅有多台Web服务器，还有多台缓存服务器，这时候我们需要解决缓存服务器之间的数据同步问题！</p><h2 id="5-常见内存缓存应用"><a href="#5-常见内存缓存应用" class="headerlink" title="5.常见内存缓存应用"></a>5.常见内存缓存应用</h2><p>通常情况下，我们很少自己去实现缓存服务，往往采用成熟的第三方缓存应用，通常有以下2个：</p><h3 id="1-memcached"><a href="#1-memcached" class="headerlink" title="1.memcached"></a>1.memcached</h3><p>功能简单，只支持常用的增删改查操作，只支持string类型，不支持持久化，不支持集群，性能优秀。</p><h3 id="2-redis"><a href="#2-redis" class="headerlink" title="2.redis"></a>2.redis</h3><p>基本上可以说memcached有的redis都有，memcached没有的redis也有，redis支持的数据类型非常多，功能强大，而且支持持久化，自带集群功能，社区活跃。所以基本上现在使用redis居多，memcached用来存储session这样的临时数据比较合适。如果只做缓存的话，memcached性能要比redis好那么一丢丢而已，但是redis的功能可不仅仅是缓存。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-什么是Cache？&quot;&gt;&lt;a href=&quot;#1-什么是Cache？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是Cache？&quot;&gt;&lt;/a&gt;1.什么是Cache？&lt;/h2&gt;&lt;p&gt;Cache(音: 侃屎),中文称为缓存，缓存可以说是计算机系统里面一味良药，在很多地方的设计都用到了Cache，比如在CPU里面的一级缓存，二级缓存，好的CPU还有三级缓存。硬盘也有缓存，比如一般1T的机械硬盘会有64M的闪存缓存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2020-03-03.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在软件系统里面，缓存更是无处不在，比如浏览器本地缓存、网络缓存、CDN缓存、代理缓存…&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程开发" scheme="https://wangbjun.site/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Cache" scheme="https://wangbjun.site/tags/Cache/"/>
    
  </entry>
  
</feed>
